{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#_1","title":"About","text":"<p>A Python package to simplify working with EarthCARE satellite data.</p> <p>Caution</p> <p>Project Status: In Development</p> <p>This project is still under active development. It is not yet feature-complete, and parts of the user documentation are missing or incomplete. Use at your own risk and expect breaking changes. Feedback and contributions are welcome!</p>"},{"location":"#what-is-earthcarekit","title":"What is <code>earthcarekit</code>?","text":"<p><code>earthcarekit</code> is an open-source Python package that provides comprehensive and flexible tools for downloading, reading, analysing and visualizing data from ESA (European Space Ageny) and JAXA's (Japan Aerospace Exploration Agency) joint satellite mission EarthCARE (Earth Cloud, Aerosol and Radiation Explorer, Wehr et al., 2023). The goal of this software is to support the diverse calibration/validation (cal/val) and scientific efforts related to the mission and provide easy-to-use functions for new EarthCARE data users.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2b07\ufe0f Download - Access EarthCARE data via the command line or your Python scripts.</li> <li>\ud83d\udd0d Search &amp; Read - Search your local EarthCARE products and open them as <code>xarray.Dataset</code> objects with unified dimension names.</li> <li>\u2699\ufe0f Process - Make use of a comprehensive set of functions, including filtering by time or geographic location, extracting vertical profile statistics, rebinning, along-track interpolation from X-MET files, and merging consecutive EarthCARE datasets, and more.</li> <li>\ud83d\udcca Visualize - Create quicklooks and plot vertical and across-track time series using a set of <code>matplotlib</code>/<code>cartopy</code>-based figure objects - while allowing customization.</li> <li>\ud83d\udcbb Command-Line Interface Tools:<ul> <li><code>ecdownload</code> - Search, select, and download EarthCARE data from a terminal.</li> <li><code>ecquicklook</code> - Create fast preview visualisations of EarthCARE datasets from a terminal.</li> </ul> </li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>The package is developed and maintained by Leonard K\u00f6nig at Leibniz Institute for Tropospheric Research (TROPOS). For questions, suggestions, or bug reports, please create an issue or reach out via email.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Colormap definitions for <code>calipso</code> and <code>chiljet2</code> were adapted from the exellent ectools repository by Shannon Mason (ECMWF).</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this software in your work, please cite it. We recommend citing the specific version you are using, which you can select on Zenodo.</p> <p>Alternatively, if you want to cite version-independent use:</p> <pre><code>@software{koenig_2025_earthcarekit,\n  author       = {K\u00f6nig, Leonard and\n                  Floutsi, Athena Augusta and\n                  Haarig, Moritz and\n                  Baars, Holger and\n                  Wandinger, Ulla},\n  title        = {earthcarekit: A Python package to simplify working\n                   with EarthCARE satellite data\n                  },\n  month        = aug,\n  year         = 2025,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.16813294},\n  url          = {https://doi.org/10.5281/zenodo.16813294},\n}\n</code></pre> <p>or in text:</p> <p>K\u00f6nig, L., Floutsi, A. A., Haarig, M., Baars, H., &amp; Wandinger, U. (2025). earthcarekit: A Python package to simplify working with EarthCARE satellite data. Zenodo. https://doi.org/10.5281/zenodo.16813294</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License (see LICENSE file or https://opensource.org/license/mit).</p>"},{"location":"#third-party-licenses","title":"Third-Party Licenses","text":"<p>This project relies on several open-source packages. Their licenses include:</p> <ul> <li>MIT License: <code>plotly</code>, <code>cmcrameri</code>, <code>vedo</code>, <code>netcdf4</code>, <code>tomli-w</code></li> <li>BSD License: <code>numpy</code>, <code>pandas</code>, <code>scipy</code>, <code>seaborn</code>, <code>owslib</code>, <code>jupyterlab</code>, <code>h5netcdf</code></li> <li>Apache 2.0 License: <code>xarray</code></li> <li>LGPL License: <code>cartopy</code></li> <li>PSF License: <code>matplotlib</code></li> </ul> <p>Please refer to each project's repository for detailed license information.</p>"},{"location":"#references","title":"References","text":"<ul> <li>Wehr, T., Kubota, T., Tzeremes, G., Wallace, K., Nakatsuka, H., Ohno, Y., Koopman, R., Rusli, S., Kikuchi, M., Eisinger, M., Tanaka, T., Taga, M., Deghaye, P., Tomita, E., and Bernaerts, D.: The EarthCARE mission \u2013 science and system overview, Atmos. Meas. Tech., 16, 3581\u20133608, https://doi.org/10.5194/amt-16-3581-2023, 2023.</li> </ul>"},{"location":"api_ref/","title":"earthcarekit","text":""},{"location":"api_ref/#api-reference","title":"API reference","text":"<p>earthcarekit</p> <p>A Python package to simplify working with EarthCARE satellite data</p> <p>See also:</p> <ul> <li>Documentation</li> <li>Development status (GitHub)</li> <li>License (MIT)</li> <li>Citation (Zenodo)</li> </ul> <p>Copyright (c) 2025 Leonard K\u00f6nig</p>"},{"location":"api_ref/#earthcarekit.cmaps","title":"cmaps  <code>module-attribute</code>","text":"<pre><code>cmaps = _get_custom_cmaps()\n</code></pre> <p>List of custom colormaps for earthcarekit.</p>"},{"location":"api_ref/#earthcarekit.Cmap","title":"Cmap","text":"<p>               Bases: <code>ListedColormap</code></p> <p>Colormap with categorical, gradient, and circular support.</p> <p>This subclass of <code>matplotlib.colors.ListedColormap</code> adds utilities for continuous and categorical color mappings. Supports labels, ticks, normalization, blending, and transparency adjustments.</p> <p>Attributes:</p> Name Type Description <code>categorical</code> <code>bool</code> <p>Whether the colormap is discrete/categorical.</p> <code>gradient</code> <code>bool</code> <p>Whether the colormap was generated from a gradient.</p> <code>circular</code> <code>bool</code> <p>Whether the colormap wraps around cyclically.</p> <code>ticks</code> <code>list[float]</code> <p>Optional tick positions for categorical plots.</p> <code>labels</code> <code>list[str]</code> <p>Optional labels corresponding to ticks.</p> <code>norm</code> <code>Normalize | None</code> <p>Normalization strategy for value mapping.</p> <code>values</code> <code>list</code> <p>Associated values for categorical mapping.</p> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>class Cmap(ListedColormap):\n    \"\"\"Colormap with categorical, gradient, and circular support.\n\n    This subclass of `matplotlib.colors.ListedColormap` adds utilities for\n    continuous and categorical color mappings. Supports labels, ticks,\n    normalization, blending, and transparency adjustments.\n\n    Attributes:\n        categorical (bool): Whether the colormap is discrete/categorical.\n        gradient (bool): Whether the colormap was generated from a gradient.\n        circular (bool): Whether the colormap wraps around cyclically.\n        ticks (list[float]): Optional tick positions for categorical plots.\n        labels (list[str]): Optional labels corresponding to ticks.\n        norm (Normalize | None): Normalization strategy for value mapping.\n        values (list): Associated values for categorical mapping.\n    \"\"\"\n\n    def __init__(\n        self,\n        colors,\n        name: str = \"colormap\",\n        N: int | None = None,\n        categorical: bool = False,\n        ticks: List[float] | None = None,\n        labels: List[str] | None = None,\n        norm: Normalize | None = None,\n        values: List | None = None,\n        gradient: bool = False,\n        circular: bool = False,\n    ):\n        \"\"\"Initialize a Cmap.\n\n        Args:\n            colors: Sequence of colors (strings or ColorLike objects).\n            name (str): Name of the colormap. Defaults to \"colormap\".\n            N (int | None): Number of discrete colors. Defaults to None.\n            categorical (bool): Whether the colormap is discrete/categorical. Defaults to False.\n            ticks (list[float] | None): Optional tick positions for categorical plots. Defaults to None.\n            labels (list[str] | None): Optional labels corresponding to ticks. Defaults to None.\n            norm (Normalize | None): Normalization strategy for value mapping. Defaults to None.\n            gradient (bool): If True, generate intermediate gradient colors. Defaults to False.\n            circular (bool): If True, colormap wraps around cyclically. Defaults to False.\n        \"\"\"\n        colors = [Color(c) if isinstance(c, str) else c for c in colors]\n\n        if gradient:\n            tmp_cmap = LinearSegmentedColormap.from_list(\"tmp_cmap\", colors, N=256)\n            colors = [tmp_cmap(i) for i in range(256)]\n\n        super().__init__(colors, name=name, N=N or len(colors))\n        self.categorical = categorical\n        self.gradient = gradient\n        self.circular = circular\n        self.ticks = ticks or []\n        self.labels = labels or []\n        self.norm = norm\n        self.values = values or []\n\n    @classmethod\n    def from_colormap(cls, cmap: Colormap, N: int = 256) -&gt; \"Cmap\":\n        \"\"\"Create a Cmap instance from an existing Matplotlib colormap.\n\n        Args:\n            cmap (Colormap): Source colormap to convert.\n            N (int): Number of discrete colors (if needed, e.g, for categorical\n                colormaps with limited number of colors). Defaults to 256.\n\n        Returns:\n            Cmap: New colormap.\n        \"\"\"\n        if isinstance(cmap, cls):\n            return cmap\n        elif isinstance(cmap, ListedColormap):\n            colors = list(cmap.colors)  # type: ignore\n            if isinstance(colors, np.ndarray) and colors.ndim == 2:\n                N = len(colors)\n            else:\n                N = cmap.N\n        else:\n            colors = [cmap(x) for x in np.linspace(0, 1, N)]\n\n        _colors = []\n        for c in colors:\n            if (\n                isinstance(c, (np.ndarray, list, tuple))\n                and not isinstance(c, str)\n                and all([_c &lt;= 1 for _c in c])\n            ):\n                _colors.append(Color(c, is_normalized=True))  # type: ignore\n            else:\n                _colors = [Color(c) for c in colors]  # type: ignore\n                continue\n        new_cmap = cls([c.hex for c in _colors], name=cmap.name, N=N)\n        new_cmap = copy_extremes(cmap, new_cmap)\n        return new_cmap\n\n    def to_categorical(\n        self,\n        values_to_labels: Dict[Any, str] | int,\n        endpoint: bool | None = None,\n        use_discrete: bool | None = None,\n    ) -&gt; \"Cmap\":\n        \"\"\"Convert a colormap to categorical.\n\n        Args:\n            values_to_labels (dict | int): Mapping from values to labels, or\n                number of categories if int.\n            endpoint (bool | None): Whether the last color is included at 1.0.\n            use_discrete (bool | None): If True, use the colormap's defined colors directly rather than sampling across its range.\n\n        Returns:\n            Cmap: Categorical version of the colormap.\n        \"\"\"\n        if isinstance(values_to_labels, int):\n            values_to_labels = {i: str(i) for i in range(values_to_labels)}\n\n        values_to_labels = dict(sorted(values_to_labels.items()))\n\n        keys = list(values_to_labels.keys())\n        labels = list(values_to_labels.values())\n        sorted_values = keys\n\n        n_classes = len(sorted_values)\n        bounds = np.array(sorted_values + [sorted_values[-1] + 1]) - 0.5\n        norm = BoundaryNorm(bounds, n_classes)\n\n        ticks = [float(t) for t in np.arange(0.5, n_classes)]\n\n        if use_discrete:\n            colors = [self(i) for i in range(n_classes)]\n        else:\n            if not isinstance(endpoint, bool):\n                endpoint = not self.circular\n            offset = -1 if endpoint else 0\n            colors = [self(i / max(n_classes + offset, 1)) for i in range(n_classes)]\n\n        return Cmap(\n            colors=colors,\n            name=self.name,\n            N=n_classes,\n            categorical=True,\n            gradient=False,\n            circular=self.circular,\n            ticks=ticks,\n            labels=labels,\n            norm=norm,\n            values=sorted_values,\n        )\n\n    def set_alpha(self, value: float) -&gt; \"Cmap\":\n        \"\"\"Return a copy of the colormap with modified alpha transparency.\n\n        Args:\n            value (float): Alpha value in the range [0, 1].\n\n        Returns:\n            Cmap: Colormap with updated transparency.\n        \"\"\"\n        if not 0 &lt;= value &lt;= 1:\n            raise ValueError(\n                f\"Invalid alpha value: '{value}' (must be in the 0-1 range)\"\n            )\n\n        new_cmap = Cmap(\n            colors=[Color(c).set_alpha(value) for c in np.asarray(self.colors)],\n            name=self.name,\n            N=self.N,\n            categorical=self.categorical,\n            gradient=self.gradient,\n            circular=self.circular,\n            ticks=self.ticks,\n            labels=self.labels,\n            norm=self.norm,\n        )\n\n        if self._rgba_bad is not None:  # type: ignore\n            new_cmap._rgba_bad = Color(self._rgba_bad, is_normalized=True).set_alpha(value).rgba  # type: ignore\n        if self._rgba_over is not None:  # type: ignore\n            new_cmap._rgba_over = Color(self._rgba_over, is_normalized=True).set_alpha(value).rgba  # type: ignore\n        if self._rgba_under is not None:  # type: ignore\n            new_cmap._rgba_under = Color(self._rgba_under, is_normalized=True).set_alpha(value).rgba  # type: ignore\n\n        return new_cmap\n\n    def blend(self, value: float, blend_color: Color | ColorLike = \"white\") -&gt; \"Cmap\":\n        \"\"\"Return a copy of the colormap blended with a second color.\n\n        Args:\n            value (float): Blend factor in the range [0, 1].\n            blend_color (Color | str): Color to blend with.\n\n        Returns:\n            Cmap: Blended colormap.\n        \"\"\"\n        if not 0 &lt;= value &lt;= 1:\n            raise ValueError(\n                f\"Invalid blend value: '{value}' (must be in the 0-1 range)\"\n            )\n\n        new_cmap = Cmap(\n            colors=[\n                Color(c).blend(value, blend_color) for c in np.asarray(self.colors)\n            ],\n            name=self.name,\n            N=self.N,\n            categorical=self.categorical,\n            gradient=self.gradient,\n            circular=self.circular,\n            ticks=self.ticks,\n            labels=self.labels,\n            norm=self.norm,\n        )\n\n        if self._rgba_bad is not None:  # type: ignore\n            new_cmap._rgba_bad = Color(self._rgba_bad, is_normalized=True).blend(value, blend_color).rgba  # type: ignore\n        if self._rgba_over is not None:  # type: ignore\n            new_cmap._rgba_over = Color(self._rgba_over, is_normalized=True).blend(value, blend_color).rgba  # type: ignore\n        if self._rgba_under is not None:  # type: ignore\n            new_cmap._rgba_under = Color(self._rgba_under, is_normalized=True).blend(value, blend_color).rgba  # type: ignore\n\n        return new_cmap\n\n    @property\n    def rgba_list(self) -&gt; list[tuple[float, ...]]:\n        \"\"\"List of RGBA tuples representing all colors in the colormap.\"\"\"\n        return [Color(c, is_normalized=True).rgba for c in np.array(self.colors)]\n\n    # def set_alpha_gradient(self, alpha_input: list) -&gt; \"Cmap\":\n    #     from matplotlib.colors import ListedColormap\n    #     from scipy.interpolate import interp1d\n\n    #     # Interpolate to 256 values\n    #     n_colors = 256\n    #     x_old = np.linspace(0, 1, len(alpha_input))\n    #     x_new = np.linspace(0, 1, n_colors)\n    #     alpha_interp = interp1d(x_old, alpha_input, kind=\"linear\")(x_new)\n\n    #     # Get base colormap and apply interpolated alpha\n    #     colors = self(np.linspace(0, 1, n_colors))\n    #     colors[:, 3] = alpha_interp  # Replace alpha channel\n\n    #     # Create transparent colormap\n    #     new_cmap = Cmap(colors, name=self.name)\n\n    @property\n    def opaque(self) -&gt; \"Cmap\":\n        \"\"\"Return an opaque version of the colormap (alpha set to 1).\"\"\"\n        return colormap_to_opaque(self)\n\n    @property\n    def alphamap(self) -&gt; \"Cmap\":\n        \"\"\"Return the alpha-mapped version of the colormap.\"\"\"\n        return colormap_to_alphamap(self)\n\n    @property\n    def blended(self) -&gt; \"Cmap\":\n        \"\"\"Return a blended version of the colormap (predefined blending).\"\"\"\n        return colormap_to_blended(self)\n\n    def __new__(cls, *args, **kwargs):\n        \"\"\"Allow instantiation from an existing Colormap or standard arguments.\"\"\"\n        if len(args) == 1 and isinstance(args[0], Colormap):\n            return cls.from_colormap(args[0])\n        return super().__new__(cls)\n</code></pre>"},{"location":"api_ref/#earthcarekit.Cmap.alphamap","title":"alphamap  <code>property</code>","text":"<pre><code>alphamap\n</code></pre> <p>Return the alpha-mapped version of the colormap.</p>"},{"location":"api_ref/#earthcarekit.Cmap.blended","title":"blended  <code>property</code>","text":"<pre><code>blended\n</code></pre> <p>Return a blended version of the colormap (predefined blending).</p>"},{"location":"api_ref/#earthcarekit.Cmap.opaque","title":"opaque  <code>property</code>","text":"<pre><code>opaque\n</code></pre> <p>Return an opaque version of the colormap (alpha set to 1).</p>"},{"location":"api_ref/#earthcarekit.Cmap.rgba_list","title":"rgba_list  <code>property</code>","text":"<pre><code>rgba_list\n</code></pre> <p>List of RGBA tuples representing all colors in the colormap.</p>"},{"location":"api_ref/#earthcarekit.Cmap.__init__","title":"__init__","text":"<pre><code>__init__(\n    colors,\n    name=\"colormap\",\n    N=None,\n    categorical=False,\n    ticks=None,\n    labels=None,\n    norm=None,\n    values=None,\n    gradient=False,\n    circular=False,\n)\n</code></pre> <p>Initialize a Cmap.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <p>Sequence of colors (strings or ColorLike objects).</p> required <code>name</code> <code>str</code> <p>Name of the colormap. Defaults to \"colormap\".</p> <code>'colormap'</code> <code>N</code> <code>int | None</code> <p>Number of discrete colors. Defaults to None.</p> <code>None</code> <code>categorical</code> <code>bool</code> <p>Whether the colormap is discrete/categorical. Defaults to False.</p> <code>False</code> <code>ticks</code> <code>list[float] | None</code> <p>Optional tick positions for categorical plots. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>Optional labels corresponding to ticks. Defaults to None.</p> <code>None</code> <code>norm</code> <code>Normalize | None</code> <p>Normalization strategy for value mapping. Defaults to None.</p> <code>None</code> <code>gradient</code> <code>bool</code> <p>If True, generate intermediate gradient colors. Defaults to False.</p> <code>False</code> <code>circular</code> <code>bool</code> <p>If True, colormap wraps around cyclically. Defaults to False.</p> <code>False</code> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>def __init__(\n    self,\n    colors,\n    name: str = \"colormap\",\n    N: int | None = None,\n    categorical: bool = False,\n    ticks: List[float] | None = None,\n    labels: List[str] | None = None,\n    norm: Normalize | None = None,\n    values: List | None = None,\n    gradient: bool = False,\n    circular: bool = False,\n):\n    \"\"\"Initialize a Cmap.\n\n    Args:\n        colors: Sequence of colors (strings or ColorLike objects).\n        name (str): Name of the colormap. Defaults to \"colormap\".\n        N (int | None): Number of discrete colors. Defaults to None.\n        categorical (bool): Whether the colormap is discrete/categorical. Defaults to False.\n        ticks (list[float] | None): Optional tick positions for categorical plots. Defaults to None.\n        labels (list[str] | None): Optional labels corresponding to ticks. Defaults to None.\n        norm (Normalize | None): Normalization strategy for value mapping. Defaults to None.\n        gradient (bool): If True, generate intermediate gradient colors. Defaults to False.\n        circular (bool): If True, colormap wraps around cyclically. Defaults to False.\n    \"\"\"\n    colors = [Color(c) if isinstance(c, str) else c for c in colors]\n\n    if gradient:\n        tmp_cmap = LinearSegmentedColormap.from_list(\"tmp_cmap\", colors, N=256)\n        colors = [tmp_cmap(i) for i in range(256)]\n\n    super().__init__(colors, name=name, N=N or len(colors))\n    self.categorical = categorical\n    self.gradient = gradient\n    self.circular = circular\n    self.ticks = ticks or []\n    self.labels = labels or []\n    self.norm = norm\n    self.values = values or []\n</code></pre>"},{"location":"api_ref/#earthcarekit.Cmap.__new__","title":"__new__","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Allow instantiation from an existing Colormap or standard arguments.</p> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>def __new__(cls, *args, **kwargs):\n    \"\"\"Allow instantiation from an existing Colormap or standard arguments.\"\"\"\n    if len(args) == 1 and isinstance(args[0], Colormap):\n        return cls.from_colormap(args[0])\n    return super().__new__(cls)\n</code></pre>"},{"location":"api_ref/#earthcarekit.Cmap.blend","title":"blend","text":"<pre><code>blend(value, blend_color='white')\n</code></pre> <p>Return a copy of the colormap blended with a second color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Blend factor in the range [0, 1].</p> required <code>blend_color</code> <code>Color | str</code> <p>Color to blend with.</p> <code>'white'</code> <p>Returns:</p> Name Type Description <code>Cmap</code> <code>Cmap</code> <p>Blended colormap.</p> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>def blend(self, value: float, blend_color: Color | ColorLike = \"white\") -&gt; \"Cmap\":\n    \"\"\"Return a copy of the colormap blended with a second color.\n\n    Args:\n        value (float): Blend factor in the range [0, 1].\n        blend_color (Color | str): Color to blend with.\n\n    Returns:\n        Cmap: Blended colormap.\n    \"\"\"\n    if not 0 &lt;= value &lt;= 1:\n        raise ValueError(\n            f\"Invalid blend value: '{value}' (must be in the 0-1 range)\"\n        )\n\n    new_cmap = Cmap(\n        colors=[\n            Color(c).blend(value, blend_color) for c in np.asarray(self.colors)\n        ],\n        name=self.name,\n        N=self.N,\n        categorical=self.categorical,\n        gradient=self.gradient,\n        circular=self.circular,\n        ticks=self.ticks,\n        labels=self.labels,\n        norm=self.norm,\n    )\n\n    if self._rgba_bad is not None:  # type: ignore\n        new_cmap._rgba_bad = Color(self._rgba_bad, is_normalized=True).blend(value, blend_color).rgba  # type: ignore\n    if self._rgba_over is not None:  # type: ignore\n        new_cmap._rgba_over = Color(self._rgba_over, is_normalized=True).blend(value, blend_color).rgba  # type: ignore\n    if self._rgba_under is not None:  # type: ignore\n        new_cmap._rgba_under = Color(self._rgba_under, is_normalized=True).blend(value, blend_color).rgba  # type: ignore\n\n    return new_cmap\n</code></pre>"},{"location":"api_ref/#earthcarekit.Cmap.from_colormap","title":"from_colormap  <code>classmethod</code>","text":"<pre><code>from_colormap(cmap, N=256)\n</code></pre> <p>Create a Cmap instance from an existing Matplotlib colormap.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>Colormap</code> <p>Source colormap to convert.</p> required <code>N</code> <code>int</code> <p>Number of discrete colors (if needed, e.g, for categorical colormaps with limited number of colors). Defaults to 256.</p> <code>256</code> <p>Returns:</p> Name Type Description <code>Cmap</code> <code>Cmap</code> <p>New colormap.</p> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>@classmethod\ndef from_colormap(cls, cmap: Colormap, N: int = 256) -&gt; \"Cmap\":\n    \"\"\"Create a Cmap instance from an existing Matplotlib colormap.\n\n    Args:\n        cmap (Colormap): Source colormap to convert.\n        N (int): Number of discrete colors (if needed, e.g, for categorical\n            colormaps with limited number of colors). Defaults to 256.\n\n    Returns:\n        Cmap: New colormap.\n    \"\"\"\n    if isinstance(cmap, cls):\n        return cmap\n    elif isinstance(cmap, ListedColormap):\n        colors = list(cmap.colors)  # type: ignore\n        if isinstance(colors, np.ndarray) and colors.ndim == 2:\n            N = len(colors)\n        else:\n            N = cmap.N\n    else:\n        colors = [cmap(x) for x in np.linspace(0, 1, N)]\n\n    _colors = []\n    for c in colors:\n        if (\n            isinstance(c, (np.ndarray, list, tuple))\n            and not isinstance(c, str)\n            and all([_c &lt;= 1 for _c in c])\n        ):\n            _colors.append(Color(c, is_normalized=True))  # type: ignore\n        else:\n            _colors = [Color(c) for c in colors]  # type: ignore\n            continue\n    new_cmap = cls([c.hex for c in _colors], name=cmap.name, N=N)\n    new_cmap = copy_extremes(cmap, new_cmap)\n    return new_cmap\n</code></pre>"},{"location":"api_ref/#earthcarekit.Cmap.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(value)\n</code></pre> <p>Return a copy of the colormap with modified alpha transparency.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Alpha value in the range [0, 1].</p> required <p>Returns:</p> Name Type Description <code>Cmap</code> <code>Cmap</code> <p>Colormap with updated transparency.</p> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>def set_alpha(self, value: float) -&gt; \"Cmap\":\n    \"\"\"Return a copy of the colormap with modified alpha transparency.\n\n    Args:\n        value (float): Alpha value in the range [0, 1].\n\n    Returns:\n        Cmap: Colormap with updated transparency.\n    \"\"\"\n    if not 0 &lt;= value &lt;= 1:\n        raise ValueError(\n            f\"Invalid alpha value: '{value}' (must be in the 0-1 range)\"\n        )\n\n    new_cmap = Cmap(\n        colors=[Color(c).set_alpha(value) for c in np.asarray(self.colors)],\n        name=self.name,\n        N=self.N,\n        categorical=self.categorical,\n        gradient=self.gradient,\n        circular=self.circular,\n        ticks=self.ticks,\n        labels=self.labels,\n        norm=self.norm,\n    )\n\n    if self._rgba_bad is not None:  # type: ignore\n        new_cmap._rgba_bad = Color(self._rgba_bad, is_normalized=True).set_alpha(value).rgba  # type: ignore\n    if self._rgba_over is not None:  # type: ignore\n        new_cmap._rgba_over = Color(self._rgba_over, is_normalized=True).set_alpha(value).rgba  # type: ignore\n    if self._rgba_under is not None:  # type: ignore\n        new_cmap._rgba_under = Color(self._rgba_under, is_normalized=True).set_alpha(value).rgba  # type: ignore\n\n    return new_cmap\n</code></pre>"},{"location":"api_ref/#earthcarekit.Cmap.to_categorical","title":"to_categorical","text":"<pre><code>to_categorical(values_to_labels, endpoint=None, use_discrete=None)\n</code></pre> <p>Convert a colormap to categorical.</p> <p>Parameters:</p> Name Type Description Default <code>values_to_labels</code> <code>dict | int</code> <p>Mapping from values to labels, or number of categories if int.</p> required <code>endpoint</code> <code>bool | None</code> <p>Whether the last color is included at 1.0.</p> <code>None</code> <code>use_discrete</code> <code>bool | None</code> <p>If True, use the colormap's defined colors directly rather than sampling across its range.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Cmap</code> <code>Cmap</code> <p>Categorical version of the colormap.</p> Source code in <code>earthcarekit/plot/color/colormap/cmap.py</code> <pre><code>def to_categorical(\n    self,\n    values_to_labels: Dict[Any, str] | int,\n    endpoint: bool | None = None,\n    use_discrete: bool | None = None,\n) -&gt; \"Cmap\":\n    \"\"\"Convert a colormap to categorical.\n\n    Args:\n        values_to_labels (dict | int): Mapping from values to labels, or\n            number of categories if int.\n        endpoint (bool | None): Whether the last color is included at 1.0.\n        use_discrete (bool | None): If True, use the colormap's defined colors directly rather than sampling across its range.\n\n    Returns:\n        Cmap: Categorical version of the colormap.\n    \"\"\"\n    if isinstance(values_to_labels, int):\n        values_to_labels = {i: str(i) for i in range(values_to_labels)}\n\n    values_to_labels = dict(sorted(values_to_labels.items()))\n\n    keys = list(values_to_labels.keys())\n    labels = list(values_to_labels.values())\n    sorted_values = keys\n\n    n_classes = len(sorted_values)\n    bounds = np.array(sorted_values + [sorted_values[-1] + 1]) - 0.5\n    norm = BoundaryNorm(bounds, n_classes)\n\n    ticks = [float(t) for t in np.arange(0.5, n_classes)]\n\n    if use_discrete:\n        colors = [self(i) for i in range(n_classes)]\n    else:\n        if not isinstance(endpoint, bool):\n            endpoint = not self.circular\n        offset = -1 if endpoint else 0\n        colors = [self(i / max(n_classes + offset, 1)) for i in range(n_classes)]\n\n    return Cmap(\n        colors=colors,\n        name=self.name,\n        N=n_classes,\n        categorical=True,\n        gradient=False,\n        circular=self.circular,\n        ticks=ticks,\n        labels=labels,\n        norm=norm,\n        values=sorted_values,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color","title":"Color  <code>dataclass</code>","text":"<p>               Bases: <code>str</code></p> <p>Represents a color with convenient conversion, blending, and alpha support.</p> <p>Extends <code>str</code> to store a color as a hex string while providing methods to access RGB/RGBA, set transparency, blend with other colors, and normalize input from various formats.</p> <p>Attributes:</p> Name Type Description <code>input</code> <code>ColorLike</code> <p>Original input used to create the color.</p> <code>name</code> <code>str | None</code> <p>Optional name of the color.</p> <code>is_normalized</code> <code>bool</code> <p>Whether the color values are normalized (0-1).</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>@dataclass(frozen=True)\nclass Color(str):\n    \"\"\"Represents a color with convenient conversion, blending, and alpha support.\n\n    Extends `str` to store a color as a hex string while providing methods\n    to access RGB/RGBA, set transparency, blend with other colors, and\n    normalize input from various formats.\n\n    Attributes:\n        input (ColorLike): Original input used to create the color.\n        name (str | None): Optional name of the color.\n        is_normalized (bool): Whether the color values are normalized (0-1).\n    \"\"\"\n\n    input: ColorLike\n    name: str | None = None\n    is_normalized: bool = False\n\n    def __new__(\n        cls,\n        color_input: \"Color\" | ColorLike,\n        name: str | None = None,\n        is_normalized: bool = False,\n    ):\n        \"\"\"Create a Color instance from a color-like input.\"\"\"\n        hex_color = cls._to_hex(color_input, is_normalized=is_normalized)\n        return str.__new__(cls, hex_color)\n\n    def __init__(\n        self,\n        color_input: \"Color\" | ColorLike,\n        name: str | None = None,\n        is_normalized: bool = False,\n    ):\n        \"\"\"Initialize Color attributes.\"\"\"\n        object.__setattr__(self, \"input\", color_input)\n        object.__setattr__(self, \"name\", name)\n        object.__setattr__(self, \"is_normalized\", is_normalized)\n\n    def __hash__(self):\n        \"\"\"Return the hash of the color string.\"\"\"\n        return hash(str(self))\n\n    @classmethod\n    def _rgb_str_to_hex(\n        cls,\n        rgb_string: str,\n        is_normalized: bool = False,\n    ) -&gt; str:\n        \"\"\"Convert an 'rgb(...)' string to a hex color.\"\"\"\n        if (not is_normalized and re.match(r\"^rgb\\(\\d*,\\d*,\\d*\\)$\", rgb_string)) or (\n            is_normalized\n            and re.match(r\"^rgb\\(\\d*\\.?\\d*,\\d*\\.?\\d*,\\d*\\.?\\d*\\)$\", rgb_string)\n        ):\n            rgb_str_list = rgb_string[4:-1].split(\",\")\n            if is_normalized:\n                rgb_tuple = tuple(float(v) for v in rgb_str_list)\n            else:\n                rgb_tuple = tuple(int(v) for v in rgb_str_list)\n            return cls._rgb_tuple_to_hex(rgb_tuple, is_normalized=is_normalized)\n        raise ValueError(f\"Invalid rgb color: '{rgb_string}'\")\n\n    @classmethod\n    def _rgba_str_to_hex(\n        cls,\n        rgba_string: str,\n        is_normalized: bool = False,\n    ) -&gt; str:\n        \"\"\"Convert an 'rgba(...)' string to a hex color.\"\"\"\n        if (\n            not is_normalized\n            and re.match(r\"^rgba\\(\\d*,\\d*,\\d*,\\d*\\.?\\d*\\)$\", rgba_string)\n        ) or (\n            is_normalized\n            and re.match(\n                r\"^rgba\\(\\d*\\.?\\d*,\\d*\\.?\\d*,\\d*\\.?\\d*,\\d*\\.?\\d*\\)$\", rgba_string\n            )\n        ):\n            rgba_str_list = rgba_string[5:-1].split(\",\")\n            if float(rgba_str_list[-1]) &gt; 1:\n                raise ValueError(\n                    f\"Invalid alpha value (must be float between 0 and 1): '{rgba_string}'\"\n                )\n            if is_normalized:\n                rgba_tuple = tuple(float(v) for v in rgba_str_list)\n            else:\n                rgba_tuple = tuple(\n                    int(v) if i &lt; 3 else float(v) for i, v in enumerate(rgba_str_list)\n                )\n            return cls._rgba_tuple_to_hex(rgba_tuple, is_normalized=is_normalized)\n        raise ValueError(f\"Invalid rgba color: '{rgba_string}'\")\n\n    @classmethod\n    def _rgb_tuple_to_hex(\n        cls,\n        rgb_tuple: Tuple[int, ...] | Tuple[float, ...],\n        is_normalized: bool = False,\n    ) -&gt; str:\n        \"\"\"Convert an RGB tuple to a hex color string.\"\"\"\n        if is_normalized:\n            rgb_tuple = tuple(int(v * 255) for v in rgb_tuple)\n        is_all_int = all(isinstance(v, int | np.integer) for v in rgb_tuple)\n        is_all_in_range = all(0 &lt;= v &lt;= 255 for v in rgb_tuple)\n        if is_all_int and is_all_in_range:\n            return \"#{:02X}{:02X}{:02X}\".format(*rgb_tuple)\n        raise ValueError(f\"Invalid rgb tuple: '{rgb_tuple}'\")\n\n    @classmethod\n    def _rgba_tuple_to_hex(\n        cls,\n        rgba_tuple: Tuple[int | float, ...],\n        is_normalized: bool = False,\n    ) -&gt; str:\n        \"\"\"Convert an RGBA tuple to a hex color string.\"\"\"\n        if is_normalized:\n            rgba_tuple = tuple(\n                int(v * 255) if i &lt; 3 else v for i, v in enumerate(rgba_tuple)\n            )\n        is_all_int = all(\n            isinstance(v, int | np.integer | float | np.floating) for v in rgba_tuple\n        )\n        is_all_in_range = all(\n            0 &lt;= v &lt;= 255 if i &lt; 3 else 0 &lt;= v &lt;= 1 for i, v in enumerate(rgba_tuple)\n        )\n        if is_all_int and is_all_in_range:\n            rgba_tuple = tuple(\n                int(v) if i &lt; 3 else float(v) for i, v in enumerate(rgba_tuple)\n            )\n            rgba_int_tuple = tuple(\n                int(v) if i &lt; 3 else int(float(v) * 255)\n                for i, v in enumerate(rgba_tuple)\n            )\n            return \"#{:02X}{:02X}{:02X}{:02X}\".format(*rgba_int_tuple)\n        raise ValueError(f\"Invalid rgba tuple: '{rgba_tuple}'\")\n\n    @classmethod\n    def _hex_str_to_hex(\n        cls,\n        hex_string: str,\n    ) -&gt; str:\n        \"\"\"Normalize a hex string to standard 6- or 8-character format.\"\"\"\n        c = hex_string.upper()\n        if re.match(r\"^#[A-F0-9]{3}$\", c):\n            c = f\"#{c[1]*2}{c[2]*2}{c[3]*2}\"\n        elif re.match(r\"^#[A-F0-9]{4}$\", c):\n            c = f\"#{c[1]*2}{c[2]*2}{c[3]*2}{c[4]*2}\"\n        if not re.match(r\"^#[A-F0-9]{6}$\", c) and not re.match(r\"^#[A-F0-9]{8}$\", c):\n            raise ValueError(f\"Invalid hex color: '{hex_string}'\")\n        return c\n\n    @classmethod\n    def _to_hex(\n        cls,\n        color: str | Sequence,\n        is_normalized: bool = False,\n    ) -&gt; str:\n        \"\"\"Convert a color input of various formats to a hex string.\"\"\"\n        if isinstance(color, str):\n            c_str = color.strip().replace(\" \", \"\").lower()\n            if c_str.startswith(\"#\"):\n                return cls._hex_str_to_hex(c_str)\n            elif c_str.startswith(\"rgb(\"):\n                return cls._rgb_str_to_hex(c_str)\n            elif c_str.startswith(\"rgba(\"):\n                return cls._rgba_str_to_hex(c_str)\n            elif c_str.startswith(\"rgb255(\"):\n                return cls._rgb_str_to_hex(c_str.replace(\"rgb255(\", \"rgb(\"))\n            elif c_str.startswith(\"rgba255(\"):\n                return cls._rgba_str_to_hex(c_str.replace(\"rgba255(\", \"rgba(\"))\n            elif c_str.startswith(\"rgb01(\"):\n                return cls._rgb_str_to_hex(\n                    c_str.replace(\"rgb01(\", \"rgb(\"), is_normalized=True\n                )\n            elif c_str.startswith(\"rgba01(\"):\n                return cls._rgba_str_to_hex(\n                    c_str.replace(\"rgba01(\", \"rgba(\"), is_normalized=True\n                )\n            else:\n                try:\n                    return _custom_colors[color].upper()\n                except KeyError as e:\n                    pass\n                return mcolors.to_hex(color).upper()\n        elif isinstance(color, (Sequence, np.ndarray)):\n            if len(color) &gt; 0:\n                if isinstance(color[0], float):\n                    is_normalized = True\n                else:\n                    is_normalized = False\n            c_tup = tuple(float(v) for v in color)\n            if len(c_tup) == 3:\n                if is_normalized:\n                    c_tup = tuple(float(v) for v in color)\n                else:\n                    c_tup = tuple(int(v) for v in color)\n                return cls._rgb_tuple_to_hex(c_tup, is_normalized=is_normalized)\n            elif len(c_tup) == 4:\n                return cls._rgba_tuple_to_hex(c_tup, is_normalized=is_normalized)\n        raise TypeError(f\"Invalid type for input color ({type(color)}: {color})\")\n\n    @property\n    def hex(self) -&gt; str:\n        \"\"\"Returns the hex color string.\"\"\"\n        return str(self).upper()\n\n    @property\n    def rgb(self) -&gt; Tuple[int, int, int]:\n        \"\"\"Returns the RGB tuple with values in the 0-255 range.\"\"\"\n        hex_str = self.lstrip(\"#\")\n        return (\n            int(hex_str[0:2], 16),\n            int(hex_str[2:4], 16),\n            int(hex_str[4:6], 16),\n        )\n\n    @property\n    def alpha(self) -&gt; float:\n        \"\"\"Returns the transparency alpha value in the 0-1 range.\"\"\"\n        if len(self) == 9:\n            return int(str(self).upper()[7::], 16) / 255\n        return 1.0\n\n    @property\n    def rgba(self) -&gt; Tuple[float, float, float, float]:\n        \"\"\"Returns the RGBA tuple with values in the 0-1 range.\"\"\"\n        hex_str = self.lstrip(\"#\")\n        return (\n            int(hex_str[0:2], 16) / 255,\n            int(hex_str[2:4], 16) / 255,\n            int(hex_str[4:6], 16) / 255,\n            self.alpha,\n        )\n\n    def set_alpha(self, value: float) -&gt; \"Color\":\n        \"\"\"Returns the same color with the given transparency alpha value applied.\"\"\"\n        if not 0 &lt;= value &lt;= 1:\n            raise ValueError(\n                f\"Invalid alpha value: '{value}' (must be in the 0-1 range)\"\n            )\n        return Color(self.hex[0:7] + \"{:02X}\".format(int(value * 255)), name=self.name)\n\n    def blend(\n        self, value: float, blend_color: \"Color\" | ColorLike = \"white\"\n    ) -&gt; \"Color\":\n        \"\"\"Returns the same color blended with a second color.\"\"\"\n        original_color = self.rgb\n        blend_color = Color(blend_color).rgb\n        new_color = Color(\n            tuple(\n                int(round((1 - value) * bc + value * oc))\n                for oc, bc in zip(original_color, blend_color)\n            )\n        )\n        return new_color\n\n    @classmethod\n    def from_optional(\n        cls,\n        color_input: \"Color\" | ColorLike | None,\n        alpha: float | None = None,\n    ) -&gt; Union[\"Color\", None]:\n        \"\"\"Parses optional color input and returns a `Color` instance or `None`.\"\"\"\n        if color_input is None:\n            return None\n        elif isinstance(alpha, float):\n            return cls(color_input).set_alpha(alpha)\n        else:\n            return cls(color_input)\n\n    def is_close_to_white(self, threshold: float = 0.1) -&gt; bool:\n        \"\"\"Check if the color is close to white.\"\"\"\n        rgb01 = 1 - (np.array(self.rgb) / 255)\n        return bool(np.all(rgb01 &lt; threshold))\n\n    def get_best_bw_contrast_color(self) -&gt; \"Color\":\n        \"\"\"\n        Return black or white color depending on best contrast according to WCAG 2.0.\n\n        See https://www.w3.org/TR/WCAG20/\n        \"\"\"\n        return Color(get_best_bw_contrast_color(self.rgb))\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.alpha","title":"alpha  <code>property</code>","text":"<pre><code>alpha\n</code></pre> <p>Returns the transparency alpha value in the 0-1 range.</p>"},{"location":"api_ref/#earthcarekit.Color.hex","title":"hex  <code>property</code>","text":"<pre><code>hex\n</code></pre> <p>Returns the hex color string.</p>"},{"location":"api_ref/#earthcarekit.Color.rgb","title":"rgb  <code>property</code>","text":"<pre><code>rgb\n</code></pre> <p>Returns the RGB tuple with values in the 0-255 range.</p>"},{"location":"api_ref/#earthcarekit.Color.rgba","title":"rgba  <code>property</code>","text":"<pre><code>rgba\n</code></pre> <p>Returns the RGBA tuple with values in the 0-1 range.</p>"},{"location":"api_ref/#earthcarekit.Color.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Return the hash of the color string.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def __hash__(self):\n    \"\"\"Return the hash of the color string.\"\"\"\n    return hash(str(self))\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.__init__","title":"__init__","text":"<pre><code>__init__(color_input, name=None, is_normalized=False)\n</code></pre> <p>Initialize Color attributes.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def __init__(\n    self,\n    color_input: \"Color\" | ColorLike,\n    name: str | None = None,\n    is_normalized: bool = False,\n):\n    \"\"\"Initialize Color attributes.\"\"\"\n    object.__setattr__(self, \"input\", color_input)\n    object.__setattr__(self, \"name\", name)\n    object.__setattr__(self, \"is_normalized\", is_normalized)\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.__new__","title":"__new__","text":"<pre><code>__new__(color_input, name=None, is_normalized=False)\n</code></pre> <p>Create a Color instance from a color-like input.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def __new__(\n    cls,\n    color_input: \"Color\" | ColorLike,\n    name: str | None = None,\n    is_normalized: bool = False,\n):\n    \"\"\"Create a Color instance from a color-like input.\"\"\"\n    hex_color = cls._to_hex(color_input, is_normalized=is_normalized)\n    return str.__new__(cls, hex_color)\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.blend","title":"blend","text":"<pre><code>blend(value, blend_color='white')\n</code></pre> <p>Returns the same color blended with a second color.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def blend(\n    self, value: float, blend_color: \"Color\" | ColorLike = \"white\"\n) -&gt; \"Color\":\n    \"\"\"Returns the same color blended with a second color.\"\"\"\n    original_color = self.rgb\n    blend_color = Color(blend_color).rgb\n    new_color = Color(\n        tuple(\n            int(round((1 - value) * bc + value * oc))\n            for oc, bc in zip(original_color, blend_color)\n        )\n    )\n    return new_color\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.from_optional","title":"from_optional  <code>classmethod</code>","text":"<pre><code>from_optional(color_input, alpha=None)\n</code></pre> <p>Parses optional color input and returns a <code>Color</code> instance or <code>None</code>.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>@classmethod\ndef from_optional(\n    cls,\n    color_input: \"Color\" | ColorLike | None,\n    alpha: float | None = None,\n) -&gt; Union[\"Color\", None]:\n    \"\"\"Parses optional color input and returns a `Color` instance or `None`.\"\"\"\n    if color_input is None:\n        return None\n    elif isinstance(alpha, float):\n        return cls(color_input).set_alpha(alpha)\n    else:\n        return cls(color_input)\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.get_best_bw_contrast_color","title":"get_best_bw_contrast_color","text":"<pre><code>get_best_bw_contrast_color()\n</code></pre> <p>Return black or white color depending on best contrast according to WCAG 2.0.</p> <p>See https://www.w3.org/TR/WCAG20/</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def get_best_bw_contrast_color(self) -&gt; \"Color\":\n    \"\"\"\n    Return black or white color depending on best contrast according to WCAG 2.0.\n\n    See https://www.w3.org/TR/WCAG20/\n    \"\"\"\n    return Color(get_best_bw_contrast_color(self.rgb))\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.is_close_to_white","title":"is_close_to_white","text":"<pre><code>is_close_to_white(threshold=0.1)\n</code></pre> <p>Check if the color is close to white.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def is_close_to_white(self, threshold: float = 0.1) -&gt; bool:\n    \"\"\"Check if the color is close to white.\"\"\"\n    rgb01 = 1 - (np.array(self.rgb) / 255)\n    return bool(np.all(rgb01 &lt; threshold))\n</code></pre>"},{"location":"api_ref/#earthcarekit.Color.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(value)\n</code></pre> <p>Returns the same color with the given transparency alpha value applied.</p> Source code in <code>earthcarekit/plot/color/color.py</code> <pre><code>def set_alpha(self, value: float) -&gt; \"Color\":\n    \"\"\"Returns the same color with the given transparency alpha value applied.\"\"\"\n    if not 0 &lt;= value &lt;= 1:\n        raise ValueError(\n            f\"Invalid alpha value: '{value}' (must be in the 0-1 range)\"\n        )\n    return Color(self.hex[0:7] + \"{:02X}\".format(int(value * 255)), name=self.name)\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure","title":"CurtainFigure","text":"<p>Figure object for displaying EarthCARE curtain data (e.g., ATLID and CPR L1/L2 profiles) along the satellite track.</p> <p>This class sets up a horizontal-along-track or time vs. vertical-height plot (a \"curtain\" view), for profiling atmospheric quantities retrieved from ground-based or nadir-viewing air/space-bourne instruments (like EarthCARE). It displays dual top/bottom x-axes (e.g., geolocation and time), and left/right y-axes for height labels.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes | None</code> <p>Existing matplotlib axes to plot on; if not provided, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Size of the figure in inches. Defaults to (FIGURE_WIDTH_CURTAIN, FIGURE_HEIGHT_CURTAIN).</p> <code>(FIGURE_WIDTH_CURTAIN, FIGURE_HEIGHT_CURTAIN)</code> <code>dpi</code> <code>int | None</code> <p>Resolution of the figure in dots per inch. Defaults to None.</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Title to display above the curtain plot. Defaults to None.</p> <code>None</code> <code>ax_style_top</code> <code>AlongTrackAxisStyle | str</code> <p>Style of the top x-axis, e.g., \"geo\", \"time\", or \"frame\". Defaults to \"geo\".</p> <code>'geo'</code> <code>ax_style_bottom</code> <code>AlongTrackAxisStyle | str</code> <p>Style of the bottom x-axis, e.g., \"geo\", \"time\", or \"frame\". Defaults to \"time\".</p> <code>'time'</code> <code>num_ticks</code> <code>int</code> <p>Maximum number of tick marks to be place along the x-axis. Defaults to 10.</p> <code>10</code> <code>show_height_left</code> <code>bool</code> <p>Whether to show height labels on the left y-axis. Defaults to True.</p> <code>True</code> <code>show_height_right</code> <code>bool</code> <p>Whether to show height labels on the right y-axis. Defaults to False.</p> <code>False</code> <code>mode</code> <code>Literal['exact', 'fast']</code> <p>Curtain plotting mode. Use \"fast\" to speed up plotting by coarsening data to at least <code>min_num_profiles</code>; \"exact\" plots full resolution. Defaults to None.</p> <code>'fast'</code> <code>min_num_profiles</code> <code>int</code> <p>Minimum number of profiles to keep when using \"fast\" mode. Defaults to 1000.</p> <code>1000</code> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>class CurtainFigure:\n    \"\"\"Figure object for displaying EarthCARE curtain data (e.g., ATLID and CPR L1/L2 profiles) along the satellite track.\n\n    This class sets up a horizontal-along-track or time vs. vertical-height plot (a \"curtain\" view), for profiling\n    atmospheric quantities retrieved from ground-based or nadir-viewing air/space-bourne instruments (like EarthCARE).\n    It displays dual top/bottom x-axes (e.g., geolocation and time), and left/right y-axes for height labels.\n\n    Args:\n        ax (Axes | None, optional): Existing matplotlib axes to plot on; if not provided, a new figure and axes will be created. Defaults to None.\n        figsize (tuple[float, float], optional): Size of the figure in inches. Defaults to (FIGURE_WIDTH_CURTAIN, FIGURE_HEIGHT_CURTAIN).\n        dpi (int | None, optional): Resolution of the figure in dots per inch. Defaults to None.\n        title (str | None, optional): Title to display above the curtain plot. Defaults to None.\n        ax_style_top (AlongTrackAxisStyle | str, optional): Style of the top x-axis, e.g., \"geo\", \"time\", or \"frame\". Defaults to \"geo\".\n        ax_style_bottom (AlongTrackAxisStyle | str, optional): Style of the bottom x-axis, e.g., \"geo\", \"time\", or \"frame\". Defaults to \"time\".\n        num_ticks (int, optional): Maximum number of tick marks to be place along the x-axis. Defaults to 10.\n        show_height_left (bool, optional): Whether to show height labels on the left y-axis. Defaults to True.\n        show_height_right (bool, optional): Whether to show height labels on the right y-axis. Defaults to False.\n        mode (Literal[\"exact\", \"fast\"], optional): Curtain plotting mode. Use \"fast\" to speed up plotting by coarsening data to at least `min_num_profiles`; \"exact\" plots full resolution. Defaults to None.\n        min_num_profiles (int, optional): Minimum number of profiles to keep when using \"fast\" mode. Defaults to 1000.\n    \"\"\"\n\n    def __init__(\n        self,\n        ax: Axes | None = None,\n        figsize: tuple[float, float] = (FIGURE_WIDTH_CURTAIN, FIGURE_HEIGHT_CURTAIN),\n        dpi: int | None = None,\n        title: str | None = None,\n        ax_style_top: AlongTrackAxisStyle | str = \"geo\",\n        ax_style_bottom: AlongTrackAxisStyle | str = \"time\",\n        num_ticks: int = 10,\n        show_height_left: bool = True,\n        show_height_right: bool = False,\n        mode: Literal[\"exact\", \"fast\"] = \"fast\",\n        min_num_profiles: int = 1000,\n        colorbar_tick_scale: float | None = None,\n        fig_height_scale: float = 1.0,\n        fig_width_scale: float = 1.0,\n    ):\n        self.fig: Figure\n        figsize = (figsize[0] * fig_width_scale, figsize[1] * fig_height_scale)\n        if isinstance(ax, Axes):\n            tmp = ax.get_figure()\n            if not isinstance(tmp, (Figure, SubFigure)):\n                raise ValueError(f\"Invalid Figure\")\n            self.fig = tmp  # type: ignore\n            self.ax = ax\n        else:\n            self.fig = plt.figure(figsize=figsize, dpi=dpi)\n            self.ax = self.fig.add_axes((0.0, 0.0, 1.0, 1.0))\n        self.title = title\n        if self.title:\n            self.fig.suptitle(self.title)\n\n        self.ax_top: Axes | None = None\n        self.ax_right: Axes | None = None\n        self.colorbar: Colorbar | None = None\n        self.colorbar_tick_scale: float | None = colorbar_tick_scale\n        self.selection_time_range: tuple[pd.Timestamp, pd.Timestamp] | None = None\n        self.ax_style_top: AlongTrackAxisStyle = AlongTrackAxisStyle.from_input(\n            ax_style_top\n        )\n        self.ax_style_bottom: AlongTrackAxisStyle = AlongTrackAxisStyle.from_input(\n            ax_style_bottom\n        )\n\n        self.info_text: AnchoredText | None = None\n        self.info_text_loc: str = \"upper right\"\n        self.num_ticks = num_ticks\n        self.show_height_left = show_height_left\n        self.show_height_right = show_height_right\n\n        if mode in [\"exact\", \"fast\"]:\n            self.mode = mode\n        else:\n            self.mode = \"fast\"\n\n        if isinstance(min_num_profiles, int):\n            self.min_num_profiles = min_num_profiles\n        else:\n            self.min_num_profiles = 1000\n\n        self.legend: Legend | None = self.ax.get_legend()\n        self._legend_handles: list = []\n        self._legend_labels: list = []\n\n    def _set_info_text_loc(self, info_text_loc: str | None) -&gt; None:\n        if isinstance(info_text_loc, str):\n            self.info_text_loc = info_text_loc\n\n    def _set_axes(\n        self,\n        tmin: np.datetime64,\n        tmax: np.datetime64,\n        hmin: float,\n        hmax: float,\n        time: NDArray,\n        tmin_original: np.datetime64 | None = None,\n        tmax_original: np.datetime64 | None = None,\n        longitude: NDArray | None = None,\n        latitude: NDArray | None = None,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n    ) -&gt; \"CurtainFigure\":\n\n        self.set_colorbar_tick_scale(multiplier=self.colorbar_tick_scale)\n\n        if ax_style_top is not None:\n            self.ax_style_top = AlongTrackAxisStyle.from_input(ax_style_top)\n        if ax_style_bottom is not None:\n            self.ax_style_bottom = AlongTrackAxisStyle.from_input(ax_style_bottom)\n        if not isinstance(tmin_original, np.datetime64):\n            tmin_original = tmin\n        if not isinstance(tmax_original, np.datetime64):\n            tmax_original = tmax\n\n        self.ax.set_xlim((tmin, tmax))  # type: ignore\n        self.ax.set_ylim((hmin, hmax))\n\n        self.ax_right = self.ax.twinx()\n        self.ax_right.set_ylim(self.ax.get_ylim())\n\n        self.ax_top = self.ax.twiny()\n        self.ax_top.set_xlim(self.ax.get_xlim())\n\n        format_height_ticks(\n            self.ax,\n            show_tick_labels=self.show_height_left,\n            show_units=self.show_height_left,\n            label=\"Height\" if self.show_height_left else \"\",\n        )\n        format_height_ticks(\n            self.ax_right,\n            show_tick_labels=self.show_height_right,\n            show_units=self.show_height_right,\n            label=\"Height\" if self.show_height_right else \"\",\n        )\n\n        format_along_track_axis(\n            self.ax,\n            self.ax_style_bottom,\n            time,\n            tmin,\n            tmax,\n            tmin_original,\n            tmax_original,\n            longitude,\n            latitude,\n            num_ticks=self.num_ticks,\n        )\n        format_along_track_axis(\n            self.ax_top,\n            self.ax_style_top,\n            time,\n            tmin,\n            tmax,\n            tmin_original,\n            tmax_original,\n            longitude,\n            latitude,\n            num_ticks=self.num_ticks,\n        )\n        return self\n\n    def plot(\n        self,\n        profiles: ProfileData | None = None,\n        *,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        height: NDArray | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        values_temperature: NDArray | None = None,\n        # Common args for wrappers\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        time_range: TimeRangeLike | None = None,\n        height_range: DistanceRangeLike | None = (0, 40e3),\n        label: str | None = None,\n        units: str | None = None,\n        cmap: str | Colormap | None = None,\n        colorbar: bool = True,\n        colorbar_ticks: ArrayLike | None = None,\n        colorbar_tick_labels: ArrayLike | None = None,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"right\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.2,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        rolling_mean: int | None = None,\n        selection_time_range: TimeRangeLike | None = None,\n        selection_color: str | None = Color(\"ec:earthcare\"),\n        selection_linestyle: str | None = \"dashed\",\n        selection_linewidth: float | int | None = 2.5,\n        selection_highlight: bool = False,\n        selection_highlight_inverted: bool = True,\n        selection_highlight_color: str | None = Color(\"white\"),\n        selection_highlight_alpha: float = 0.5,\n        selection_max_time_margin: (\n            TimedeltaLike | Sequence[TimedeltaLike] | None\n        ) = None,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n        show_temperature: bool = False,\n        mode: Literal[\"exact\", \"fast\"] | None = None,\n        min_num_profiles: int = 1000,\n        mark_profiles_at: Sequence[TimestampLike] | None = None,\n        mark_profiles_at_color: (\n            str | Color | Sequence[str | Color | None] | None\n        ) = None,\n        mark_profiles_at_linestyle: str | Sequence[str] = \"solid\",\n        mark_profiles_at_linewidth: float | Sequence[float] = 2.5,\n        label_length: int = 40,\n        **kwargs,\n    ) -&gt; \"CurtainFigure\":\n        # Parse colors\n        selection_color = Color.from_optional(selection_color)\n        selection_highlight_color = Color.from_optional(selection_highlight_color)\n\n        _mark_profiles_at_color: list[Color | None] = []\n        _mark_profiles_at_linestyle: list[str] = []\n        _mark_profiles_at_linewidth: list[float] = []\n        if isinstance(mark_profiles_at, (Sequence, np.ndarray)):\n            if mark_profiles_at_color is None:\n                _mark_profiles_at_color = [selection_color] * len(mark_profiles_at)\n            elif isinstance(mark_profiles_at_color, (str, Color)):\n                _mark_profiles_at_color = [\n                    Color.from_optional(mark_profiles_at_color)\n                ] * len(mark_profiles_at)\n            elif len(mark_profiles_at_color) != len(mark_profiles_at):\n                raise ValueError(\n                    f\"length of mark_profiles_at_color ({len(mark_profiles_at_color)}) must be same as length of mark_profiles_at ({len(mark_profiles_at)})\"\n                )\n            else:\n                _mark_profiles_at_color = [\n                    Color.from_optional(c) for c in mark_profiles_at_color\n                ]\n\n            if isinstance(mark_profiles_at_linestyle, str):\n                _mark_profiles_at_linestyle = [mark_profiles_at_linestyle] * len(\n                    mark_profiles_at\n                )\n            elif len(mark_profiles_at_linestyle) != len(mark_profiles_at):\n                raise ValueError(\n                    f\"length of mark_profiles_at_linestyle ({len(mark_profiles_at_linestyle)}) must be same as length of mark_profiles_at ({len(mark_profiles_at)})\"\n                )\n            else:\n                _mark_profiles_at_linestyle = [ls for ls in mark_profiles_at_linestyle]\n\n            if isinstance(mark_profiles_at_linewidth, (int, float)):\n                _mark_profiles_at_linewidth = [mark_profiles_at_linewidth] * len(\n                    mark_profiles_at\n                )\n            elif len(mark_profiles_at_linewidth) != len(mark_profiles_at):\n                raise ValueError(\n                    f\"length of mark_profiles_at_linewidth ({len(mark_profiles_at_linewidth)}) must be same as length of mark_profiles_at ({len(mark_profiles_at)})\"\n                )\n            else:\n                _mark_profiles_at_linewidth = [lw for lw in mark_profiles_at_linewidth]\n\n        if mode in [\"exact\", \"fast\"]:\n            self.mode = mode\n\n        if isinstance(min_num_profiles, int):\n            self.min_num_profiles = min_num_profiles\n\n        if isinstance(value_range, Sequence):\n            if len(value_range) != 2:\n                raise ValueError(\n                    f\"invalid `value_range`: {value_range}, expecting (vmin, vmax)\"\n                )\n        else:\n            value_range = (None, None)\n\n        cmap = get_cmap(cmap)\n\n        if cmap.categorical:\n            norm = cmap.norm\n        if isinstance(norm, Normalize):\n            if log_scale == True and not isinstance(norm, LogNorm):\n                norm = LogNorm(norm.vmin, norm.vmax)\n            elif log_scale == False and isinstance(norm, LogNorm):\n                norm = Normalize(norm.vmin, norm.vmax)\n            if value_range[0] is not None:\n                norm.vmin = value_range[0]  # type: ignore\n            if value_range[1] is not None:\n                norm.vmax = value_range[1]  # type: ignore\n        else:\n            if log_scale == True:\n                norm = LogNorm(value_range[0], value_range[1])  # type: ignore\n            else:\n                norm = Normalize(value_range[0], value_range[1])  # type: ignore\n        value_range = (norm.vmin, norm.vmax)\n\n        if isinstance(profiles, ProfileData):\n            values = profiles.values\n            time = profiles.time\n            height = profiles.height\n            latitude = profiles.latitude\n            longitude = profiles.longitude\n            label = profiles.label\n            units = profiles.units\n        elif values is None or time is None or height is None:\n            raise ValueError(\n                \"Missing required arguments. Provide either a `VerticalProfiles` or all of `values`, `time`, and `height`\"\n            )\n\n        values = np.asarray(values)\n        time = np.asarray(time)\n        height = np.asarray(height)\n        if latitude is not None:\n            latitude = np.asarray(latitude)\n        if longitude is not None:\n            longitude = np.asarray(longitude)\n\n        # Validate inputs\n        if len(values.shape) != 2:\n            raise ValueError(\n                f\"Values must be either 2D, but has {len(values.shape)} dimensions (shape={values.shape})\"\n            )\n\n        validate_profile_data_dimensions(\n            values=values,\n            time=time,\n            height=height,\n            latitude=latitude,\n            longitude=longitude,\n        )\n\n        vp = ProfileData(\n            values=values,\n            time=time,\n            height=height,\n            latitude=latitude,\n            longitude=longitude,\n            label=label,\n            units=units,\n        )\n\n        tmin_original = vp.time[0]\n        tmax_original = vp.time[-1]\n        hmin_original = vp.height[0]\n        hmax_original = vp.height[-1]\n\n        if selection_time_range is not None:\n            if selection_max_time_margin is not None and not (\n                isinstance(selection_max_time_margin, (Sequence, np.ndarray))\n                and not isinstance(selection_max_time_margin, str)\n            ):\n                selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin),\n                    to_timedelta(selection_max_time_margin),\n                )\n\n            self.selection_time_range = validate_time_range(selection_time_range)\n            _selection_max_time_margin: tuple[pd.Timedelta, pd.Timedelta] | None = None\n            if isinstance(selection_max_time_margin, (Sequence, np.ndarray)):\n                _selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin[0]),\n                    to_timedelta(selection_max_time_margin[1]),\n                )\n            elif selection_max_time_margin is not None:\n                _selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin),\n                    to_timedelta(selection_max_time_margin),\n                )\n\n            if _selection_max_time_margin is not None:\n                time_range = [\n                    np.max(\n                        [\n                            vp.time[0],\n                            (\n                                self.selection_time_range[0]\n                                - _selection_max_time_margin[0]\n                            ).to_datetime64(),\n                        ]\n                    ),\n                    np.min(\n                        [\n                            vp.time[-1],\n                            (\n                                self.selection_time_range[1]\n                                + _selection_max_time_margin[1]\n                            ).to_datetime64(),\n                        ]\n                    ),\n                ]\n\n        if isinstance(rolling_mean, int):\n            vp = vp.rolling_mean(rolling_mean)\n\n        if height_range is not None:\n            if isinstance(height_range, Iterable) and len(height_range) == 2:\n                for i in [0, -1]:\n                    height_range = list(height_range)\n                    if height_range[i] is None:\n                        height_range[i] = [\n                            np.nanmin(vp.height),\n                            np.nanmax(vp.height),\n                        ][i]\n                    height_range = tuple(height_range)\n            vp = vp.select_height_range(height_range, pad_idx=1)\n        else:\n            height_range = (\n                np.nanmin(vp.height),\n                np.nanmax(vp.height),\n            )\n\n        if time_range is not None:\n            if isinstance(time_range, Iterable) and len(time_range) == 2:\n                for i in [0, -1]:\n                    time_range = list(time_range)\n                    if time_range[i] is None:\n                        time_range[i] = vp.time[i]\n                    time_range = tuple(time_range)  # type: ignore\n            pad_idxs = 0\n            if isinstance(rolling_mean, int):\n                pad_idxs = rolling_mean\n            vp = vp.select_time_range(time_range, pad_idxs=pad_idxs)\n\n        # else:\n        time_range = (vp.time[0], vp.time[-1])\n        tmin = np.datetime64(time_range[0])\n        tmax = np.datetime64(time_range[1])\n\n        hmin = height_range[0]\n        hmax = height_range[1]\n\n        time_non_coarsened = vp.time\n        lat_non_coarsened = vp.latitude\n        lon_non_coarsened = vp.longitude\n\n        if (\n            self.mode == \"fast\"\n            and not cmap.categorical\n            and not np.issubdtype(vp.values.dtype, np.integer)\n        ):\n            n = vp.time.shape[0] // self.min_num_profiles\n            if n &gt; 1:\n                vp = vp.coarsen_mean(n)\n\n        time_grid, height_grid = create_time_height_grids(\n            values=vp.values, time=vp.time, height=vp.height\n        )\n\n        mesh = self.ax.pcolormesh(\n            time_grid,\n            height_grid,\n            vp.values,\n            cmap=cmap,\n            norm=norm,\n            shading=\"auto\",\n            linewidth=0,\n            rasterized=True,\n            **kwargs,\n        )\n        mesh.set_edgecolor(\"face\")\n\n        if colorbar:\n            cb_kwargs = dict(\n                label=format_var_label(vp.label, vp.units, label_len=label_length),\n                position=colorbar_position,\n                alignment=colorbar_alignment,\n                width=colorbar_width,\n                spacing=colorbar_spacing,\n                length_ratio=colorbar_length_ratio,\n                label_outside=colorbar_label_outside,\n                ticks_outside=colorbar_ticks_outside,\n                ticks_both=colorbar_ticks_both,\n            )\n            if cmap.categorical:\n                self.colorbar = add_colorbar(\n                    fig=self.fig,\n                    ax=self.ax,\n                    data=mesh,\n                    cmap=cmap,\n                    **cb_kwargs,  # type: ignore\n                )\n            else:\n                self.colorbar = add_colorbar(\n                    fig=self.fig,\n                    ax=self.ax,\n                    data=mesh,\n                    ticks=colorbar_ticks,\n                    tick_labels=colorbar_tick_labels,\n                    **cb_kwargs,  # type: ignore\n                )\n\n        if selection_time_range is not None:\n            if selection_highlight:\n                if selection_highlight_inverted:\n                    self.ax.axvspan(\n                        tmin,  # type: ignore\n                        self.selection_time_range[0],  # type: ignore\n                        color=selection_highlight_color,\n                        alpha=selection_highlight_alpha,\n                    )\n                    self.ax.axvspan(\n                        self.selection_time_range[1],  # type: ignore\n                        tmax,  # type: ignore\n                        color=selection_highlight_color,\n                        alpha=selection_highlight_alpha,\n                    )\n                else:\n                    self.ax.axvspan(\n                        self.selection_time_range[0],  # type: ignore\n                        self.selection_time_range[1],  # type: ignore\n                        color=selection_highlight_color,\n                        alpha=selection_highlight_alpha,\n                    )\n\n            for t in self.selection_time_range:  # type: ignore\n                self.ax.axvline(\n                    x=t,  # type: ignore\n                    color=selection_color,\n                    linestyle=selection_linestyle,\n                    linewidth=selection_linewidth,\n                    zorder=20,\n                )\n\n        _latitude = None\n        if isinstance(vp.latitude, (np.ndarray)) and isinstance(\n            lat_non_coarsened, (np.ndarray)\n        ):\n            _latitude = np.concatenate(\n                ([lat_non_coarsened[0]], vp.latitude, [lat_non_coarsened[-1]])\n            )\n\n        _longitude = None\n        if isinstance(vp.longitude, (np.ndarray)) and isinstance(\n            lon_non_coarsened, (np.ndarray)\n        ):\n            _longitude = np.concatenate(\n                ([lon_non_coarsened[0]], vp.longitude, [lon_non_coarsened[-1]])\n            )\n\n        self._set_axes(\n            tmin=tmin,\n            tmax=tmax,\n            hmin=hmin,  # type: ignore\n            hmax=hmax,  # type: ignore\n            time=np.concatenate(\n                ([time_non_coarsened[0]], vp.time, [time_non_coarsened[-1]])\n            ),\n            tmin_original=tmin_original,\n            tmax_original=tmax_original,\n            latitude=_latitude,\n            longitude=_longitude,\n            ax_style_top=ax_style_top,\n            ax_style_bottom=ax_style_bottom,\n        )\n\n        if show_temperature and values_temperature is not None:\n            self.plot_contour(\n                values=values_temperature,\n                time=time,\n                height=height,\n            )\n\n        if mark_profiles_at is not None:\n            for i, t in enumerate(to_timestamps(mark_profiles_at)):\n                self.ax.axvline(\n                    t,  # type: ignore\n                    color=_mark_profiles_at_color[i],\n                    linestyle=_mark_profiles_at_linestyle[i],\n                    linewidth=_mark_profiles_at_linewidth[i],\n                    zorder=20,\n                )  # type: ignore\n\n        return self\n\n    def ecplot(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        *,\n        time_var: str = TIME_VAR,\n        height_var: str = HEIGHT_VAR,\n        lat_var: str = TRACK_LAT_VAR,\n        lon_var: str = TRACK_LON_VAR,\n        temperature_var: str = TEMP_CELSIUS_VAR,\n        along_track_dim: str = ALONG_TRACK_DIM,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        height: NDArray | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        values_temperature: NDArray | None = None,\n        site: str | GroundSite | None = None,\n        radius_km: float = 100.0,\n        mark_closest_profile: bool = False,\n        show_info: bool = True,\n        show_radius: bool = True,\n        info_text_loc: str | None = None,\n        # Common args for wrappers\n        value_range: ValueRangeLike | Literal[\"default\"] | None = \"default\",\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        time_range: TimeRangeLike | None = None,\n        height_range: DistanceRangeLike | None = (0, 40e3),\n        label: str | None = None,\n        units: str | None = None,\n        cmap: str | Colormap | None = None,\n        colorbar: bool = True,\n        colorbar_ticks: ArrayLike | None = None,\n        colorbar_tick_labels: ArrayLike | None = None,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"right\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.2,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        rolling_mean: int | None = None,\n        selection_time_range: TimeRangeLike | None = None,\n        selection_color: str | None = Color(\"ec:earthcare\"),\n        selection_linestyle: str | None = \"dashed\",\n        selection_linewidth: float | int | None = 2.5,\n        selection_highlight: bool = False,\n        selection_highlight_inverted: bool = True,\n        selection_highlight_color: str | None = Color(\"white\"),\n        selection_highlight_alpha: float = 0.5,\n        selection_max_time_margin: (\n            TimedeltaLike | Sequence[TimedeltaLike] | None\n        ) = None,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n        show_temperature: bool = False,\n        mode: Literal[\"exact\", \"fast\"] | None = None,\n        min_num_profiles: int = 5000,\n        mark_profiles_at: Sequence[TimestampLike] | None = None,\n        mark_profiles_at_color: (\n            str | Color | Sequence[str | Color | None] | None\n        ) = None,\n        mark_profiles_at_linestyle: str | Sequence[str] = \"solid\",\n        mark_profiles_at_linewidth: float | Sequence[float] = 2.5,\n        label_length: int = 40,\n        **kwargs,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Plot a vertical curtain (i.e. cross-section) of a variable along the satellite track a EarthCARE dataset.\n\n        This method collections all required data from a EarthCARE `xarray.dataset`, such as time, height, latitude and longitude.\n        It supports various forms of customization through the use of arguments listed below.\n\n        Args:\n            ds (xr.Dataset): The EarthCARE dataset from with data will be plotted.\n            var (str): Name of the variable to plot.\n            time_var (str, optional): Name of the time variable. Defaults to TIME_VAR.\n            height_var (str, optional): Name of the height variable. Defaults to HEIGHT_VAR.\n            lat_var (str, optional): Name of the latitude variable. Defaults to TRACK_LAT_VAR.\n            lon_var (str, optional): Name of the longitude variable. Defaults to TRACK_LON_VAR.\n            temperature_var (str, optional): Name of the temperature variable; ignored if `show_temperature` is set to False. Defaults to TEMP_CELSIUS_VAR.\n            along_track_dim (str, optional): Dimension name representing the along-track direction. Defaults to ALONG_TRACK_DIM.\n            values (NDArray | None, optional): Data values to be used instead of values found in the `var` variable of the dataset. Defaults to None.\n            time (NDArray | None, optional): Time values to be used instead of values found in the `time_var` variable of the dataset. Defaults to None.\n            height (NDArray | None, optional): Height values to be used instead of values found in the `height_var` variable of the dataset. Defaults to None.\n            latitude (NDArray | None, optional): Latitude values to be used instead of values found in the `lat_var` variable of the dataset. Defaults to None.\n            longitude (NDArray | None, optional): Longitude values to be used instead of values found in the `lon_var` variable of the dataset. Defaults to None.\n            values_temperature (NDArray | None, optional): Temperature values to be used instead of values found in the `temperature_var` variable of the dataset. Defaults to None.\n            site (str | GroundSite | None, optional): Highlights data within `radius_km` of a ground site (given either as a `GroundSite` object or name string); ignored if not set. Defaults to None.\n            radius_km (float, optional): Radius around the ground site to highlight data from; ignored if `site` not set. Defaults to 100.0.\n            mark_closest_profile (bool, optional): Mark the closest profile to the ground site in the plot; ignored if `site` not set. Defaults to False.\n            show_info (bool, optional): If True, show text on the plot containing EarthCARE frame and baseline info. Defaults to True.\n            info_text_loc (str | None, optional): Place info text at a specific location of the plot, e.g. \"upper right\" or \"lower left\". Defaults to None.\n            value_range (ValueRangeLike | None, optional): Min and max range for the variable values. Defaults to None.\n            log_scale (bool | None, optional): Whether to apply a logarithmic color scale. Defaults to None.\n            norm (Normalize | None, optional): Matplotlib norm to use for color scaling. Defaults to None.\n            time_range (TimeRangeLike | None, optional): Time range to restrict the data for plotting. Defaults to None.\n            height_range (DistanceRangeLike | None, optional): Height range to restrict the data for plotting. Defaults to (0, 40e3).\n            label (str | None, optional): Label to use for colorbar. Defaults to None.\n            units (str | None, optional): Units of the variable to show in the colorbar label. Defaults to None.\n            cmap (str | Colormap | None, optional): Colormap to use for plotting. Defaults to None.\n            colorbar (bool, optional): Whether to display a colorbar. Defaults to True.\n            colorbar_ticks (ArrayLike | None, optional): Custom tick values for the colorbar. Defaults to None.\n            colorbar_tick_labels (ArrayLike | None, optional): Custom labels for the colorbar ticks. Defaults to None.\n            rolling_mean (int | None, optional): Apply rolling mean along time axis with this window size. Defaults to None.\n            selection_time_range (TimeRangeLike | None, optional): Time range to highlight as a selection; ignored if `site` is set. Defaults to None.\n            selection_color (_type_, optional): Color for the selection range marker lines. Defaults to Color(\"ec:earthcare\").\n            selection_linestyle (str | None, optional): Line style for selection range markers. Defaults to \"dashed\".\n            selection_linewidth (float | int | None, optional): Line width for selection range markers. Defaults to 2.5.\n            selection_highlight (bool, optional): Whether to highlight the selection region by shading outside or inside areas. Defaults to False.\n            selection_highlight_inverted (bool, optional): If True and `selection_highlight` is also set to True, areas outside the selection are shaded. Defaults to True.\n            selection_highlight_color (str | None, optional): If True and `selection_highlight` is also set to True, sets color used for shading selected outside or inside areas. Defaults to Color(\"white\").\n            selection_highlight_alpha (float, optional): If True and `selection_highlight` is also set to True, sets transparency used for shading selected outside or inside areas.. Defaults to 0.5.\n            selection_max_time_margin (TimedeltaLike | Sequence[TimedeltaLike], optional): Zooms the time axis to a given maximum time from a selected time area. Defaults to None.\n            ax_style_top (AlongTrackAxisStyle | str | None, optional): Style for the top axis (e.g., geo, lat, lon, distance, time, utc, lst, none). Defaults to None.\n            ax_style_bottom (AlongTrackAxisStyle | str | None, optional): Style for the bottom axis (e.g., geo, lat, lon, distance, time, utc, lst, none). Defaults to None.\n            show_temperature (bool, optional): Whether to overlay temperature as contours; requires either `values_temperature` or `temperature_var`. Defaults to False.\n            mode (Literal[\"exact\", \"fast\"] | None, optional): Overwrites the curtain plotting mode. Use \"fast\" to speed up plotting by coarsening data to at least `min_num_profiles`; \"exact\" plots full resolution. Defaults to None.\n            min_num_profiles (int, optional): Overwrites the minimum number of profiles to keep when using \"fast\" mode. Defaults to 1000.\n            mark_profiles_at (Sequence[TimestampLike] | None, optional): Timestamps at which to mark vertical profiles. Defaults to None.\n\n        Returns:\n            CurtainFigure: The figure object containing the curtain plot.\n\n        Example:\n            ```python\n            import earthcarekit as eck\n\n            filepath = \"path/to/mydata/ECA_EXAE_ATL_NOM_1B_20250606T132535Z_20250606T150730Z_05813D.h5\"\n            with eck.read_product(filepath) as ds:\n                cf = eck.CurtainFigure()\n                cf = cf.ecplot(ds, \"mie_attenuated_backscatter\", height_range=(0, 20e3))\n            ```\n        \"\"\"\n\n        # Collect all common args for wrapped plot function call\n        local_args = locals()\n        # Delete all args specific to this wrapper function\n        del local_args[\"self\"]\n        del local_args[\"ds\"]\n        del local_args[\"var\"]\n        del local_args[\"time_var\"]\n        del local_args[\"height_var\"]\n        del local_args[\"lat_var\"]\n        del local_args[\"lon_var\"]\n        del local_args[\"temperature_var\"]\n        del local_args[\"along_track_dim\"]\n        del local_args[\"site\"]\n        del local_args[\"radius_km\"]\n        del local_args[\"show_info\"]\n        del local_args[\"show_radius\"]\n        del local_args[\"info_text_loc\"]\n        del local_args[\"mark_closest_profile\"]\n        # Delete kwargs to then merge it with the residual common args\n        del local_args[\"kwargs\"]\n        all_args = {**local_args, **kwargs}\n\n        warn_about_variable_limitations(var)\n\n        if all_args[\"values\"] is None:\n            all_args[\"values\"] = ds[var].values\n        if all_args[\"time\"] is None:\n            all_args[\"time\"] = ds[time_var].values\n        if all_args[\"height\"] is None:\n            all_args[\"height\"] = ds[height_var].values\n        if all_args[\"latitude\"] is None:\n            all_args[\"latitude\"] = ds[lat_var].values\n        if all_args[\"longitude\"] is None:\n            all_args[\"longitude\"] = ds[lon_var].values\n        if all_args[\"values_temperature\"] is None:\n            if show_temperature == False:\n                all_args[\"values_temperature\"] = None\n            elif ds.get(temperature_var, None) is None:\n                warnings.warn(\n                    f'No temperature variable called \"{temperature_var}\" found in given dataset.'\n                )\n                all_args[\"values_temperature\"] = None\n            else:\n                all_args[\"values_temperature\"] = ds[temperature_var].values\n\n        # Set default values depending on variable name\n        if label is None:\n            all_args[\"label\"] = (\n                \"Values\" if not hasattr(ds[var], \"long_name\") else ds[var].long_name\n            )\n        if units is None:\n            all_args[\"units\"] = \"-\" if not hasattr(ds[var], \"units\") else ds[var].units\n        if isinstance(value_range, str) and value_range == \"default\":\n            value_range = None\n            all_args[\"value_range\"] = None\n            if log_scale is None and norm is None:\n                all_args[\"norm\"] = get_default_norm(var, file_type=ds)\n        if rolling_mean is None:\n            all_args[\"rolling_mean\"] = get_default_rolling_mean(var, file_type=ds)\n        if cmap is None:\n            all_args[\"cmap\"] = get_default_cmap(var, file_type=ds)\n        all_args[\"cmap\"] = get_cmap(all_args[\"cmap\"])\n\n        if all_args[\"cmap\"] == get_cmap(\"synergetic_tc\"):\n            self.colorbar_tick_scale = 0.8\n\n        # Handle overpass\n        _site: GroundSite | None = None\n        if isinstance(site, GroundSite):\n            _site = site\n        elif isinstance(site, str):\n            _site = get_ground_site(site)\n        else:\n            pass\n\n        if isinstance(_site, GroundSite):\n            info_overpass = get_overpass_info(\n                ds,\n                site_radius_km=radius_km,\n                site=_site,\n                time_var=time_var,\n                lat_var=lat_var,\n                lon_var=lon_var,\n                along_track_dim=along_track_dim,\n            )\n            if show_radius:\n                overpass_time_range = info_overpass.time_range\n                all_args[\"selection_time_range\"] = overpass_time_range\n            else:\n                mark_closest_profile = True\n            if mark_closest_profile:\n                _mark_profiles_at = all_args[\"mark_profiles_at\"]\n                _mark_profiles_at_color = all_args[\"mark_profiles_at_color\"]\n                _mark_profiles_at_linestyle = all_args[\"mark_profiles_at_linestyle\"]\n                _mark_profiles_at_linewidth = all_args[\"mark_profiles_at_linewidth\"]\n                if isinstance(_mark_profiles_at, (Sequence, np.ndarray)):\n                    list(_mark_profiles_at).append(info_overpass.closest_time)\n                    all_args[\"mark_profiles_at\"] = _mark_profiles_at\n                else:\n                    all_args[\"mark_profiles_at\"] = [info_overpass.closest_time]\n\n                if not isinstance(_mark_profiles_at_color, str) and isinstance(\n                    _mark_profiles_at_color, (Sequence, np.ndarray)\n                ):\n                    list(_mark_profiles_at_color).append(\"ec:earthcare\")\n                    all_args[\"mark_profiles_at_color\"] = _mark_profiles_at_color\n\n                if not isinstance(_mark_profiles_at_linestyle, str) and isinstance(\n                    _mark_profiles_at_linestyle, (Sequence, np.ndarray)\n                ):\n                    list(_mark_profiles_at_linestyle).append(\"solid\")\n                    all_args[\"mark_profiles_at_linestyle\"] = _mark_profiles_at_linestyle\n\n                if isinstance(_mark_profiles_at_linewidth, (Sequence, np.ndarray)):\n                    list(_mark_profiles_at_linewidth).append(2.5)\n                    all_args[\"mark_profiles_at_linewidth\"] = _mark_profiles_at_linewidth\n\n                all_args[\"selection_linestyle\"] = \"none\"\n                all_args[\"selection_linewidth\"] = 0.1\n        self.plot(**all_args)\n\n        self._set_info_text_loc(info_text_loc)\n        if show_info:\n            self.info_text = add_text_product_info(\n                self.ax, ds, append_to=self.info_text, loc=self.info_text_loc\n            )\n\n        return self\n\n    def plot_height(\n        self,\n        height: NDArray,\n        time: NDArray,\n        linewidth: int | float | None = 1.5,\n        linestyle: str | None = \"solid\",\n        color: Color | str | None = None,\n        alpha: float | None = 1.0,\n        zorder: int | float | None = 2,\n        marker: str | None = None,\n        markersize: int | float | None = None,\n        fill: bool = False,\n        legend_label: str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds height line to the plot.\"\"\"\n        color = Color.from_optional(color)\n\n        height = np.asarray(height)\n        time = np.asarray(time)\n\n        hnew, tnew = _convert_height_line_to_time_bin_step_function(height, time)\n\n        fb: list = []\n        if fill:\n            _fb1 = self.ax.fill_between(\n                tnew,\n                hnew,\n                y2=-5e3,\n                color=color,\n                alpha=alpha,\n                zorder=zorder,\n            )\n            from matplotlib.patches import Patch\n\n            # Proxy for the legend\n            _fb2 = Patch(facecolor=color, alpha=alpha, linewidth=0.0)\n            fb = [_fb1, _fb2]\n\n        hl = self.ax.plot(\n            tnew,\n            hnew,\n            linestyle=linestyle,\n            linewidth=linewidth,\n            marker=marker,\n            markersize=markersize,\n            color=color,\n            alpha=alpha,\n            zorder=zorder,\n        )\n\n        if isinstance(legend_label, str):\n            self._legend_handles.append(tuple(hl + fb))\n            self._legend_labels.append(legend_label)\n\n        return self\n\n    def ecplot_height(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        time_var: str = TIME_VAR,\n        linewidth: int | float | None = 1.5,\n        linestyle: str | None = \"none\",\n        color: Color | str | None = \"black\",\n        zorder: int | float | None = 2.1,\n        marker: str | None = \"s\",\n        markersize: int | float | None = 1,\n        show_info: bool = True,\n        info_text_loc: str | None = None,\n        legend_label: str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds height line to the plot.\"\"\"\n        height = ds[var].values\n        time = ds[time_var].values\n        self.plot_height(\n            height=height,\n            time=time,\n            linewidth=linewidth,\n            linestyle=linestyle,\n            color=color,\n            zorder=zorder,\n            marker=marker,\n            markersize=markersize,\n            legend_label=legend_label,\n        )\n\n        self._set_info_text_loc(info_text_loc)\n        if show_info:\n            self.info_text = add_text_product_info(\n                self.ax, ds, append_to=self.info_text, loc=self.info_text_loc\n            )\n\n        return self\n\n    def plot_contour(\n        self,\n        values: NDArray,\n        time: NDArray,\n        height: NDArray,\n        label_levels: list | NDArray | None = None,\n        label_format: str | None = None,\n        levels: list | NDArray | None = None,\n        linewidths: int | float | list | NDArray | None = 1.5,\n        linestyles: str | list | NDArray | None = \"solid\",\n        colors: Color | str | list | NDArray | None = \"black\",\n        zorder: int | float | None = 2,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds contour lines to the plot.\"\"\"\n        values = np.asarray(values)\n        time = np.asarray(time)\n        height = np.asarray(height)\n\n        if len(height.shape) == 2:\n            height = height[0]\n\n        if isinstance(colors, str):\n            colors = Color.from_optional(colors)\n        elif isinstance(colors, (Iterable, np.ndarray)):\n            colors = [Color.from_optional(c) for c in colors]\n        else:\n            colors = Color.from_optional(colors)\n\n        x = time\n        y = height\n        z = values.T\n\n        if len(y.shape) == 2:\n            y = y[len(y) // 2]\n\n        if isinstance(colors, list):\n            shade_color = Color.from_optional(colors[0])\n        else:\n            shade_color = Color.from_optional(colors)\n\n        if isinstance(shade_color, Color):\n            shade_color = shade_color.get_best_bw_contrast_color()\n\n        linewidths2: int | float | np.ndarray\n        if not isinstance(linewidths, (int, float, np.number, np.ndarray)):\n            linewidths2 = np.array(linewidths) * 2.5\n        else:\n            linewidths2 = linewidths * 2.5\n\n        cn2 = self.ax.contour(\n            x,\n            y,\n            z,\n            levels=levels,\n            linewidths=linewidths2,\n            colors=shade_color,\n            alpha=0.5,\n            linestyles=\"solid\",\n            zorder=zorder,\n        )\n\n        cn = self.ax.contour(\n            x,\n            y,\n            z,\n            levels=levels,\n            linewidths=linewidths,\n            colors=colors,\n            linestyles=linestyles,\n            zorder=zorder,\n        )\n\n        labels: Iterable[float]\n        if label_levels:\n            labels = [l for l in label_levels if l in cn.levels]\n        else:\n            labels = cn.levels\n\n        cl = self.ax.clabel(\n            cn,\n            labels,  # type: ignore\n            inline=True,\n            fmt=label_format,\n            fontsize=\"small\",\n            zorder=zorder,\n        )\n\n        for t in cn.labelTexts:\n            add_shade_to_text(t, alpha=0.5)\n            t.set_rotation(0)\n\n        return self\n\n    def plot_hatch(\n        self,\n        values: NDArray,\n        time: NDArray,\n        height: NDArray,\n        value_range: tuple[float, float],\n        hatch: str = \"/////\",\n        linewidth: float = 1,\n        linewidth_border: float = 0,\n        color: ColorLike | None = \"black\",\n        color_border: ColorLike | None = None,\n        zorder: int | float | None = 2,\n        legend_label: str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds hatched/filled areas to the plot.\"\"\"\n        values = np.asarray(values)\n        time = np.asarray(time)\n        height = np.asarray(height)\n\n        if len(height.shape) == 2:\n            height = height[0]\n\n        color = Color.from_optional(color)\n        color_border = Color.from_optional(color_border)\n\n        cnf = self.ax.contourf(\n            time,\n            height,\n            values.T,\n            levels=[value_range[0], value_range[1]],\n            colors=[\"none\"],\n            hatches=[hatch],\n            zorder=zorder,\n        )\n        cnf.set_edgecolors(color)  # type: ignore\n        cnf.set_hatch_linewidth(linewidth)\n\n        color = Color(cnf.get_edgecolors()[0], is_normalized=True)  # type: ignore\n        if color_border is None:\n            color_border = color.hex\n        cnf.set_color(color_border)  # type: ignore\n        cnf.set_linewidth(linewidth_border)\n\n        if isinstance(legend_label, str):\n            from matplotlib.patches import Patch\n\n            _facecolor = \"none\"\n            if color.is_close_to_white():\n                _facecolor = color.blend(0.7, \"black\").hex\n\n            hatch_patch = Patch(\n                linewidth=linewidth_border,\n                facecolor=_facecolor,\n                edgecolor=color.hex,\n                hatch=hatch,\n                label=legend_label,\n            )\n\n            self._legend_handles.append(hatch_patch)\n            self._legend_labels.append(legend_label)\n\n        return self\n\n    def ecplot_hatch(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        value_range: tuple[float, float],\n        time_var: str = TIME_VAR,\n        height_var: str = HEIGHT_VAR,\n        hatch: str = \"/////\",\n        linewidth: float = 1,\n        linewidth_border: float = 0,\n        color: ColorLike | None = \"black\",\n        color_border: ColorLike | None = None,\n        zorder: int | float | None = 2,\n        legend_label: str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds hatched/filled areas to the plot.\"\"\"\n        height = ds[height_var].values\n        time = ds[time_var].values\n        values = ds[var].values\n\n        return self.plot_hatch(\n            values=values,\n            time=time,\n            height=height,\n            value_range=value_range,\n            hatch=hatch,\n            linewidth=linewidth,\n            linewidth_border=linewidth_border,\n            color=color,\n            color_border=color_border,\n            zorder=zorder,\n            legend_label=legend_label,\n        )\n\n    def ecplot_hatch_attenuated(\n        self,\n        ds: xr.Dataset,\n        var: str = \"simple_classification\",\n        value_range: tuple[float, float] = (-1.5, -0.5),\n        **kwargs,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds hatched area where ATLID \"simple_classification\" shows \"attenuated\" (-1).\"\"\"\n        return self.ecplot_hatch(\n            ds=ds,\n            var=var,\n            value_range=value_range,\n            **kwargs,\n        )\n\n    def ecplot_contour(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        time_var: str = TIME_VAR,\n        height_var: str = HEIGHT_VAR,\n        levels: list | NDArray | None = None,\n        label_format: str | None = None,\n        label_levels: list | NDArray | None = None,\n        linewidths: int | float | list | NDArray | None = 1.5,\n        linestyles: str | list | NDArray | None = \"solid\",\n        colors: Color | str | list | NDArray | None = \"black\",\n        zorder: float | int = 3,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds contour lines to the plot.\"\"\"\n        values = ds[var].values\n        time = ds[time_var].values\n        height = ds[height_var].values\n        tp = ProfileData(values=values, time=time, height=height)\n        self.plot_contour(\n            values=tp.values,\n            time=tp.time,\n            height=tp.height,\n            levels=levels,\n            linewidths=linewidths,\n            linestyles=linestyles,\n            colors=colors,\n            zorder=zorder,\n            label_format=label_format,\n            label_levels=label_levels,\n        )\n        return self\n\n    def ecplot_temperature(\n        self,\n        ds: xr.Dataset,\n        var: str = TEMP_CELSIUS_VAR,\n        label_format: str | None = \"$%.0f^{\\circ}$C\",\n        label_levels: list | NDArray | None = [-80, -40, 0],\n        levels=[\n            -80,\n            -70,\n            -60,\n            -50,\n            -40,\n            -30,\n            -20,\n            -10,\n            0,\n            10,\n            20,\n        ],\n        linewidths=[\n            0.75,  # -80\n            0.25,  # -70\n            0.50,  # -60\n            0.50,  # -50\n            0.75,  # -40\n            0.50,  # -30\n            0.75,  # -20\n            0.50,  # -10\n            1.00,  # 0\n            0.50,  # 10\n            0.75,  # 20\n        ],\n        linestyles=[\n            \"dashed\",  # -80\n            \"dashed\",  # -70\n            \"dashed\",  # -60\n            \"dashed\",  # -50\n            \"dashed\",  # -40\n            \"dashed\",  # -30\n            \"dashed\",  # -20\n            \"dashed\",  # -10\n            \"solid\",  # 0\n            \"solid\",  # 10\n            \"solid\",  # 20\n        ],\n        colors=\"black\",\n        **kwargs,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds temperature contour lines to the plot.\"\"\"\n        return self.ecplot_contour(\n            ds=ds,\n            var=var,\n            label_format=label_format,\n            levels=levels,\n            label_levels=label_levels,\n            linewidths=linewidths,\n            linestyles=linestyles,\n            colors=colors,\n            **kwargs,\n        )\n\n    def ecplot_pressure(\n        self,\n        ds: xr.Dataset,\n        var: str = PRESSURE_VAR,\n        time_var: str = TIME_VAR,\n        height_var: str = HEIGHT_VAR,\n        label_format: str | None = r\"%d hPa\",\n        **kwargs,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds pressure contour lines to the plot.\"\"\"\n        values = ds[var].values / 100.0\n        time = ds[time_var].values\n        height = ds[height_var].values\n        return self.plot_contour(\n            values=values,\n            time=time,\n            height=height,\n            label_format=label_format,\n            **kwargs,\n        )\n\n    def ecplot_elevation(\n        self,\n        ds: xr.Dataset,\n        var: str = ELEVATION_VAR,\n        time_var: str = TIME_VAR,\n        land_flag_var: str = LAND_FLAG_VAR,\n        color: Color | str | None = \"ec:land\",\n        color_water: Color | str | None = \"ec:water\",\n        legend_label: str | None = None,\n        legend_label_water: str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds filled elevation/surface area to the plot.\"\"\"\n        height = ds[var].copy().values\n        time = ds[time_var].copy().values\n\n        kwargs = dict(\n            linewidth=0,\n            linestyle=\"none\",\n            marker=\"none\",\n            markersize=0,\n            fill=True,\n            zorder=10,\n        )\n\n        is_water = land_flag_var in ds.variables\n\n        if is_water:\n            land_flag = ds[land_flag_var].copy().values == 1\n            height_water = height.copy()\n            height_water[land_flag] = np.nan\n            height[~land_flag] = np.nan\n\n        self.plot_height(\n            height=height,\n            time=time,\n            color=color,\n            legend_label=legend_label,\n            **kwargs,  # type: ignore\n        )\n\n        if is_water:\n            self.plot_height(\n                height=height_water,\n                time=time,\n                color=color_water,\n                legend_label=legend_label_water,\n                **kwargs,  # type: ignore\n            )\n\n        return self\n\n    def ecplot_tropopause(\n        self,\n        ds: xr.Dataset,\n        var: str = TROPOPAUSE_VAR,\n        time_var: str = TIME_VAR,\n        color: Color | str | None = \"ec:tropopause\",\n        linewidth: float = 2,\n        linestyle: str = \"solid\",\n        legend_label: str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        \"\"\"Adds tropopause line to the plot.\"\"\"\n        height = ds[var].values\n        time = ds[time_var].values\n        self.plot_height(\n            height=height,\n            time=time,\n            linewidth=linewidth,\n            linestyle=linestyle,\n            color=color,\n            marker=\"none\",\n            markersize=0,\n            fill=False,\n            zorder=12,\n            legend_label=legend_label,\n        )\n\n        return self\n\n    def to_texture(self) -&gt; \"CurtainFigure\":\n        \"\"\"Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.\"\"\"\n        # Remove anchored text and other artist text objects\n        for artist in reversed(self.ax.artists):\n            if isinstance(artist, (Text, AnchoredOffsetbox)):\n                artist.remove()\n\n        # Completely remove axis ticks and labels\n        self.ax.axis(\"off\")\n\n        if self.ax_top:\n            self.ax_top.axis(\"off\")\n\n        if self.ax_right:\n            self.ax_right.axis(\"off\")\n\n        # Remove white frame around figure\n        self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n        # Remove colorbar\n        if self.colorbar:\n            self.colorbar.remove()\n            self.colorbar = None\n\n        # Remove legend\n        if self.legend:\n            self.legend.remove()\n            self.legend = None\n\n        return self\n\n    def invert_xaxis(self) -&gt; \"CurtainFigure\":\n        \"\"\"Invert the x-axis.\"\"\"\n        self.ax.invert_xaxis()\n        if self.ax_top:\n            self.ax_top.invert_xaxis()\n        return self\n\n    def invert_yaxis(self) -&gt; \"CurtainFigure\":\n        \"\"\"Invert the y-axis.\"\"\"\n        self.ax.invert_yaxis()\n        if self.ax_right:\n            self.ax_right.invert_yaxis()\n        return self\n\n    def show_legend(\n        self,\n        loc: str = \"upper left\",\n        markerscale: float = 1.5,\n        frameon: bool = True,\n        facecolor: ColorLike = \"white\",\n        edgecolor: ColorLike = \"black\",\n        framealpha: float = 0.8,\n        edgewidth: float = 1.5,\n        fancybox: bool = False,\n        handlelength: float = 0.7,\n        handletextpad: float = 0.5,\n        borderaxespad: float = 0,\n        ncols: int = 8,\n        textcolor: ColorLike = \"black\",\n        textweight: int | str = \"normal\",\n        textshadealpha: float = 0.0,\n        textshadewidth: float = 3.0,\n        textshadecolor: ColorLike = \"white\",\n        **kwargs,\n    ) -&gt; \"CurtainFigure\":\n        from matplotlib.legend_handler import HandlerTuple\n\n        facecolor = Color(facecolor)\n        edgecolor = Color(edgecolor)\n        textcolor = Color(textcolor)\n        textshadecolor = Color(textshadecolor)\n\n        if len(self._legend_handles) &gt; 0:\n            self.legend = self.ax.legend(\n                self._legend_handles,\n                self._legend_labels,\n                loc=loc,\n                markerscale=markerscale,\n                frameon=frameon,\n                facecolor=facecolor,\n                edgecolor=edgecolor,\n                framealpha=framealpha,\n                fancybox=fancybox,\n                handlelength=handlelength,\n                handletextpad=handletextpad,\n                borderaxespad=borderaxespad,\n                ncols=ncols,\n                handler_map={tuple: HandlerTuple(ndivide=1)},\n                **kwargs,\n            )\n            self.legend.get_frame().set_linewidth(edgewidth)\n            for text in self.legend.get_texts():\n                text.set_color(textcolor)\n                text.set_fontweight(textweight)\n\n                if textshadealpha &gt; 0:\n                    text = add_shade_to_text(\n                        text,\n                        alpha=textshadealpha,\n                        linewidth=textshadewidth,\n                        color=textshadecolor,\n                    )\n        return self\n\n    def set_colorbar_tick_scale(\n        self,\n        multiplier: float | None = None,\n        fontsize: float | str | None = None,\n    ) -&gt; \"CurtainFigure\":\n        _cb = self.colorbar\n        cb: Colorbar\n        if isinstance(_cb, Colorbar):\n            cb = _cb\n        else:\n            return self\n\n        if fontsize is not None:\n            cb.ax.tick_params(labelsize=fontsize)\n            return self\n\n        if multiplier is not None:\n            tls = cb.ax.yaxis.get_ticklabels()\n            if len(tls) == 0:\n                tls = cb.ax.xaxis.get_ticklabels()\n            if len(tls) == 0:\n                return self\n            _fontsize = tls[0].get_fontsize()\n            if isinstance(_fontsize, str):\n                from matplotlib import font_manager\n\n                fp = font_manager.FontProperties(size=_fontsize)\n                _fontsize = fp.get_size_in_points()\n            cb.ax.tick_params(labelsize=_fontsize * multiplier)\n        return self\n\n    def show(self) -&gt; None:\n        import IPython\n        import matplotlib.pyplot as plt\n        from IPython.display import display\n\n        if IPython.get_ipython() is not None:\n            display(self.fig)\n        else:\n            plt.show()\n\n    def save(\n        self,\n        filename: str = \"\",\n        filepath: str | None = None,\n        ds: xr.Dataset | None = None,\n        ds_filepath: str | None = None,\n        dpi: float | Literal[\"figure\"] = \"figure\",\n        orbit_and_frame: str | None = None,\n        utc_timestamp: TimestampLike | None = None,\n        use_utc_creation_timestamp: bool = False,\n        site_name: str | None = None,\n        hmax: int | float | None = None,\n        radius: int | float | None = None,\n        extra: str | None = None,\n        transparent_outside: bool = False,\n        verbose: bool = True,\n        print_prefix: str = \"\",\n        create_dirs: bool = False,\n        transparent_background: bool = False,\n        resolution: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n        Args:\n            figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n            filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n            filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n            ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n            ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n            pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n            dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n            orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n            site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n            transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n            verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n            print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n            create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n            transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n            **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n        \"\"\"\n        save_plot(\n            fig=self.fig,\n            filename=filename,\n            filepath=filepath,\n            ds=ds,\n            ds_filepath=ds_filepath,\n            dpi=dpi,\n            orbit_and_frame=orbit_and_frame,\n            utc_timestamp=utc_timestamp,\n            use_utc_creation_timestamp=use_utc_creation_timestamp,\n            site_name=site_name,\n            hmax=hmax,\n            radius=radius,\n            extra=extra,\n            transparent_outside=transparent_outside,\n            verbose=verbose,\n            print_prefix=print_prefix,\n            create_dirs=create_dirs,\n            transparent_background=transparent_background,\n            resolution=resolution,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot","title":"ecplot","text":"<pre><code>ecplot(\n    ds,\n    var,\n    *,\n    time_var=TIME_VAR,\n    height_var=HEIGHT_VAR,\n    lat_var=TRACK_LAT_VAR,\n    lon_var=TRACK_LON_VAR,\n    temperature_var=TEMP_CELSIUS_VAR,\n    along_track_dim=ALONG_TRACK_DIM,\n    values=None,\n    time=None,\n    height=None,\n    latitude=None,\n    longitude=None,\n    values_temperature=None,\n    site=None,\n    radius_km=100.0,\n    mark_closest_profile=False,\n    show_info=True,\n    show_radius=True,\n    info_text_loc=None,\n    value_range=\"default\",\n    log_scale=None,\n    norm=None,\n    time_range=None,\n    height_range=(0, 40000.0),\n    label=None,\n    units=None,\n    cmap=None,\n    colorbar=True,\n    colorbar_ticks=None,\n    colorbar_tick_labels=None,\n    colorbar_position=\"right\",\n    colorbar_alignment=\"center\",\n    colorbar_width=DEFAULT_COLORBAR_WIDTH,\n    colorbar_spacing=0.2,\n    colorbar_length_ratio=\"100%\",\n    colorbar_label_outside=True,\n    colorbar_ticks_outside=True,\n    colorbar_ticks_both=False,\n    rolling_mean=None,\n    selection_time_range=None,\n    selection_color=Color(\"ec:earthcare\"),\n    selection_linestyle=\"dashed\",\n    selection_linewidth=2.5,\n    selection_highlight=False,\n    selection_highlight_inverted=True,\n    selection_highlight_color=Color(\"white\"),\n    selection_highlight_alpha=0.5,\n    selection_max_time_margin=None,\n    ax_style_top=None,\n    ax_style_bottom=None,\n    show_temperature=False,\n    mode=None,\n    min_num_profiles=5000,\n    mark_profiles_at=None,\n    mark_profiles_at_color=None,\n    mark_profiles_at_linestyle=\"solid\",\n    mark_profiles_at_linewidth=2.5,\n    label_length=40,\n    **kwargs\n)\n</code></pre> <p>Plot a vertical curtain (i.e. cross-section) of a variable along the satellite track a EarthCARE dataset.</p> <p>This method collections all required data from a EarthCARE <code>xarray.dataset</code>, such as time, height, latitude and longitude. It supports various forms of customization through the use of arguments listed below.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The EarthCARE dataset from with data will be plotted.</p> required <code>var</code> <code>str</code> <p>Name of the variable to plot.</p> required <code>time_var</code> <code>str</code> <p>Name of the time variable. Defaults to TIME_VAR.</p> <code>TIME_VAR</code> <code>height_var</code> <code>str</code> <p>Name of the height variable. Defaults to HEIGHT_VAR.</p> <code>HEIGHT_VAR</code> <code>lat_var</code> <code>str</code> <p>Name of the latitude variable. Defaults to TRACK_LAT_VAR.</p> <code>TRACK_LAT_VAR</code> <code>lon_var</code> <code>str</code> <p>Name of the longitude variable. Defaults to TRACK_LON_VAR.</p> <code>TRACK_LON_VAR</code> <code>temperature_var</code> <code>str</code> <p>Name of the temperature variable; ignored if <code>show_temperature</code> is set to False. Defaults to TEMP_CELSIUS_VAR.</p> <code>TEMP_CELSIUS_VAR</code> <code>along_track_dim</code> <code>str</code> <p>Dimension name representing the along-track direction. Defaults to ALONG_TRACK_DIM.</p> <code>ALONG_TRACK_DIM</code> <code>values</code> <code>NDArray | None</code> <p>Data values to be used instead of values found in the <code>var</code> variable of the dataset. Defaults to None.</p> <code>None</code> <code>time</code> <code>NDArray | None</code> <p>Time values to be used instead of values found in the <code>time_var</code> variable of the dataset. Defaults to None.</p> <code>None</code> <code>height</code> <code>NDArray | None</code> <p>Height values to be used instead of values found in the <code>height_var</code> variable of the dataset. Defaults to None.</p> <code>None</code> <code>latitude</code> <code>NDArray | None</code> <p>Latitude values to be used instead of values found in the <code>lat_var</code> variable of the dataset. Defaults to None.</p> <code>None</code> <code>longitude</code> <code>NDArray | None</code> <p>Longitude values to be used instead of values found in the <code>lon_var</code> variable of the dataset. Defaults to None.</p> <code>None</code> <code>values_temperature</code> <code>NDArray | None</code> <p>Temperature values to be used instead of values found in the <code>temperature_var</code> variable of the dataset. Defaults to None.</p> <code>None</code> <code>site</code> <code>str | GroundSite | None</code> <p>Highlights data within <code>radius_km</code> of a ground site (given either as a <code>GroundSite</code> object or name string); ignored if not set. Defaults to None.</p> <code>None</code> <code>radius_km</code> <code>float</code> <p>Radius around the ground site to highlight data from; ignored if <code>site</code> not set. Defaults to 100.0.</p> <code>100.0</code> <code>mark_closest_profile</code> <code>bool</code> <p>Mark the closest profile to the ground site in the plot; ignored if <code>site</code> not set. Defaults to False.</p> <code>False</code> <code>show_info</code> <code>bool</code> <p>If True, show text on the plot containing EarthCARE frame and baseline info. Defaults to True.</p> <code>True</code> <code>info_text_loc</code> <code>str | None</code> <p>Place info text at a specific location of the plot, e.g. \"upper right\" or \"lower left\". Defaults to None.</p> <code>None</code> <code>value_range</code> <code>ValueRangeLike | None</code> <p>Min and max range for the variable values. Defaults to None.</p> <code>'default'</code> <code>log_scale</code> <code>bool | None</code> <p>Whether to apply a logarithmic color scale. Defaults to None.</p> <code>None</code> <code>norm</code> <code>Normalize | None</code> <p>Matplotlib norm to use for color scaling. Defaults to None.</p> <code>None</code> <code>time_range</code> <code>TimeRangeLike | None</code> <p>Time range to restrict the data for plotting. Defaults to None.</p> <code>None</code> <code>height_range</code> <code>DistanceRangeLike | None</code> <p>Height range to restrict the data for plotting. Defaults to (0, 40e3).</p> <code>(0, 40000.0)</code> <code>label</code> <code>str | None</code> <p>Label to use for colorbar. Defaults to None.</p> <code>None</code> <code>units</code> <code>str | None</code> <p>Units of the variable to show in the colorbar label. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str | Colormap | None</code> <p>Colormap to use for plotting. Defaults to None.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>Whether to display a colorbar. Defaults to True.</p> <code>True</code> <code>colorbar_ticks</code> <code>ArrayLike | None</code> <p>Custom tick values for the colorbar. Defaults to None.</p> <code>None</code> <code>colorbar_tick_labels</code> <code>ArrayLike | None</code> <p>Custom labels for the colorbar ticks. Defaults to None.</p> <code>None</code> <code>rolling_mean</code> <code>int | None</code> <p>Apply rolling mean along time axis with this window size. Defaults to None.</p> <code>None</code> <code>selection_time_range</code> <code>TimeRangeLike | None</code> <p>Time range to highlight as a selection; ignored if <code>site</code> is set. Defaults to None.</p> <code>None</code> <code>selection_color</code> <code>_type_</code> <p>Color for the selection range marker lines. Defaults to Color(\"ec:earthcare\").</p> <code>Color('ec:earthcare')</code> <code>selection_linestyle</code> <code>str | None</code> <p>Line style for selection range markers. Defaults to \"dashed\".</p> <code>'dashed'</code> <code>selection_linewidth</code> <code>float | int | None</code> <p>Line width for selection range markers. Defaults to 2.5.</p> <code>2.5</code> <code>selection_highlight</code> <code>bool</code> <p>Whether to highlight the selection region by shading outside or inside areas. Defaults to False.</p> <code>False</code> <code>selection_highlight_inverted</code> <code>bool</code> <p>If True and <code>selection_highlight</code> is also set to True, areas outside the selection are shaded. Defaults to True.</p> <code>True</code> <code>selection_highlight_color</code> <code>str | None</code> <p>If True and <code>selection_highlight</code> is also set to True, sets color used for shading selected outside or inside areas. Defaults to Color(\"white\").</p> <code>Color('white')</code> <code>selection_highlight_alpha</code> <code>float</code> <p>If True and <code>selection_highlight</code> is also set to True, sets transparency used for shading selected outside or inside areas.. Defaults to 0.5.</p> <code>0.5</code> <code>selection_max_time_margin</code> <code>TimedeltaLike | Sequence[TimedeltaLike]</code> <p>Zooms the time axis to a given maximum time from a selected time area. Defaults to None.</p> <code>None</code> <code>ax_style_top</code> <code>AlongTrackAxisStyle | str | None</code> <p>Style for the top axis (e.g., geo, lat, lon, distance, time, utc, lst, none). Defaults to None.</p> <code>None</code> <code>ax_style_bottom</code> <code>AlongTrackAxisStyle | str | None</code> <p>Style for the bottom axis (e.g., geo, lat, lon, distance, time, utc, lst, none). Defaults to None.</p> <code>None</code> <code>show_temperature</code> <code>bool</code> <p>Whether to overlay temperature as contours; requires either <code>values_temperature</code> or <code>temperature_var</code>. Defaults to False.</p> <code>False</code> <code>mode</code> <code>Literal['exact', 'fast'] | None</code> <p>Overwrites the curtain plotting mode. Use \"fast\" to speed up plotting by coarsening data to at least <code>min_num_profiles</code>; \"exact\" plots full resolution. Defaults to None.</p> <code>None</code> <code>min_num_profiles</code> <code>int</code> <p>Overwrites the minimum number of profiles to keep when using \"fast\" mode. Defaults to 1000.</p> <code>5000</code> <code>mark_profiles_at</code> <code>Sequence[TimestampLike] | None</code> <p>Timestamps at which to mark vertical profiles. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CurtainFigure</code> <code>CurtainFigure</code> <p>The figure object containing the curtain plot.</p> Example <pre><code>import earthcarekit as eck\n\nfilepath = \"path/to/mydata/ECA_EXAE_ATL_NOM_1B_20250606T132535Z_20250606T150730Z_05813D.h5\"\nwith eck.read_product(filepath) as ds:\n    cf = eck.CurtainFigure()\n    cf = cf.ecplot(ds, \"mie_attenuated_backscatter\", height_range=(0, 20e3))\n</code></pre> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot(\n    self,\n    ds: xr.Dataset,\n    var: str,\n    *,\n    time_var: str = TIME_VAR,\n    height_var: str = HEIGHT_VAR,\n    lat_var: str = TRACK_LAT_VAR,\n    lon_var: str = TRACK_LON_VAR,\n    temperature_var: str = TEMP_CELSIUS_VAR,\n    along_track_dim: str = ALONG_TRACK_DIM,\n    values: NDArray | None = None,\n    time: NDArray | None = None,\n    height: NDArray | None = None,\n    latitude: NDArray | None = None,\n    longitude: NDArray | None = None,\n    values_temperature: NDArray | None = None,\n    site: str | GroundSite | None = None,\n    radius_km: float = 100.0,\n    mark_closest_profile: bool = False,\n    show_info: bool = True,\n    show_radius: bool = True,\n    info_text_loc: str | None = None,\n    # Common args for wrappers\n    value_range: ValueRangeLike | Literal[\"default\"] | None = \"default\",\n    log_scale: bool | None = None,\n    norm: Normalize | None = None,\n    time_range: TimeRangeLike | None = None,\n    height_range: DistanceRangeLike | None = (0, 40e3),\n    label: str | None = None,\n    units: str | None = None,\n    cmap: str | Colormap | None = None,\n    colorbar: bool = True,\n    colorbar_ticks: ArrayLike | None = None,\n    colorbar_tick_labels: ArrayLike | None = None,\n    colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"right\",\n    colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n    colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n    colorbar_spacing: float = 0.2,\n    colorbar_length_ratio: float | str = \"100%\",\n    colorbar_label_outside: bool = True,\n    colorbar_ticks_outside: bool = True,\n    colorbar_ticks_both: bool = False,\n    rolling_mean: int | None = None,\n    selection_time_range: TimeRangeLike | None = None,\n    selection_color: str | None = Color(\"ec:earthcare\"),\n    selection_linestyle: str | None = \"dashed\",\n    selection_linewidth: float | int | None = 2.5,\n    selection_highlight: bool = False,\n    selection_highlight_inverted: bool = True,\n    selection_highlight_color: str | None = Color(\"white\"),\n    selection_highlight_alpha: float = 0.5,\n    selection_max_time_margin: (\n        TimedeltaLike | Sequence[TimedeltaLike] | None\n    ) = None,\n    ax_style_top: AlongTrackAxisStyle | str | None = None,\n    ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n    show_temperature: bool = False,\n    mode: Literal[\"exact\", \"fast\"] | None = None,\n    min_num_profiles: int = 5000,\n    mark_profiles_at: Sequence[TimestampLike] | None = None,\n    mark_profiles_at_color: (\n        str | Color | Sequence[str | Color | None] | None\n    ) = None,\n    mark_profiles_at_linestyle: str | Sequence[str] = \"solid\",\n    mark_profiles_at_linewidth: float | Sequence[float] = 2.5,\n    label_length: int = 40,\n    **kwargs,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Plot a vertical curtain (i.e. cross-section) of a variable along the satellite track a EarthCARE dataset.\n\n    This method collections all required data from a EarthCARE `xarray.dataset`, such as time, height, latitude and longitude.\n    It supports various forms of customization through the use of arguments listed below.\n\n    Args:\n        ds (xr.Dataset): The EarthCARE dataset from with data will be plotted.\n        var (str): Name of the variable to plot.\n        time_var (str, optional): Name of the time variable. Defaults to TIME_VAR.\n        height_var (str, optional): Name of the height variable. Defaults to HEIGHT_VAR.\n        lat_var (str, optional): Name of the latitude variable. Defaults to TRACK_LAT_VAR.\n        lon_var (str, optional): Name of the longitude variable. Defaults to TRACK_LON_VAR.\n        temperature_var (str, optional): Name of the temperature variable; ignored if `show_temperature` is set to False. Defaults to TEMP_CELSIUS_VAR.\n        along_track_dim (str, optional): Dimension name representing the along-track direction. Defaults to ALONG_TRACK_DIM.\n        values (NDArray | None, optional): Data values to be used instead of values found in the `var` variable of the dataset. Defaults to None.\n        time (NDArray | None, optional): Time values to be used instead of values found in the `time_var` variable of the dataset. Defaults to None.\n        height (NDArray | None, optional): Height values to be used instead of values found in the `height_var` variable of the dataset. Defaults to None.\n        latitude (NDArray | None, optional): Latitude values to be used instead of values found in the `lat_var` variable of the dataset. Defaults to None.\n        longitude (NDArray | None, optional): Longitude values to be used instead of values found in the `lon_var` variable of the dataset. Defaults to None.\n        values_temperature (NDArray | None, optional): Temperature values to be used instead of values found in the `temperature_var` variable of the dataset. Defaults to None.\n        site (str | GroundSite | None, optional): Highlights data within `radius_km` of a ground site (given either as a `GroundSite` object or name string); ignored if not set. Defaults to None.\n        radius_km (float, optional): Radius around the ground site to highlight data from; ignored if `site` not set. Defaults to 100.0.\n        mark_closest_profile (bool, optional): Mark the closest profile to the ground site in the plot; ignored if `site` not set. Defaults to False.\n        show_info (bool, optional): If True, show text on the plot containing EarthCARE frame and baseline info. Defaults to True.\n        info_text_loc (str | None, optional): Place info text at a specific location of the plot, e.g. \"upper right\" or \"lower left\". Defaults to None.\n        value_range (ValueRangeLike | None, optional): Min and max range for the variable values. Defaults to None.\n        log_scale (bool | None, optional): Whether to apply a logarithmic color scale. Defaults to None.\n        norm (Normalize | None, optional): Matplotlib norm to use for color scaling. Defaults to None.\n        time_range (TimeRangeLike | None, optional): Time range to restrict the data for plotting. Defaults to None.\n        height_range (DistanceRangeLike | None, optional): Height range to restrict the data for plotting. Defaults to (0, 40e3).\n        label (str | None, optional): Label to use for colorbar. Defaults to None.\n        units (str | None, optional): Units of the variable to show in the colorbar label. Defaults to None.\n        cmap (str | Colormap | None, optional): Colormap to use for plotting. Defaults to None.\n        colorbar (bool, optional): Whether to display a colorbar. Defaults to True.\n        colorbar_ticks (ArrayLike | None, optional): Custom tick values for the colorbar. Defaults to None.\n        colorbar_tick_labels (ArrayLike | None, optional): Custom labels for the colorbar ticks. Defaults to None.\n        rolling_mean (int | None, optional): Apply rolling mean along time axis with this window size. Defaults to None.\n        selection_time_range (TimeRangeLike | None, optional): Time range to highlight as a selection; ignored if `site` is set. Defaults to None.\n        selection_color (_type_, optional): Color for the selection range marker lines. Defaults to Color(\"ec:earthcare\").\n        selection_linestyle (str | None, optional): Line style for selection range markers. Defaults to \"dashed\".\n        selection_linewidth (float | int | None, optional): Line width for selection range markers. Defaults to 2.5.\n        selection_highlight (bool, optional): Whether to highlight the selection region by shading outside or inside areas. Defaults to False.\n        selection_highlight_inverted (bool, optional): If True and `selection_highlight` is also set to True, areas outside the selection are shaded. Defaults to True.\n        selection_highlight_color (str | None, optional): If True and `selection_highlight` is also set to True, sets color used for shading selected outside or inside areas. Defaults to Color(\"white\").\n        selection_highlight_alpha (float, optional): If True and `selection_highlight` is also set to True, sets transparency used for shading selected outside or inside areas.. Defaults to 0.5.\n        selection_max_time_margin (TimedeltaLike | Sequence[TimedeltaLike], optional): Zooms the time axis to a given maximum time from a selected time area. Defaults to None.\n        ax_style_top (AlongTrackAxisStyle | str | None, optional): Style for the top axis (e.g., geo, lat, lon, distance, time, utc, lst, none). Defaults to None.\n        ax_style_bottom (AlongTrackAxisStyle | str | None, optional): Style for the bottom axis (e.g., geo, lat, lon, distance, time, utc, lst, none). Defaults to None.\n        show_temperature (bool, optional): Whether to overlay temperature as contours; requires either `values_temperature` or `temperature_var`. Defaults to False.\n        mode (Literal[\"exact\", \"fast\"] | None, optional): Overwrites the curtain plotting mode. Use \"fast\" to speed up plotting by coarsening data to at least `min_num_profiles`; \"exact\" plots full resolution. Defaults to None.\n        min_num_profiles (int, optional): Overwrites the minimum number of profiles to keep when using \"fast\" mode. Defaults to 1000.\n        mark_profiles_at (Sequence[TimestampLike] | None, optional): Timestamps at which to mark vertical profiles. Defaults to None.\n\n    Returns:\n        CurtainFigure: The figure object containing the curtain plot.\n\n    Example:\n        ```python\n        import earthcarekit as eck\n\n        filepath = \"path/to/mydata/ECA_EXAE_ATL_NOM_1B_20250606T132535Z_20250606T150730Z_05813D.h5\"\n        with eck.read_product(filepath) as ds:\n            cf = eck.CurtainFigure()\n            cf = cf.ecplot(ds, \"mie_attenuated_backscatter\", height_range=(0, 20e3))\n        ```\n    \"\"\"\n\n    # Collect all common args for wrapped plot function call\n    local_args = locals()\n    # Delete all args specific to this wrapper function\n    del local_args[\"self\"]\n    del local_args[\"ds\"]\n    del local_args[\"var\"]\n    del local_args[\"time_var\"]\n    del local_args[\"height_var\"]\n    del local_args[\"lat_var\"]\n    del local_args[\"lon_var\"]\n    del local_args[\"temperature_var\"]\n    del local_args[\"along_track_dim\"]\n    del local_args[\"site\"]\n    del local_args[\"radius_km\"]\n    del local_args[\"show_info\"]\n    del local_args[\"show_radius\"]\n    del local_args[\"info_text_loc\"]\n    del local_args[\"mark_closest_profile\"]\n    # Delete kwargs to then merge it with the residual common args\n    del local_args[\"kwargs\"]\n    all_args = {**local_args, **kwargs}\n\n    warn_about_variable_limitations(var)\n\n    if all_args[\"values\"] is None:\n        all_args[\"values\"] = ds[var].values\n    if all_args[\"time\"] is None:\n        all_args[\"time\"] = ds[time_var].values\n    if all_args[\"height\"] is None:\n        all_args[\"height\"] = ds[height_var].values\n    if all_args[\"latitude\"] is None:\n        all_args[\"latitude\"] = ds[lat_var].values\n    if all_args[\"longitude\"] is None:\n        all_args[\"longitude\"] = ds[lon_var].values\n    if all_args[\"values_temperature\"] is None:\n        if show_temperature == False:\n            all_args[\"values_temperature\"] = None\n        elif ds.get(temperature_var, None) is None:\n            warnings.warn(\n                f'No temperature variable called \"{temperature_var}\" found in given dataset.'\n            )\n            all_args[\"values_temperature\"] = None\n        else:\n            all_args[\"values_temperature\"] = ds[temperature_var].values\n\n    # Set default values depending on variable name\n    if label is None:\n        all_args[\"label\"] = (\n            \"Values\" if not hasattr(ds[var], \"long_name\") else ds[var].long_name\n        )\n    if units is None:\n        all_args[\"units\"] = \"-\" if not hasattr(ds[var], \"units\") else ds[var].units\n    if isinstance(value_range, str) and value_range == \"default\":\n        value_range = None\n        all_args[\"value_range\"] = None\n        if log_scale is None and norm is None:\n            all_args[\"norm\"] = get_default_norm(var, file_type=ds)\n    if rolling_mean is None:\n        all_args[\"rolling_mean\"] = get_default_rolling_mean(var, file_type=ds)\n    if cmap is None:\n        all_args[\"cmap\"] = get_default_cmap(var, file_type=ds)\n    all_args[\"cmap\"] = get_cmap(all_args[\"cmap\"])\n\n    if all_args[\"cmap\"] == get_cmap(\"synergetic_tc\"):\n        self.colorbar_tick_scale = 0.8\n\n    # Handle overpass\n    _site: GroundSite | None = None\n    if isinstance(site, GroundSite):\n        _site = site\n    elif isinstance(site, str):\n        _site = get_ground_site(site)\n    else:\n        pass\n\n    if isinstance(_site, GroundSite):\n        info_overpass = get_overpass_info(\n            ds,\n            site_radius_km=radius_km,\n            site=_site,\n            time_var=time_var,\n            lat_var=lat_var,\n            lon_var=lon_var,\n            along_track_dim=along_track_dim,\n        )\n        if show_radius:\n            overpass_time_range = info_overpass.time_range\n            all_args[\"selection_time_range\"] = overpass_time_range\n        else:\n            mark_closest_profile = True\n        if mark_closest_profile:\n            _mark_profiles_at = all_args[\"mark_profiles_at\"]\n            _mark_profiles_at_color = all_args[\"mark_profiles_at_color\"]\n            _mark_profiles_at_linestyle = all_args[\"mark_profiles_at_linestyle\"]\n            _mark_profiles_at_linewidth = all_args[\"mark_profiles_at_linewidth\"]\n            if isinstance(_mark_profiles_at, (Sequence, np.ndarray)):\n                list(_mark_profiles_at).append(info_overpass.closest_time)\n                all_args[\"mark_profiles_at\"] = _mark_profiles_at\n            else:\n                all_args[\"mark_profiles_at\"] = [info_overpass.closest_time]\n\n            if not isinstance(_mark_profiles_at_color, str) and isinstance(\n                _mark_profiles_at_color, (Sequence, np.ndarray)\n            ):\n                list(_mark_profiles_at_color).append(\"ec:earthcare\")\n                all_args[\"mark_profiles_at_color\"] = _mark_profiles_at_color\n\n            if not isinstance(_mark_profiles_at_linestyle, str) and isinstance(\n                _mark_profiles_at_linestyle, (Sequence, np.ndarray)\n            ):\n                list(_mark_profiles_at_linestyle).append(\"solid\")\n                all_args[\"mark_profiles_at_linestyle\"] = _mark_profiles_at_linestyle\n\n            if isinstance(_mark_profiles_at_linewidth, (Sequence, np.ndarray)):\n                list(_mark_profiles_at_linewidth).append(2.5)\n                all_args[\"mark_profiles_at_linewidth\"] = _mark_profiles_at_linewidth\n\n            all_args[\"selection_linestyle\"] = \"none\"\n            all_args[\"selection_linewidth\"] = 0.1\n    self.plot(**all_args)\n\n    self._set_info_text_loc(info_text_loc)\n    if show_info:\n        self.info_text = add_text_product_info(\n            self.ax, ds, append_to=self.info_text, loc=self.info_text_loc\n        )\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_contour","title":"ecplot_contour","text":"<pre><code>ecplot_contour(\n    ds,\n    var,\n    time_var=TIME_VAR,\n    height_var=HEIGHT_VAR,\n    levels=None,\n    label_format=None,\n    label_levels=None,\n    linewidths=1.5,\n    linestyles=\"solid\",\n    colors=\"black\",\n    zorder=3,\n)\n</code></pre> <p>Adds contour lines to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_contour(\n    self,\n    ds: xr.Dataset,\n    var: str,\n    time_var: str = TIME_VAR,\n    height_var: str = HEIGHT_VAR,\n    levels: list | NDArray | None = None,\n    label_format: str | None = None,\n    label_levels: list | NDArray | None = None,\n    linewidths: int | float | list | NDArray | None = 1.5,\n    linestyles: str | list | NDArray | None = \"solid\",\n    colors: Color | str | list | NDArray | None = \"black\",\n    zorder: float | int = 3,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds contour lines to the plot.\"\"\"\n    values = ds[var].values\n    time = ds[time_var].values\n    height = ds[height_var].values\n    tp = ProfileData(values=values, time=time, height=height)\n    self.plot_contour(\n        values=tp.values,\n        time=tp.time,\n        height=tp.height,\n        levels=levels,\n        linewidths=linewidths,\n        linestyles=linestyles,\n        colors=colors,\n        zorder=zorder,\n        label_format=label_format,\n        label_levels=label_levels,\n    )\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_elevation","title":"ecplot_elevation","text":"<pre><code>ecplot_elevation(\n    ds,\n    var=ELEVATION_VAR,\n    time_var=TIME_VAR,\n    land_flag_var=LAND_FLAG_VAR,\n    color=\"ec:land\",\n    color_water=\"ec:water\",\n    legend_label=None,\n    legend_label_water=None,\n)\n</code></pre> <p>Adds filled elevation/surface area to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_elevation(\n    self,\n    ds: xr.Dataset,\n    var: str = ELEVATION_VAR,\n    time_var: str = TIME_VAR,\n    land_flag_var: str = LAND_FLAG_VAR,\n    color: Color | str | None = \"ec:land\",\n    color_water: Color | str | None = \"ec:water\",\n    legend_label: str | None = None,\n    legend_label_water: str | None = None,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds filled elevation/surface area to the plot.\"\"\"\n    height = ds[var].copy().values\n    time = ds[time_var].copy().values\n\n    kwargs = dict(\n        linewidth=0,\n        linestyle=\"none\",\n        marker=\"none\",\n        markersize=0,\n        fill=True,\n        zorder=10,\n    )\n\n    is_water = land_flag_var in ds.variables\n\n    if is_water:\n        land_flag = ds[land_flag_var].copy().values == 1\n        height_water = height.copy()\n        height_water[land_flag] = np.nan\n        height[~land_flag] = np.nan\n\n    self.plot_height(\n        height=height,\n        time=time,\n        color=color,\n        legend_label=legend_label,\n        **kwargs,  # type: ignore\n    )\n\n    if is_water:\n        self.plot_height(\n            height=height_water,\n            time=time,\n            color=color_water,\n            legend_label=legend_label_water,\n            **kwargs,  # type: ignore\n        )\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_hatch","title":"ecplot_hatch","text":"<pre><code>ecplot_hatch(\n    ds,\n    var,\n    value_range,\n    time_var=TIME_VAR,\n    height_var=HEIGHT_VAR,\n    hatch=\"/////\",\n    linewidth=1,\n    linewidth_border=0,\n    color=\"black\",\n    color_border=None,\n    zorder=2,\n    legend_label=None,\n)\n</code></pre> <p>Adds hatched/filled areas to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_hatch(\n    self,\n    ds: xr.Dataset,\n    var: str,\n    value_range: tuple[float, float],\n    time_var: str = TIME_VAR,\n    height_var: str = HEIGHT_VAR,\n    hatch: str = \"/////\",\n    linewidth: float = 1,\n    linewidth_border: float = 0,\n    color: ColorLike | None = \"black\",\n    color_border: ColorLike | None = None,\n    zorder: int | float | None = 2,\n    legend_label: str | None = None,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds hatched/filled areas to the plot.\"\"\"\n    height = ds[height_var].values\n    time = ds[time_var].values\n    values = ds[var].values\n\n    return self.plot_hatch(\n        values=values,\n        time=time,\n        height=height,\n        value_range=value_range,\n        hatch=hatch,\n        linewidth=linewidth,\n        linewidth_border=linewidth_border,\n        color=color,\n        color_border=color_border,\n        zorder=zorder,\n        legend_label=legend_label,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_hatch_attenuated","title":"ecplot_hatch_attenuated","text":"<pre><code>ecplot_hatch_attenuated(\n    ds, var=\"simple_classification\", value_range=(-1.5, -0.5), **kwargs\n)\n</code></pre> <p>Adds hatched area where ATLID \"simple_classification\" shows \"attenuated\" (-1).</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_hatch_attenuated(\n    self,\n    ds: xr.Dataset,\n    var: str = \"simple_classification\",\n    value_range: tuple[float, float] = (-1.5, -0.5),\n    **kwargs,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds hatched area where ATLID \"simple_classification\" shows \"attenuated\" (-1).\"\"\"\n    return self.ecplot_hatch(\n        ds=ds,\n        var=var,\n        value_range=value_range,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_height","title":"ecplot_height","text":"<pre><code>ecplot_height(\n    ds,\n    var,\n    time_var=TIME_VAR,\n    linewidth=1.5,\n    linestyle=\"none\",\n    color=\"black\",\n    zorder=2.1,\n    marker=\"s\",\n    markersize=1,\n    show_info=True,\n    info_text_loc=None,\n    legend_label=None,\n)\n</code></pre> <p>Adds height line to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_height(\n    self,\n    ds: xr.Dataset,\n    var: str,\n    time_var: str = TIME_VAR,\n    linewidth: int | float | None = 1.5,\n    linestyle: str | None = \"none\",\n    color: Color | str | None = \"black\",\n    zorder: int | float | None = 2.1,\n    marker: str | None = \"s\",\n    markersize: int | float | None = 1,\n    show_info: bool = True,\n    info_text_loc: str | None = None,\n    legend_label: str | None = None,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds height line to the plot.\"\"\"\n    height = ds[var].values\n    time = ds[time_var].values\n    self.plot_height(\n        height=height,\n        time=time,\n        linewidth=linewidth,\n        linestyle=linestyle,\n        color=color,\n        zorder=zorder,\n        marker=marker,\n        markersize=markersize,\n        legend_label=legend_label,\n    )\n\n    self._set_info_text_loc(info_text_loc)\n    if show_info:\n        self.info_text = add_text_product_info(\n            self.ax, ds, append_to=self.info_text, loc=self.info_text_loc\n        )\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_pressure","title":"ecplot_pressure","text":"<pre><code>ecplot_pressure(\n    ds,\n    var=PRESSURE_VAR,\n    time_var=TIME_VAR,\n    height_var=HEIGHT_VAR,\n    label_format=\"%d hPa\",\n    **kwargs\n)\n</code></pre> <p>Adds pressure contour lines to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_pressure(\n    self,\n    ds: xr.Dataset,\n    var: str = PRESSURE_VAR,\n    time_var: str = TIME_VAR,\n    height_var: str = HEIGHT_VAR,\n    label_format: str | None = r\"%d hPa\",\n    **kwargs,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds pressure contour lines to the plot.\"\"\"\n    values = ds[var].values / 100.0\n    time = ds[time_var].values\n    height = ds[height_var].values\n    return self.plot_contour(\n        values=values,\n        time=time,\n        height=height,\n        label_format=label_format,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_temperature","title":"ecplot_temperature","text":"<pre><code>ecplot_temperature(\n    ds,\n    var=TEMP_CELSIUS_VAR,\n    label_format=\"$%.0f^{\\\\circ}$C\",\n    label_levels=[-80, -40, 0],\n    levels=[-80, -70, -60, -50, -40, -30, -20, -10, 0, 10, 20],\n    linewidths=[0.75, 0.25, 0.5, 0.5, 0.75, 0.5, 0.75, 0.5, 1.0, 0.5, 0.75],\n    linestyles=[\n        \"dashed\",\n        \"dashed\",\n        \"dashed\",\n        \"dashed\",\n        \"dashed\",\n        \"dashed\",\n        \"dashed\",\n        \"dashed\",\n        \"solid\",\n        \"solid\",\n        \"solid\",\n    ],\n    colors=\"black\",\n    **kwargs\n)\n</code></pre> <p>Adds temperature contour lines to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_temperature(\n    self,\n    ds: xr.Dataset,\n    var: str = TEMP_CELSIUS_VAR,\n    label_format: str | None = \"$%.0f^{\\circ}$C\",\n    label_levels: list | NDArray | None = [-80, -40, 0],\n    levels=[\n        -80,\n        -70,\n        -60,\n        -50,\n        -40,\n        -30,\n        -20,\n        -10,\n        0,\n        10,\n        20,\n    ],\n    linewidths=[\n        0.75,  # -80\n        0.25,  # -70\n        0.50,  # -60\n        0.50,  # -50\n        0.75,  # -40\n        0.50,  # -30\n        0.75,  # -20\n        0.50,  # -10\n        1.00,  # 0\n        0.50,  # 10\n        0.75,  # 20\n    ],\n    linestyles=[\n        \"dashed\",  # -80\n        \"dashed\",  # -70\n        \"dashed\",  # -60\n        \"dashed\",  # -50\n        \"dashed\",  # -40\n        \"dashed\",  # -30\n        \"dashed\",  # -20\n        \"dashed\",  # -10\n        \"solid\",  # 0\n        \"solid\",  # 10\n        \"solid\",  # 20\n    ],\n    colors=\"black\",\n    **kwargs,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds temperature contour lines to the plot.\"\"\"\n    return self.ecplot_contour(\n        ds=ds,\n        var=var,\n        label_format=label_format,\n        levels=levels,\n        label_levels=label_levels,\n        linewidths=linewidths,\n        linestyles=linestyles,\n        colors=colors,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.ecplot_tropopause","title":"ecplot_tropopause","text":"<pre><code>ecplot_tropopause(\n    ds,\n    var=TROPOPAUSE_VAR,\n    time_var=TIME_VAR,\n    color=\"ec:tropopause\",\n    linewidth=2,\n    linestyle=\"solid\",\n    legend_label=None,\n)\n</code></pre> <p>Adds tropopause line to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def ecplot_tropopause(\n    self,\n    ds: xr.Dataset,\n    var: str = TROPOPAUSE_VAR,\n    time_var: str = TIME_VAR,\n    color: Color | str | None = \"ec:tropopause\",\n    linewidth: float = 2,\n    linestyle: str = \"solid\",\n    legend_label: str | None = None,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds tropopause line to the plot.\"\"\"\n    height = ds[var].values\n    time = ds[time_var].values\n    self.plot_height(\n        height=height,\n        time=time,\n        linewidth=linewidth,\n        linestyle=linestyle,\n        color=color,\n        marker=\"none\",\n        markersize=0,\n        fill=False,\n        zorder=12,\n        legend_label=legend_label,\n    )\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.invert_xaxis","title":"invert_xaxis","text":"<pre><code>invert_xaxis()\n</code></pre> <p>Invert the x-axis.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def invert_xaxis(self) -&gt; \"CurtainFigure\":\n    \"\"\"Invert the x-axis.\"\"\"\n    self.ax.invert_xaxis()\n    if self.ax_top:\n        self.ax_top.invert_xaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.invert_yaxis","title":"invert_yaxis","text":"<pre><code>invert_yaxis()\n</code></pre> <p>Invert the y-axis.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def invert_yaxis(self) -&gt; \"CurtainFigure\":\n    \"\"\"Invert the y-axis.\"\"\"\n    self.ax.invert_yaxis()\n    if self.ax_right:\n        self.ax_right.invert_yaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.plot_contour","title":"plot_contour","text":"<pre><code>plot_contour(\n    values,\n    time,\n    height,\n    label_levels=None,\n    label_format=None,\n    levels=None,\n    linewidths=1.5,\n    linestyles=\"solid\",\n    colors=\"black\",\n    zorder=2,\n)\n</code></pre> <p>Adds contour lines to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def plot_contour(\n    self,\n    values: NDArray,\n    time: NDArray,\n    height: NDArray,\n    label_levels: list | NDArray | None = None,\n    label_format: str | None = None,\n    levels: list | NDArray | None = None,\n    linewidths: int | float | list | NDArray | None = 1.5,\n    linestyles: str | list | NDArray | None = \"solid\",\n    colors: Color | str | list | NDArray | None = \"black\",\n    zorder: int | float | None = 2,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds contour lines to the plot.\"\"\"\n    values = np.asarray(values)\n    time = np.asarray(time)\n    height = np.asarray(height)\n\n    if len(height.shape) == 2:\n        height = height[0]\n\n    if isinstance(colors, str):\n        colors = Color.from_optional(colors)\n    elif isinstance(colors, (Iterable, np.ndarray)):\n        colors = [Color.from_optional(c) for c in colors]\n    else:\n        colors = Color.from_optional(colors)\n\n    x = time\n    y = height\n    z = values.T\n\n    if len(y.shape) == 2:\n        y = y[len(y) // 2]\n\n    if isinstance(colors, list):\n        shade_color = Color.from_optional(colors[0])\n    else:\n        shade_color = Color.from_optional(colors)\n\n    if isinstance(shade_color, Color):\n        shade_color = shade_color.get_best_bw_contrast_color()\n\n    linewidths2: int | float | np.ndarray\n    if not isinstance(linewidths, (int, float, np.number, np.ndarray)):\n        linewidths2 = np.array(linewidths) * 2.5\n    else:\n        linewidths2 = linewidths * 2.5\n\n    cn2 = self.ax.contour(\n        x,\n        y,\n        z,\n        levels=levels,\n        linewidths=linewidths2,\n        colors=shade_color,\n        alpha=0.5,\n        linestyles=\"solid\",\n        zorder=zorder,\n    )\n\n    cn = self.ax.contour(\n        x,\n        y,\n        z,\n        levels=levels,\n        linewidths=linewidths,\n        colors=colors,\n        linestyles=linestyles,\n        zorder=zorder,\n    )\n\n    labels: Iterable[float]\n    if label_levels:\n        labels = [l for l in label_levels if l in cn.levels]\n    else:\n        labels = cn.levels\n\n    cl = self.ax.clabel(\n        cn,\n        labels,  # type: ignore\n        inline=True,\n        fmt=label_format,\n        fontsize=\"small\",\n        zorder=zorder,\n    )\n\n    for t in cn.labelTexts:\n        add_shade_to_text(t, alpha=0.5)\n        t.set_rotation(0)\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.plot_hatch","title":"plot_hatch","text":"<pre><code>plot_hatch(\n    values,\n    time,\n    height,\n    value_range,\n    hatch=\"/////\",\n    linewidth=1,\n    linewidth_border=0,\n    color=\"black\",\n    color_border=None,\n    zorder=2,\n    legend_label=None,\n)\n</code></pre> <p>Adds hatched/filled areas to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def plot_hatch(\n    self,\n    values: NDArray,\n    time: NDArray,\n    height: NDArray,\n    value_range: tuple[float, float],\n    hatch: str = \"/////\",\n    linewidth: float = 1,\n    linewidth_border: float = 0,\n    color: ColorLike | None = \"black\",\n    color_border: ColorLike | None = None,\n    zorder: int | float | None = 2,\n    legend_label: str | None = None,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds hatched/filled areas to the plot.\"\"\"\n    values = np.asarray(values)\n    time = np.asarray(time)\n    height = np.asarray(height)\n\n    if len(height.shape) == 2:\n        height = height[0]\n\n    color = Color.from_optional(color)\n    color_border = Color.from_optional(color_border)\n\n    cnf = self.ax.contourf(\n        time,\n        height,\n        values.T,\n        levels=[value_range[0], value_range[1]],\n        colors=[\"none\"],\n        hatches=[hatch],\n        zorder=zorder,\n    )\n    cnf.set_edgecolors(color)  # type: ignore\n    cnf.set_hatch_linewidth(linewidth)\n\n    color = Color(cnf.get_edgecolors()[0], is_normalized=True)  # type: ignore\n    if color_border is None:\n        color_border = color.hex\n    cnf.set_color(color_border)  # type: ignore\n    cnf.set_linewidth(linewidth_border)\n\n    if isinstance(legend_label, str):\n        from matplotlib.patches import Patch\n\n        _facecolor = \"none\"\n        if color.is_close_to_white():\n            _facecolor = color.blend(0.7, \"black\").hex\n\n        hatch_patch = Patch(\n            linewidth=linewidth_border,\n            facecolor=_facecolor,\n            edgecolor=color.hex,\n            hatch=hatch,\n            label=legend_label,\n        )\n\n        self._legend_handles.append(hatch_patch)\n        self._legend_labels.append(legend_label)\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.plot_height","title":"plot_height","text":"<pre><code>plot_height(\n    height,\n    time,\n    linewidth=1.5,\n    linestyle=\"solid\",\n    color=None,\n    alpha=1.0,\n    zorder=2,\n    marker=None,\n    markersize=None,\n    fill=False,\n    legend_label=None,\n)\n</code></pre> <p>Adds height line to the plot.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def plot_height(\n    self,\n    height: NDArray,\n    time: NDArray,\n    linewidth: int | float | None = 1.5,\n    linestyle: str | None = \"solid\",\n    color: Color | str | None = None,\n    alpha: float | None = 1.0,\n    zorder: int | float | None = 2,\n    marker: str | None = None,\n    markersize: int | float | None = None,\n    fill: bool = False,\n    legend_label: str | None = None,\n) -&gt; \"CurtainFigure\":\n    \"\"\"Adds height line to the plot.\"\"\"\n    color = Color.from_optional(color)\n\n    height = np.asarray(height)\n    time = np.asarray(time)\n\n    hnew, tnew = _convert_height_line_to_time_bin_step_function(height, time)\n\n    fb: list = []\n    if fill:\n        _fb1 = self.ax.fill_between(\n            tnew,\n            hnew,\n            y2=-5e3,\n            color=color,\n            alpha=alpha,\n            zorder=zorder,\n        )\n        from matplotlib.patches import Patch\n\n        # Proxy for the legend\n        _fb2 = Patch(facecolor=color, alpha=alpha, linewidth=0.0)\n        fb = [_fb1, _fb2]\n\n    hl = self.ax.plot(\n        tnew,\n        hnew,\n        linestyle=linestyle,\n        linewidth=linewidth,\n        marker=marker,\n        markersize=markersize,\n        color=color,\n        alpha=alpha,\n        zorder=zorder,\n    )\n\n    if isinstance(legend_label, str):\n        self._legend_handles.append(tuple(hl + fb))\n        self._legend_labels.append(legend_label)\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.save","title":"save","text":"<pre><code>save(\n    filename=\"\",\n    filepath=None,\n    ds=None,\n    ds_filepath=None,\n    dpi=\"figure\",\n    orbit_and_frame=None,\n    utc_timestamp=None,\n    use_utc_creation_timestamp=False,\n    site_name=None,\n    hmax=None,\n    radius=None,\n    extra=None,\n    transparent_outside=False,\n    verbose=True,\n    print_prefix=\"\",\n    create_dirs=False,\n    transparent_background=False,\n    resolution=None,\n    **kwargs\n)\n</code></pre> <p>Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure | HasFigure</code> <p>A figure object (<code>matplotlib.figure.Figure</code>) or objects exposing a <code>.fig</code> attribute containing a figure (e.g., <code>CurtainFigure</code>).</p> required <code>filename</code> <code>str</code> <p>The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.</p> <code>''</code> <code>filepath</code> <code>str | None</code> <p>The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.</p> <code>None</code> <code>ds</code> <code>Dataset | None</code> <p>A EarthCARE dataset from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>ds_filepath</code> <code>str | None</code> <p>A path to a EarthCARE product from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>pad</code> <code>float</code> <p>Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.</p> required <code>dpi</code> <code>float | figure</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.</p> <code>'figure'</code> <code>orbit_and_frame</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>utc_timestamp</code> <code>TimestampLike | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>use_utc_creation_timestamp</code> <code>bool</code> <p>Whether the time of image creation should be included in the file name. Defaults to False.</p> <code>False</code> <code>site_name</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>hmax</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>radius</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>extra</code> <code>str | None</code> <p>A custom string to be included in the file name. Defaults to None.</p> <code>None</code> <code>transparent_outside</code> <code>bool</code> <p>Whether the area outside figures should be transparent. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether the progress of image creation should be printed to the console. Defaults to True.</p> <code>True</code> <code>print_prefix</code> <code>str</code> <p>A prefix string to all console messages. Defaults to \"\".</p> <code>''</code> <code>create_dirs</code> <code>bool</code> <p>Whether images should be saved in a folder structure based on provided metadata. Defaults to False.</p> <code>False</code> <code>transparent_background</code> <code>bool</code> <p>Whether the background inside and outside of figures should be transparent. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments passed to wrapped function call of <code>matplotlib.pyplot.savefig</code>.</p> <code>{}</code> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def save(\n    self,\n    filename: str = \"\",\n    filepath: str | None = None,\n    ds: xr.Dataset | None = None,\n    ds_filepath: str | None = None,\n    dpi: float | Literal[\"figure\"] = \"figure\",\n    orbit_and_frame: str | None = None,\n    utc_timestamp: TimestampLike | None = None,\n    use_utc_creation_timestamp: bool = False,\n    site_name: str | None = None,\n    hmax: int | float | None = None,\n    radius: int | float | None = None,\n    extra: str | None = None,\n    transparent_outside: bool = False,\n    verbose: bool = True,\n    print_prefix: str = \"\",\n    create_dirs: bool = False,\n    transparent_background: bool = False,\n    resolution: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n    Args:\n        figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n        filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n        filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n        ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n        ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n        pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n        dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n        orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n        site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n        transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n        verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n        print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n        create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n        transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n        **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n    \"\"\"\n    save_plot(\n        fig=self.fig,\n        filename=filename,\n        filepath=filepath,\n        ds=ds,\n        ds_filepath=ds_filepath,\n        dpi=dpi,\n        orbit_and_frame=orbit_and_frame,\n        utc_timestamp=utc_timestamp,\n        use_utc_creation_timestamp=use_utc_creation_timestamp,\n        site_name=site_name,\n        hmax=hmax,\n        radius=radius,\n        extra=extra,\n        transparent_outside=transparent_outside,\n        verbose=verbose,\n        print_prefix=print_prefix,\n        create_dirs=create_dirs,\n        transparent_background=transparent_background,\n        resolution=resolution,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.CurtainFigure.to_texture","title":"to_texture","text":"<pre><code>to_texture()\n</code></pre> <p>Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.</p> Source code in <code>earthcarekit/plot/figure/curtain.py</code> <pre><code>def to_texture(self) -&gt; \"CurtainFigure\":\n    \"\"\"Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.\"\"\"\n    # Remove anchored text and other artist text objects\n    for artist in reversed(self.ax.artists):\n        if isinstance(artist, (Text, AnchoredOffsetbox)):\n            artist.remove()\n\n    # Completely remove axis ticks and labels\n    self.ax.axis(\"off\")\n\n    if self.ax_top:\n        self.ax_top.axis(\"off\")\n\n    if self.ax_right:\n        self.ax_right.axis(\"off\")\n\n    # Remove white frame around figure\n    self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n    # Remove colorbar\n    if self.colorbar:\n        self.colorbar.remove()\n        self.colorbar = None\n\n    # Remove legend\n    if self.legend:\n        self.legend.remove()\n        self.legend = None\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.FileAgency","title":"FileAgency","text":"<p>               Bases: <code>FileInfoEnum</code></p> Source code in <code>earthcarekit/utils/read/product/file_info/agency.py</code> <pre><code>class FileAgency(FileInfoEnum):\n    ESA = \"E\"\n    JAXA = \"J\"\n\n    @classmethod\n    def from_input(cls, input: str | xr.Dataset) -&gt; \"FileAgency\":\n        \"\"\"Infers the EarthCARE product agency (i.e. ESA or JAXA) from a given file or dataset.\"\"\"\n        if isinstance(input, str):\n            try:\n                return cls[input.upper()]\n            except AttributeError:\n                pass\n            except KeyError:\n                pass\n            try:\n                return cls(input.upper())\n            except ValueError:\n                pass\n\n        return get_file_agency(input)\n</code></pre>"},{"location":"api_ref/#earthcarekit.FileAgency.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(input)\n</code></pre> <p>Infers the EarthCARE product agency (i.e. ESA or JAXA) from a given file or dataset.</p> Source code in <code>earthcarekit/utils/read/product/file_info/agency.py</code> <pre><code>@classmethod\ndef from_input(cls, input: str | xr.Dataset) -&gt; \"FileAgency\":\n    \"\"\"Infers the EarthCARE product agency (i.e. ESA or JAXA) from a given file or dataset.\"\"\"\n    if isinstance(input, str):\n        try:\n            return cls[input.upper()]\n        except AttributeError:\n            pass\n        except KeyError:\n            pass\n        try:\n            return cls(input.upper())\n        except ValueError:\n            pass\n\n    return get_file_agency(input)\n</code></pre>"},{"location":"api_ref/#earthcarekit.FileLatency","title":"FileLatency","text":"<p>               Bases: <code>FileInfoEnum</code></p> Source code in <code>earthcarekit/utils/read/product/file_info/latency.py</code> <pre><code>class FileLatency(FileInfoEnum):\n    NEAR_REAL_TIME = \"N\"\n    OFFLINE = \"O\"\n    NOT_APPLICABLE = \"X\"\n\n    @classmethod\n    def from_input(cls, input: str | xr.Dataset) -&gt; \"FileLatency\":\n        \"\"\"Infers the EarthCARE product latency indicator (i.e. N for Near-real time, O for Offline, X for not applicable) from a given name, file or dataset.\"\"\"\n        if isinstance(input, str):\n            try:\n                return cls[input.upper()]\n            except AttributeError:\n                pass\n            except KeyError:\n                pass\n            try:\n                return cls(input.upper())\n            except ValueError:\n                pass\n\n        return get_file_latency(input)\n</code></pre>"},{"location":"api_ref/#earthcarekit.FileLatency.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(input)\n</code></pre> <p>Infers the EarthCARE product latency indicator (i.e. N for Near-real time, O for Offline, X for not applicable) from a given name, file or dataset.</p> Source code in <code>earthcarekit/utils/read/product/file_info/latency.py</code> <pre><code>@classmethod\ndef from_input(cls, input: str | xr.Dataset) -&gt; \"FileLatency\":\n    \"\"\"Infers the EarthCARE product latency indicator (i.e. N for Near-real time, O for Offline, X for not applicable) from a given name, file or dataset.\"\"\"\n    if isinstance(input, str):\n        try:\n            return cls[input.upper()]\n        except AttributeError:\n            pass\n        except KeyError:\n            pass\n        try:\n            return cls(input.upper())\n        except ValueError:\n            pass\n\n    return get_file_latency(input)\n</code></pre>"},{"location":"api_ref/#earthcarekit.FileType","title":"FileType","text":"<p>               Bases: <code>FileInfoEnum</code></p> Source code in <code>earthcarekit/utils/read/product/file_info/type.py</code> <pre><code>class FileType(FileInfoEnum):\n    # Level 1\n    ATL_NOM_1B = \"ATL_NOM_1B\"\n    ATL_DCC_1B = \"ATL_DCC_1B\"\n    ATL_CSC_1B = \"ATL_CSC_1B\"\n    ATL_FSC_1B = \"ATL_FSC_1B\"\n    MSI_NOM_1B = \"MSI_NOM_1B\"\n    MSI_BBS_1B = \"MSI_BBS_1B\"\n    MSI_SD1_1B = \"MSI_SD1_1B\"\n    MSI_SD2_1B = \"MSI_SD2_1B\"\n    MSI_RGR_1C = \"MSI_RGR_1C\"\n    BBR_NOM_1B = \"BBR_NOM_1B\"\n    BBR_SNG_1B = \"BBR_SNG_1B\"\n    BBR_SOL_1B = \"BBR_SOL_1B\"\n    BBR_LIN_1B = \"BBR_LIN_1B\"\n    CPR_NOM_1B = \"CPR_NOM_1B\"  # JAXA product\n    # Level 2a\n    ATL_FM__2A = \"ATL_FM__2A\"\n    ATL_AER_2A = \"ATL_AER_2A\"\n    ATL_ICE_2A = \"ATL_ICE_2A\"\n    ATL_TC__2A = \"ATL_TC__2A\"\n    ATL_EBD_2A = \"ATL_EBD_2A\"\n    ATL_CTH_2A = \"ATL_CTH_2A\"\n    ATL_ALD_2A = \"ATL_ALD_2A\"\n    MSI_CM__2A = \"MSI_CM__2A\"\n    MSI_COP_2A = \"MSI_COP_2A\"\n    MSI_AOT_2A = \"MSI_AOT_2A\"\n    CPR_FMR_2A = \"CPR_FMR_2A\"\n    CPR_CD__2A = \"CPR_CD__2A\"\n    CPR_TC__2A = \"CPR_TC__2A\"\n    CPR_CLD_2A = \"CPR_CLD_2A\"\n    CPR_APC_2A = \"CPR_APC_2A\"\n    ATL_CLA_2A = \"ATL_CLA_2A\"  # JAXA product\n    MSI_CLP_2A = \"MSI_CLP_2A\"  # JAXA product\n    CPR_ECO_2A = \"CPR_ECO_2A\"  # JAXA product\n    CPR_CLP_2A = \"CPR_CLP_2A\"  # JAXA product\n    # Level 2b\n    AM__MO__2B = \"AM__MO__2B\"\n    AM__CTH_2B = \"AM__CTH_2B\"\n    AM__ACD_2B = \"AM__ACD_2B\"\n    AC__TC__2B = \"AC__TC__2B\"\n    BM__RAD_2B = \"BM__RAD_2B\"\n    BMA_FLX_2B = \"BMA_FLX_2B\"\n    ACM_CAP_2B = \"ACM_CAP_2B\"\n    ACM_COM_2B = \"ACM_COM_2B\"\n    ACM_RT__2B = \"ACM_RT__2B\"\n    ALL_DF__2B = \"ALL_DF__2B\"\n    ALL_3D__2B = \"ALL_3D__2B\"\n    AC__CLP_2B = \"AC__CLP_2B\"  # JAXA product\n    ACM_CLP_2B = \"ACM_CLP_2B\"  # JAXA product\n    ALL_RAD_2B = \"ALL_RAD_2B\"  # JAXA product\n    # Auxiliary data\n    AUX_MET_1D = \"AUX_MET_1D\"\n    AUX_JSG_1D = \"AUX_JSG_1D\"\n    # Orbit data\n    MPL_ORBSCT = \"MPL_ORBSCT\"\n    AUX_ORBPRE = \"AUX_ORBPRE\"\n    AUX_ORBRES = \"AUX_ORBRES\"\n\n    @classmethod\n    def from_input(cls, input: str | xr.Dataset) -&gt; \"FileType\":\n        \"\"\"Infers the EarthCARE product type from a given file or dataset.\"\"\"\n        if isinstance(input, str):\n            try:\n                return cls[format_file_type_string(input)]\n            except AttributeError:\n                pass\n            except KeyError:\n                pass\n            try:\n                return cls(format_file_type_string(input))\n            except ValueError:\n                pass\n            except KeyError:\n                pass\n\n        return get_file_type(input)\n\n    @classmethod\n    def list(cls):\n        return list(map(lambda c: c.value, cls))\n\n    def to_shorthand(self, with_dash: bool = False):\n        if with_dash:\n            return _short_hand_map[self.value]\n        else:\n            return _short_hand_map[self.value].replace(\"-\", \"\")\n</code></pre>"},{"location":"api_ref/#earthcarekit.FileType.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(input)\n</code></pre> <p>Infers the EarthCARE product type from a given file or dataset.</p> Source code in <code>earthcarekit/utils/read/product/file_info/type.py</code> <pre><code>@classmethod\ndef from_input(cls, input: str | xr.Dataset) -&gt; \"FileType\":\n    \"\"\"Infers the EarthCARE product type from a given file or dataset.\"\"\"\n    if isinstance(input, str):\n        try:\n            return cls[format_file_type_string(input)]\n        except AttributeError:\n            pass\n        except KeyError:\n            pass\n        try:\n            return cls(format_file_type_string(input))\n        except ValueError:\n            pass\n        except KeyError:\n            pass\n\n    return get_file_type(input)\n</code></pre>"},{"location":"api_ref/#earthcarekit.GroundSite","title":"GroundSite  <code>dataclass</code>","text":"<p>Class representing a geographic site (or ground station) with associated metadata.</p> <p>Attributes:</p> Name Type Description <code>latitude</code> <code>float</code> <p>Latitude of the site in decimal degrees.</p> <code>longitude</code> <code>float</code> <p>Longitude of the site in decimal degrees.</p> <code>name</code> <code>str</code> <p>Short name or identifier of the site.</p> <code>long_name</code> <code>str</code> <p>Full descriptive name of the site.</p> <code>aliases</code> <code>list[str]</code> <p>Alternative names or identifiers for the site.</p> <code>altitude</code> <code>float</code> <p>Altitude of the site in meters above sea level.</p> <code>cloudnet_name</code> <code>str | None</code> <p>Identifier string used in CloudNet file names, or None if not applicable.</p> Source code in <code>earthcarekit/utils/ground_sites.py</code> <pre><code>@dataclass(frozen=True)\nclass GroundSite:\n    \"\"\"Class representing a geographic site (or ground station) with associated metadata.\n\n    Attributes:\n        latitude (float): Latitude of the site in decimal degrees.\n        longitude (float): Longitude of the site in decimal degrees.\n        name (str): Short name or identifier of the site.\n        long_name (str): Full descriptive name of the site.\n        aliases (list[str]): Alternative names or identifiers for the site.\n        altitude (float): Altitude of the site in meters above sea level.\n        cloudnet_name (str | None): Identifier string used in CloudNet file names, or None if not applicable.\n    \"\"\"\n\n    latitude: float\n    \"\"\"Latitude of the site in decimal degrees.\"\"\"\n    longitude: float\n    \"\"\"Longitude of the site in decimal degrees.\"\"\"\n    name: str = \"\"\n    \"\"\"Short name or identifier of the site.\"\"\"\n    long_name: str = \"\"\n    \"\"\"Full descriptive name of the site.\"\"\"\n    aliases: list[str] = field(default_factory=list)\n    \"\"\"Alternative names or identifiers for the site.\"\"\"\n    altitude: float = 0.0\n    \"\"\"Altitude of the site in meters above sea level.\"\"\"\n    cloudnet_name: str | None = None\n    \"\"\"Identifier string used in CloudNet file names, or None if not applicable.\"\"\"\n\n    @property\n    def coordinates(self) -&gt; tuple[float, float]:\n        \"\"\"Geodetic coordinates of the ground site (lat,lon).\"\"\"\n        return (self.latitude, self.longitude)\n</code></pre>"},{"location":"api_ref/#earthcarekit.GroundSite.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases = field(default_factory=list)\n</code></pre> <p>Alternative names or identifiers for the site.</p>"},{"location":"api_ref/#earthcarekit.GroundSite.altitude","title":"altitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>altitude = 0.0\n</code></pre> <p>Altitude of the site in meters above sea level.</p>"},{"location":"api_ref/#earthcarekit.GroundSite.cloudnet_name","title":"cloudnet_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cloudnet_name = None\n</code></pre> <p>Identifier string used in CloudNet file names, or None if not applicable.</p>"},{"location":"api_ref/#earthcarekit.GroundSite.coordinates","title":"coordinates  <code>property</code>","text":"<pre><code>coordinates\n</code></pre> <p>Geodetic coordinates of the ground site (lat,lon).</p>"},{"location":"api_ref/#earthcarekit.GroundSite.latitude","title":"latitude  <code>instance-attribute</code>","text":"<pre><code>latitude\n</code></pre> <p>Latitude of the site in decimal degrees.</p>"},{"location":"api_ref/#earthcarekit.GroundSite.long_name","title":"long_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>long_name = ''\n</code></pre> <p>Full descriptive name of the site.</p>"},{"location":"api_ref/#earthcarekit.GroundSite.longitude","title":"longitude  <code>instance-attribute</code>","text":"<pre><code>longitude\n</code></pre> <p>Longitude of the site in decimal degrees.</p>"},{"location":"api_ref/#earthcarekit.GroundSite.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = ''\n</code></pre> <p>Short name or identifier of the site.</p>"},{"location":"api_ref/#earthcarekit.LineFigure","title":"LineFigure","text":"<p>TODO: documentation</p> Source code in <code>earthcarekit/plot/figure/line.py</code> <pre><code>class LineFigure:\n    \"\"\"TODO: documentation\"\"\"\n\n    def __init__(\n        self,\n        ax: Axes | None = None,\n        figsize: tuple[float, float] = (FIGURE_WIDTH_LINE, FIGURE_HEIGHT_LINE),\n        dpi: int | None = None,\n        title: str | None = None,\n        ax_style_top: AlongTrackAxisStyle | str = \"geo\",\n        ax_style_bottom: AlongTrackAxisStyle | str = \"time\",\n        num_ticks: int = 10,\n        show_value_left: bool = True,\n        show_value_right: bool = False,\n        mode: str | Literal[\"line\", \"scatter\", \"area\"] = \"line\",\n        show_grid: bool = True,\n        grid_color: str | None = Color(\"lightgray\"),\n        grid_which: Literal[\"major\", \"minor\", \"both\"] = \"major\",\n        grid_axis: Literal[\"both\", \"x\", \"y\"] = \"both\",\n        grid_linestyle: str = \"dashed\",\n        grid_linewidth: float = 1,\n        fig_height_scale: float = 1.0,\n        fig_width_scale: float = 1.0,\n    ):\n        figsize = (figsize[0] * fig_width_scale, figsize[1] * fig_height_scale)\n        self.fig: Figure\n        if isinstance(ax, Axes):\n            tmp = ax.get_figure()\n            if not isinstance(tmp, (Figure, SubFigure)):\n                raise ValueError(f\"Invalid Figure\")\n            self.fig = tmp  # type: ignore\n            self.ax = ax\n        else:\n            self.fig = plt.figure(figsize=figsize, dpi=dpi)\n            self.ax = self.fig.add_subplot()  # add_axes((0.0, 0.0, 1.0, 1.0))\n        self.title = title\n        if self.title:\n            self.fig.suptitle(self.title, y=1.4)\n\n        self.ax_top: Axes\n        self.ax_right: Axes\n        self.selection_time_range: tuple[pd.Timestamp, pd.Timestamp] | None = None\n        self.ax_style_top: AlongTrackAxisStyle = AlongTrackAxisStyle.from_input(\n            ax_style_top\n        )\n        self.ax_style_bottom: AlongTrackAxisStyle = AlongTrackAxisStyle.from_input(\n            ax_style_bottom\n        )\n\n        self.info_text: AnchoredText | None = None\n        self.info_text_loc: str = \"upper right\"\n        self.num_ticks = num_ticks\n        self.show_value_left: bool = show_value_left\n        self.show_value_right: bool = show_value_right\n        self.mode: str | Literal[\"line\", \"scatter\", \"area\"] = mode\n\n        self.show_grid = show_grid\n        self.grid_color = Color.from_optional(grid_color)\n        self.grid_which = grid_which\n        self.grid_axis = grid_axis\n        self.grid_linestyle = grid_linestyle\n        self.grid_linewidth = grid_linewidth\n\n        self.ax_right = self.ax.twinx()\n        self.ax_right.set_ylim(self.ax.get_ylim())\n        self.ax_right.set_yticks([])\n\n        self.ax_top = self.ax.twiny()\n        self.ax_top.set_xlim(self.ax.get_xlim())\n\n        self.tmin: np.datetime64 | None = None\n        self.tmax: np.datetime64 | None = None\n\n    def _set_info_text_loc(self, info_text_loc: str | None) -&gt; None:\n        if isinstance(info_text_loc, str):\n            self.info_text_loc = info_text_loc\n\n    def _set_axes(\n        self,\n        tmin: np.datetime64,\n        tmax: np.datetime64,\n        vmin: float,\n        vmax: float,\n        time: NDArray,\n        tmin_original: np.datetime64 | None = None,\n        tmax_original: np.datetime64 | None = None,\n        longitude: NDArray | None = None,\n        latitude: NDArray | None = None,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n    ) -&gt; \"LineFigure\":\n        if ax_style_top is not None:\n            self.ax_style_top = AlongTrackAxisStyle.from_input(self.ax_style_top)\n        if ax_style_bottom is not None:\n            self.ax_style_bottom = AlongTrackAxisStyle.from_input(self.ax_style_bottom)\n        if not isinstance(tmin_original, np.datetime64):\n            tmin_original = tmin\n        if not isinstance(tmax_original, np.datetime64):\n            tmax_original = tmax\n\n        self.ax.set_xlim((tmin, tmax))  # type: ignore\n        self.ax.set_ylim((vmin, vmax))\n\n        if self.show_grid:\n            self.ax.grid(\n                visible=self.show_grid,\n                which=self.grid_which,\n                axis=self.grid_axis,\n                color=self.grid_color,\n                linestyle=self.grid_linestyle,\n                linewidth=self.grid_linewidth,\n            )\n\n        self.ax_right.set_ylim(self.ax.get_ylim())\n        self.ax_top.set_xlim(self.ax.get_xlim())\n\n        format_along_track_axis(\n            self.ax,\n            self.ax_style_bottom,\n            time,\n            tmin,\n            tmax,\n            tmin_original,\n            tmax_original,\n            longitude,\n            latitude,\n            num_ticks=self.num_ticks,\n        )\n        format_along_track_axis(\n            self.ax_top,\n            self.ax_style_top,\n            time,\n            tmin,\n            tmax,\n            tmin_original,\n            tmax_original,\n            longitude,\n            latitude,\n            num_ticks=self.num_ticks,\n        )\n        return self\n\n    def plot(\n        self,\n        *,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        # Common args for wrappers\n        mode: str | Literal[\"line\", \"scatter\", \"area\"] | None = None,\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        time_range: TimeRangeLike | None = None,\n        label: str | None = None,\n        units: str | None = None,\n        color: str | None = Color(\"ec:blue\"),\n        alpha: float = 1.0,\n        linestyle: str | None = \"solid\",\n        linewidth: float | int | None = 2.0,\n        marker: str | None = \"s\",\n        markersize: float | int | None = 2.0,\n        selection_time_range: TimeRangeLike | None = None,\n        selection_color: str | None = Color(\"ec:earthcare\"),\n        selection_linestyle: str | None = \"dashed\",\n        selection_linewidth: float | int | None = 2.5,\n        selection_highlight: bool = False,\n        selection_highlight_inverted: bool = True,\n        selection_highlight_color: str | None = Color(\"white\"),\n        selection_highlight_alpha: float = 0.5,\n        selection_max_time_margin: (\n            TimedeltaLike | Sequence[TimedeltaLike] | None\n        ) = None,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n        mark_profiles_at: Sequence[TimestampLike] | None = None,\n        classes: Sequence[int] | dict[int, str] | None = None,\n        classes_kwargs: dict[str, Any] = {},\n        is_prob: bool = False,\n        prob_labels: list[str] | None = None,\n        prob_colors: list[ColorLike] | None = None,\n        zorder: int | float | None = None,\n        label_length: int = 20,\n        **kwargs,\n    ) -&gt; \"LineFigure\":\n        _zorder: float = 2.0\n        if isinstance(zorder, (int, float)):\n            _zorder = float(zorder)\n        # Parse colors\n        color = Color.from_optional(color)\n        selection_color = Color.from_optional(selection_color)\n        selection_highlight_color = Color.from_optional(selection_highlight_color)\n\n        if isinstance(mode, str):\n            if mode in [\"line\", \"scatter\", \"area\"]:\n                self.mode = mode\n            else:\n                raise ValueError(\n                    f'invalid `mode` \"{mode}\", expected either \"line\", \"scatter\" or \"area\"'\n                )\n\n        if isinstance(value_range, Iterable):\n            if len(value_range) != 2:\n                raise ValueError(\n                    f\"invalid `value_range`: {value_range}, expecting (vmin, vmax)\"\n                )\n        else:\n            value_range = (None, None)\n\n        if isinstance(norm, Normalize):\n            if log_scale == True and not isinstance(norm, LogNorm):\n                norm = LogNorm(norm.vmin, norm.vmax)\n            elif log_scale == False and isinstance(norm, LogNorm):\n                norm = Normalize(norm.vmin, norm.vmax)\n            if value_range[0] is not None:\n                norm.vmin = value_range[0]  # type: ignore # FIXME\n            if value_range[1] is not None:\n                norm.vmax = value_range[1]  # type: ignore # FIXME\n        else:\n            if log_scale == True:\n                norm = LogNorm(value_range[0], value_range[1])  # type: ignore # FIXME\n            else:\n                norm = Normalize(value_range[0], value_range[1])  # type: ignore # FIXME\n        value_range = (norm.vmin, norm.vmax)\n\n        values = np.asarray(values)\n        time = np.asarray(time)\n        if latitude is not None:\n            latitude = np.asarray(latitude)\n        if longitude is not None:\n            longitude = np.asarray(longitude)\n\n        # Validate inputs\n        if is_prob:\n            if len(values.shape) != 2:\n                raise ValueError(\n                    f\"Since {is_prob=} values must be 2D, but has shape={values.shape}\"\n                )\n        elif len(values.shape) != 1:\n            raise ValueError(\n                f\"Since {is_prob=} values must be 1D, but has shape={values.shape}\"\n            )\n\n        tmin_original = np.datetime64(to_timestamp(time[0]))\n        tmax_original = np.datetime64(to_timestamp(time[-1]))\n        vmin_original = values[0]\n        vmax_original = values[-1]\n\n        if selection_time_range is not None:\n            self.selection_time_range = validate_time_range(selection_time_range)\n            _selection_max_time_margin: tuple[pd.Timedelta, pd.Timedelta] | None = None\n            if isinstance(selection_max_time_margin, (Sequence, np.ndarray)):\n                _selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin[0]),\n                    to_timedelta(selection_max_time_margin[1]),\n                )\n            elif selection_max_time_margin is not None:\n                _selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin),\n                    to_timedelta(selection_max_time_margin),\n                )\n\n            if _selection_max_time_margin is not None:\n                time_range = [\n                    np.max(\n                        [\n                            time[0],\n                            (\n                                self.selection_time_range[0]\n                                - _selection_max_time_margin[0]\n                            ).to_datetime64(),\n                        ]\n                    ),\n                    np.min(\n                        [\n                            time[-1],\n                            (\n                                self.selection_time_range[1]\n                                + _selection_max_time_margin[1]\n                            ).to_datetime64(),\n                        ]\n                    ),\n                ]\n\n        if time_range is not None:\n            if isinstance(time_range, Iterable) and len(time_range) == 2:\n                for i in [0, -1]:\n                    time_range = list(time_range)\n                    if time_range[i] is None:\n                        time_range[i] = time[i]\n                    time_range = tuple(time_range)  # type: ignore\n            time_range = (\n                np.datetime64(to_timestamp(time_range[0])),\n                np.datetime64(to_timestamp(time_range[-1])),\n            )\n            self.tmin = time_range[0]\n            self.tmax = time_range[1]\n        else:\n            time_range = (time[0], time[-1])\n        time_range = (\n            np.datetime64(to_timestamp(time_range[0])),\n            np.datetime64(to_timestamp(time_range[-1])),\n        )\n\n        _value_range: tuple[float, float] = select_value_range(\n            data=values,\n            value_range=value_range,\n            pad_frac=0.0,\n            use_min_max=True,\n        )\n\n        tmin = self.tmin or np.datetime64(time_range[0])\n        tmax = self.tmax or np.datetime64(time_range[1])\n\n        vmin: float = _value_range[0]\n        vmax: float = _value_range[1]\n\n        x: NDArray = time\n        y: NDArray = values\n\n        if is_prob:\n            plot_stacked_propabilities(\n                ax=self.ax,\n                probabilities=values,\n                time=time,\n                labels=prob_labels,\n                colors=prob_colors,\n                zorder=_zorder,\n                ax_label=label,\n            )\n            vmin = 0\n            vmax = 1\n        elif classes is not None:\n            _yaxis_position = classes_kwargs.get(\"yaxis_position\", \"left\")\n            _is_left = _yaxis_position == \"left\"\n            _label = format_var_label(label, units, label_len=label_length)\n\n            plot_1d_integer_flag(\n                ax=self.ax if _is_left else self.ax_right,\n                ax2=self.ax_right if _is_left else self.ax,\n                data=y,\n                x=x,\n                classes=classes,\n                ax_label=_label,\n                zorder=_zorder,\n                **classes_kwargs,\n            )\n        else:\n            line: list[Line2D] | PathCollection | PolyCollection\n            if \"line\" in self.mode:\n                line = self.ax.plot(\n                    x,\n                    y,\n                    marker=\"none\",\n                    linewidth=linewidth,\n                    linestyle=linestyle,\n                    color=color,\n                    alpha=alpha,\n                    zorder=_zorder,\n                )\n            elif \"scatter\" in self.mode:\n                line = self.ax.scatter(\n                    x,\n                    y,\n                    marker=marker,\n                    s=markersize,\n                    color=color,\n                    alpha=alpha,\n                    zorder=_zorder,\n                )\n            elif \"area\" in self.mode:\n                line = self.ax.fill_between(\n                    x,\n                    [0] * x.shape[0],\n                    y,\n                    color=color,\n                    alpha=alpha,\n                    zorder=zorder or 0.0,\n                )\n            else:\n                raise ValueError(f\"invalid `mode` {self.mode}\")\n\n            format_numeric_ticks(\n                ax=self.ax,\n                axis=\"y\",\n                label=format_var_label(label, units, label_len=label_length),\n                max_line_length=label_length,\n                show_label=self.show_value_left,\n                show_values=self.show_value_left,\n            )\n            format_numeric_ticks(\n                ax=self.ax_right,\n                axis=\"y\",\n                label=format_var_label(label, units, label_len=label_length),\n                max_line_length=label_length,\n                show_label=self.show_value_right,\n                show_values=self.show_value_right,\n            )\n\n        if selection_time_range is not None:\n            if selection_highlight:\n                if selection_highlight_inverted:\n                    self.ax.axvspan(\n                        tmin,  # type: ignore\n                        self.selection_time_range[0],  # type: ignore\n                        color=selection_highlight_color,\n                        alpha=selection_highlight_alpha,\n                        zorder=3,\n                    )\n                    self.ax.axvspan(\n                        self.selection_time_range[1],  # type: ignore\n                        tmax,  # type: ignore\n                        color=selection_highlight_color,\n                        alpha=selection_highlight_alpha,\n                        zorder=3,\n                    )\n                else:\n                    self.ax.axvspan(\n                        self.selection_time_range[0],  # type: ignore\n                        self.selection_time_range[1],  # type: ignore\n                        color=selection_highlight_color,\n                        alpha=selection_highlight_alpha,\n                        zorder=3,\n                    )\n\n            for t in self.selection_time_range:  # type: ignore\n                self.ax.axvline(\n                    x=t,  # type: ignore\n                    color=selection_color,\n                    linestyle=selection_linestyle,\n                    linewidth=selection_linewidth,\n                    zorder=3,\n                )\n\n        self._set_axes(\n            tmin=tmin,\n            tmax=tmax,\n            vmin=vmin,\n            vmax=vmax,\n            time=time,\n            tmin_original=tmin_original,\n            tmax_original=tmax_original,\n            latitude=latitude,\n            longitude=longitude,\n            ax_style_top=ax_style_top,\n            ax_style_bottom=ax_style_bottom,\n        )\n\n        if mark_profiles_at is not None:\n            for t in to_timestamps(mark_profiles_at):\n                self.ax.axvline(\n                    t,  # type: ignore\n                    color=selection_color,\n                    linestyle=\"solid\",\n                    linewidth=selection_linewidth,\n                    zorder=3,\n                )\n\n        return self\n\n    def ecplot(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        *,\n        time_var: str = TIME_VAR,\n        lat_var: str = TRACK_LAT_VAR,\n        lon_var: str = TRACK_LON_VAR,\n        along_track_dim: str = ALONG_TRACK_DIM,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        site: str | GroundSite | None = None,\n        radius_km: float = 100.0,\n        mark_closest_profile: bool = False,\n        show_info: bool = True,\n        info_text_loc: str | None = None,\n        # Common args for wrappers\n        mode: str | Literal[\"line\", \"scatter\", \"area\"] | None = None,\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        time_range: TimeRangeLike | None = None,\n        label: str | None = None,\n        units: str | None = None,\n        color: str | None = Color(\"ec:blue\"),\n        alpha: float = 1.0,\n        linestyle: str | None = \"solid\",\n        linewidth: float | int | None = 2.0,\n        marker: str | None = \"s\",\n        markersize: float | int | None = 2.0,\n        selection_time_range: TimeRangeLike | None = None,\n        selection_color: str | None = Color(\"ec:earthcare\"),\n        selection_linestyle: str | None = \"dashed\",\n        selection_linewidth: float | int | None = 2.5,\n        selection_highlight: bool = False,\n        selection_highlight_inverted: bool = True,\n        selection_highlight_color: str | None = Color(\"white\"),\n        selection_highlight_alpha: float = 0.5,\n        selection_max_time_margin: (\n            TimedeltaLike | Sequence[TimedeltaLike] | None\n        ) = None,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n        mark_profiles_at: Sequence[TimestampLike] | None = None,\n        classes: Sequence[int] | dict[int, str] | None = None,\n        classes_kwargs: dict[str, Any] = {},\n        is_prob: bool = False,\n        prob_labels: list[str] | None = None,\n        prob_colors: list[ColorLike] | None = None,\n        zorder: int | float | None = None,\n        label_length: int = 20,\n        **kwargs,\n    ) -&gt; \"LineFigure\":\n        # Collect all common args for wrapped plot function call\n        local_args = locals()\n        # Delete all args specific to this wrapper function\n        del local_args[\"self\"]\n        del local_args[\"ds\"]\n        del local_args[\"var\"]\n        del local_args[\"time_var\"]\n        del local_args[\"lat_var\"]\n        del local_args[\"lon_var\"]\n        del local_args[\"along_track_dim\"]\n        del local_args[\"site\"]\n        del local_args[\"radius_km\"]\n        del local_args[\"show_info\"]\n        del local_args[\"info_text_loc\"]\n        del local_args[\"mark_closest_profile\"]\n        # Delete kwargs to then merge it with the residual common args\n        del local_args[\"kwargs\"]\n        all_args = {**local_args, **kwargs}\n\n        if all_args[\"values\"] is None:\n            all_args[\"values\"] = ds[var].values\n        if all_args[\"time\"] is None:\n            all_args[\"time\"] = ds[time_var].values\n        if all_args[\"latitude\"] is None:\n            all_args[\"latitude\"] = ds[lat_var].values\n        if all_args[\"longitude\"] is None:\n            all_args[\"longitude\"] = ds[lon_var].values\n\n        # Set default values depending on variable name\n        if label is None:\n            all_args[\"label\"] = (\n                \"Values\" if not hasattr(ds[var], \"long_name\") else ds[var].long_name\n            )\n        if units is None:\n            all_args[\"units\"] = \"-\" if not hasattr(ds[var], \"units\") else ds[var].units\n        if classes is not None and len(classes) &gt; 0:\n            all_args[\"value_range\"] = (-0.5, len(classes) - 0.5)\n        elif value_range is None and log_scale is None and norm is None:\n            all_args[\"norm\"] = get_default_norm(var, file_type=ds)\n\n        # Handle overpass\n        _site: GroundSite | None = None\n        if isinstance(site, GroundSite):\n            _site = site\n        elif isinstance(site, str):\n            _site = get_ground_site(site)\n        else:\n            pass\n\n        if isinstance(_site, GroundSite):\n            info_overpass = get_overpass_info(\n                ds,\n                site_radius_km=radius_km,\n                site=_site,\n                time_var=time_var,\n                lat_var=lat_var,\n                lon_var=lon_var,\n                along_track_dim=along_track_dim,\n            )\n            overpass_time_range = info_overpass.time_range\n            all_args[\"selection_time_range\"] = overpass_time_range\n            if mark_closest_profile:\n                _mark_profiles_at = all_args[\"mark_profiles_at\"]\n                if isinstance(_mark_profiles_at, (Sequence, np.ndarray)):\n                    list(_mark_profiles_at).append(info_overpass.closest_time)\n                    all_args[\"mark_profiles_at\"] = _mark_profiles_at\n                else:\n                    all_args[\"mark_profiles_at\"] = [info_overpass.closest_time]\n\n        self.plot(**all_args)\n\n        self._set_info_text_loc(info_text_loc)\n        if show_info:\n            self.info_text = add_text_product_info(\n                self.ax, ds, append_to=self.info_text, loc=self.info_text_loc\n            )\n\n        return self\n\n    def to_texture(self) -&gt; \"LineFigure\":\n        # Remove anchored text and other artist text objects\n        for artist in reversed(self.ax.artists):\n            if isinstance(artist, (Text, AnchoredOffsetbox)):\n                artist.remove()\n\n        # Completely remove axis ticks and labels\n        self.ax.axis(\"off\")\n\n        if self.ax_top:\n            self.ax_top.axis(\"off\")\n\n        if self.ax_right:\n            self.ax_right.axis(\"off\")\n\n        # Remove white frame around figure\n        self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n        return self\n\n    def invert_xaxis(self) -&gt; \"LineFigure\":\n        \"\"\"Invert the x-axis.\"\"\"\n        self.ax.invert_xaxis()\n        if self.ax_top:\n            self.ax_top.invert_xaxis()\n        return self\n\n    def invert_yaxis(self) -&gt; \"LineFigure\":\n        \"\"\"Invert the y-axis.\"\"\"\n        self.ax.invert_yaxis()\n        if self.ax_right:\n            self.ax_right.invert_yaxis()\n        return self\n\n    def show(self) -&gt; None:\n        import IPython\n        import matplotlib.pyplot as plt\n        from IPython.display import display\n\n        if IPython.get_ipython() is not None:\n            display(self.fig)\n        else:\n            plt.show()\n\n    def save(\n        self,\n        filename: str = \"\",\n        filepath: str | None = None,\n        ds: xr.Dataset | None = None,\n        ds_filepath: str | None = None,\n        dpi: float | Literal[\"figure\"] = \"figure\",\n        orbit_and_frame: str | None = None,\n        utc_timestamp: TimestampLike | None = None,\n        use_utc_creation_timestamp: bool = False,\n        site_name: str | None = None,\n        hmax: int | float | None = None,\n        radius: int | float | None = None,\n        extra: str | None = None,\n        transparent_outside: bool = False,\n        verbose: bool = True,\n        print_prefix: str = \"\",\n        create_dirs: bool = False,\n        transparent_background: bool = False,\n        resolution: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n        Args:\n            figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n            filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n            filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n            ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n            ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n            pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n            dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n            orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n            site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n            transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n            verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n            print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n            create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n            transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n            **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n        \"\"\"\n        save_plot(\n            fig=self.fig,\n            filename=filename,\n            filepath=filepath,\n            ds=ds,\n            ds_filepath=ds_filepath,\n            dpi=dpi,\n            orbit_and_frame=orbit_and_frame,\n            utc_timestamp=utc_timestamp,\n            use_utc_creation_timestamp=use_utc_creation_timestamp,\n            site_name=site_name,\n            hmax=hmax,\n            radius=radius,\n            extra=extra,\n            transparent_outside=transparent_outside,\n            verbose=verbose,\n            print_prefix=print_prefix,\n            create_dirs=create_dirs,\n            transparent_background=transparent_background,\n            resolution=resolution,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_ref/#earthcarekit.LineFigure.invert_xaxis","title":"invert_xaxis","text":"<pre><code>invert_xaxis()\n</code></pre> <p>Invert the x-axis.</p> Source code in <code>earthcarekit/plot/figure/line.py</code> <pre><code>def invert_xaxis(self) -&gt; \"LineFigure\":\n    \"\"\"Invert the x-axis.\"\"\"\n    self.ax.invert_xaxis()\n    if self.ax_top:\n        self.ax_top.invert_xaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.LineFigure.invert_yaxis","title":"invert_yaxis","text":"<pre><code>invert_yaxis()\n</code></pre> <p>Invert the y-axis.</p> Source code in <code>earthcarekit/plot/figure/line.py</code> <pre><code>def invert_yaxis(self) -&gt; \"LineFigure\":\n    \"\"\"Invert the y-axis.\"\"\"\n    self.ax.invert_yaxis()\n    if self.ax_right:\n        self.ax_right.invert_yaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.LineFigure.save","title":"save","text":"<pre><code>save(\n    filename=\"\",\n    filepath=None,\n    ds=None,\n    ds_filepath=None,\n    dpi=\"figure\",\n    orbit_and_frame=None,\n    utc_timestamp=None,\n    use_utc_creation_timestamp=False,\n    site_name=None,\n    hmax=None,\n    radius=None,\n    extra=None,\n    transparent_outside=False,\n    verbose=True,\n    print_prefix=\"\",\n    create_dirs=False,\n    transparent_background=False,\n    resolution=None,\n    **kwargs\n)\n</code></pre> <p>Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure | HasFigure</code> <p>A figure object (<code>matplotlib.figure.Figure</code>) or objects exposing a <code>.fig</code> attribute containing a figure (e.g., <code>CurtainFigure</code>).</p> required <code>filename</code> <code>str</code> <p>The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.</p> <code>''</code> <code>filepath</code> <code>str | None</code> <p>The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.</p> <code>None</code> <code>ds</code> <code>Dataset | None</code> <p>A EarthCARE dataset from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>ds_filepath</code> <code>str | None</code> <p>A path to a EarthCARE product from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>pad</code> <code>float</code> <p>Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.</p> required <code>dpi</code> <code>float | figure</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.</p> <code>'figure'</code> <code>orbit_and_frame</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>utc_timestamp</code> <code>TimestampLike | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>use_utc_creation_timestamp</code> <code>bool</code> <p>Whether the time of image creation should be included in the file name. Defaults to False.</p> <code>False</code> <code>site_name</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>hmax</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>radius</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>extra</code> <code>str | None</code> <p>A custom string to be included in the file name. Defaults to None.</p> <code>None</code> <code>transparent_outside</code> <code>bool</code> <p>Whether the area outside figures should be transparent. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether the progress of image creation should be printed to the console. Defaults to True.</p> <code>True</code> <code>print_prefix</code> <code>str</code> <p>A prefix string to all console messages. Defaults to \"\".</p> <code>''</code> <code>create_dirs</code> <code>bool</code> <p>Whether images should be saved in a folder structure based on provided metadata. Defaults to False.</p> <code>False</code> <code>transparent_background</code> <code>bool</code> <p>Whether the background inside and outside of figures should be transparent. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments passed to wrapped function call of <code>matplotlib.pyplot.savefig</code>.</p> <code>{}</code> Source code in <code>earthcarekit/plot/figure/line.py</code> <pre><code>def save(\n    self,\n    filename: str = \"\",\n    filepath: str | None = None,\n    ds: xr.Dataset | None = None,\n    ds_filepath: str | None = None,\n    dpi: float | Literal[\"figure\"] = \"figure\",\n    orbit_and_frame: str | None = None,\n    utc_timestamp: TimestampLike | None = None,\n    use_utc_creation_timestamp: bool = False,\n    site_name: str | None = None,\n    hmax: int | float | None = None,\n    radius: int | float | None = None,\n    extra: str | None = None,\n    transparent_outside: bool = False,\n    verbose: bool = True,\n    print_prefix: str = \"\",\n    create_dirs: bool = False,\n    transparent_background: bool = False,\n    resolution: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n    Args:\n        figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n        filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n        filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n        ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n        ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n        pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n        dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n        orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n        site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n        transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n        verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n        print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n        create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n        transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n        **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n    \"\"\"\n    save_plot(\n        fig=self.fig,\n        filename=filename,\n        filepath=filepath,\n        ds=ds,\n        ds_filepath=ds_filepath,\n        dpi=dpi,\n        orbit_and_frame=orbit_and_frame,\n        utc_timestamp=utc_timestamp,\n        use_utc_creation_timestamp=use_utc_creation_timestamp,\n        site_name=site_name,\n        hmax=hmax,\n        radius=radius,\n        extra=extra,\n        transparent_outside=transparent_outside,\n        verbose=verbose,\n        print_prefix=print_prefix,\n        create_dirs=create_dirs,\n        transparent_background=transparent_background,\n        resolution=resolution,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.MapFigure","title":"MapFigure","text":"<p>Figure object for displaying EarthCARE satellite track and/or imager swaths on a global map.</p> <p>This class sets up a georeferenced map canvas using a range of cartographic projections and visual styles. It serves as the basis for plotting 2D swath data (e.g., from MSI) or simple satellite tracks, optionally with info labels, backgrounds, and other styling options.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes | None</code> <p>Existing matplotlib axes to plot on; if not provided, new axes will be created. Defaults to None.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size in inches. Defaults to (FIGURE_MAP_WIDTH, FIGURE_MAP_HEIGHT).</p> <code>(FIGURE_MAP_WIDTH, FIGURE_MAP_HEIGHT)</code> <code>dpi</code> <code>int | None</code> <p>Resolution of the figure in dots per inch. Defaults to None.</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Title to display on the map. Defaults to None.</p> <code>None</code> <code>style</code> <code>str</code> <p>Base map style to use; options include \"none\", \"stock_img\", \"gray\", \"osm\", \"satellite\", \"mtg\", \"msg\". Defaults to \"gray\".</p> <code>'gray'</code> <code>projection</code> <code>str | Projection</code> <p>Map projection to use; options include \"platecarree\", \"perspective\", \"orthographic\", or a custom <code>cartopy.crs.Projection</code>. Defaults to <code>ccrs.Orthographic()</code>.</p> <code>Orthographic()</code> <code>central_latitude</code> <code>float | None</code> <p>Latitude at the center of the projection. Defaults to None.</p> <code>None</code> <code>central_longitude</code> <code>float | None</code> <p>Longitude at the center of the projection. Defaults to None.</p> <code>None</code> <code>grid_color</code> <code>ColorLike | None</code> <p>Color of grid lines. Defaults to None.</p> <code>None</code> <code>border_color</code> <code>ColorLike | None</code> <p>Color of border box around the map. Defaults to None.</p> <code>None</code> <code>coastline_color</code> <code>ColorLike | None</code> <p>Color of coastlines. Defaults to None.</p> <code>None</code> <code>show_grid</code> <code>bool</code> <p>Whether to show latitude/longitude grid lines. Defaults to True.</p> <code>True</code> <code>show_top_labels</code> <code>bool</code> <p>Whether to show tick labels on the top axis. Defaults to True.</p> <code>True</code> <code>show_bottom_labels</code> <code>bool</code> <p>Whether to show tick labels on the bottom axis. Defaults to True.</p> <code>True</code> <code>show_right_labels</code> <code>bool</code> <p>Whether to show tick labels on the right axis. Defaults to True.</p> <code>True</code> <code>show_left_labels</code> <code>bool</code> <p>Whether to show tick labels on the left axis. Defaults to True.</p> <code>True</code> <code>show_text_time</code> <code>bool</code> <p>Whether to display a datetime info text above the plot. Defaults to True.</p> <code>True</code> <code>show_text_frame</code> <code>bool</code> <p>Whether to display a EarthCARE frame info text above the plot. Defaults to True.</p> <code>True</code> <code>show_text_overpass</code> <code>bool</code> <p>Whether to display ground site overpass info in the plot. Defaults to True.</p> <code>True</code> <code>show_night_shade</code> <code>bool</code> <p>Whether to overlay the nighttime shading based on <code>timestamp</code>. Defaults to True.</p> <code>True</code> <code>timestamp</code> <code>TimestampLike | None</code> <p>Time reference used for nightshade overlay. Defaults to None.</p> <code>None</code> <code>extent</code> <code>Iterable | None</code> <p>Map extent given as [lon_min, lon_max, lat_min, lat_max]; overrides auto zoom. Defaults to None.</p> <code>None</code> <code>lod</code> <code>int</code> <p>Level of detail for coastlines and grid elements; higher values reduce complexity. Defaults to 2.</p> <code>2</code> <code>coastlines_resolution</code> <code>str</code> <p>Resolution of coastlines to display; options are \"10m\", \"50m\", or \"110m\". Defaults to \"110m\".</p> <code>'110m'</code> <code>azimuth</code> <code>float</code> <p>Rotation of the <code>cartopy.crs.ObliqueMercator</code> projection, in degrees (if used). Defaults to 0.</p> <code>0</code> <code>pad</code> <code>float | list[float]</code> <p>Padding applied when selecting a map extent. Defaults to 0.05.</p> <code>0.05</code> <code>background_alpha</code> <code>float</code> <p>Transparency level of the background map style. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>earthcarekit/plot/figure/map.py</code> <pre><code>class MapFigure:\n    \"\"\"Figure object for displaying EarthCARE satellite track and/or imager swaths on a global map.\n\n    This class sets up a georeferenced map canvas using a range of cartographic projections and visual styles.\n    It serves as the basis for plotting 2D swath data (e.g., from MSI) or simple satellite tracks, optionally\n    with info labels, backgrounds, and other styling options.\n\n    Args:\n        ax (Axes | None, optional): Existing matplotlib axes to plot on; if not provided, new axes will be created. Defaults to None.\n        figsize (tuple[float, float], optional): Figure size in inches. Defaults to (FIGURE_MAP_WIDTH, FIGURE_MAP_HEIGHT).\n        dpi (int | None, optional): Resolution of the figure in dots per inch. Defaults to None.\n        title (str | None, optional): Title to display on the map. Defaults to None.\n        style (str, optional): Base map style to use; options include \"none\", \"stock_img\", \"gray\", \"osm\", \"satellite\", \"mtg\", \"msg\". Defaults to \"gray\".\n        projection (str | Projection, optional): Map projection to use; options include \"platecarree\", \"perspective\", \"orthographic\", or a custom `cartopy.crs.Projection`. Defaults to `ccrs.Orthographic()`.\n        central_latitude (float | None, optional): Latitude at the center of the projection. Defaults to None.\n        central_longitude (float | None, optional): Longitude at the center of the projection. Defaults to None.\n        grid_color (ColorLike | None, optional): Color of grid lines. Defaults to None.\n        border_color (ColorLike | None, optional): Color of border box around the map. Defaults to None.\n        coastline_color (ColorLike | None, optional): Color of coastlines. Defaults to None.\n        show_grid (bool, optional): Whether to show latitude/longitude grid lines. Defaults to True.\n        show_top_labels (bool, optional): Whether to show tick labels on the top axis. Defaults to True.\n        show_bottom_labels (bool, optional): Whether to show tick labels on the bottom axis. Defaults to True.\n        show_right_labels (bool, optional): Whether to show tick labels on the right axis. Defaults to True.\n        show_left_labels (bool, optional): Whether to show tick labels on the left axis. Defaults to True.\n        show_text_time (bool, optional): Whether to display a datetime info text above the plot. Defaults to True.\n        show_text_frame (bool, optional): Whether to display a EarthCARE frame info text above the plot. Defaults to True.\n        show_text_overpass (bool, optional): Whether to display ground site overpass info in the plot. Defaults to True.\n        show_night_shade (bool, optional): Whether to overlay the nighttime shading based on `timestamp`. Defaults to True.\n        timestamp (TimestampLike | None, optional): Time reference used for nightshade overlay. Defaults to None.\n        extent (Iterable | None, optional): Map extent given as [lon_min, lon_max, lat_min, lat_max]; overrides auto zoom. Defaults to None.\n        lod (int, optional): Level of detail for coastlines and grid elements; higher values reduce complexity. Defaults to 2.\n        coastlines_resolution (str, optional): Resolution of coastlines to display; options are \"10m\", \"50m\", or \"110m\". Defaults to \"110m\".\n        azimuth (float, optional): Rotation of the `cartopy.crs.ObliqueMercator` projection, in degrees (if used). Defaults to 0.\n        pad (float | list[float], optional): Padding applied when selecting a map extent. Defaults to 0.05.\n        background_alpha (float, optional): Transparency level of the background map style. Defaults to 1.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        ax: Axes | None = None,\n        figsize: tuple[float, float] = (FIGURE_MAP_WIDTH, FIGURE_MAP_HEIGHT),\n        dpi: int | None = None,\n        title: str | None = None,\n        style: (\n            str\n            | Literal[\n                \"none\",\n                \"stock_img\",\n                \"gray\",\n                \"osm\",\n                \"satellite\",\n                \"mtg\",\n                \"msg\",\n                \"blue_marble\",\n            ]\n        ) = \"gray\",\n        projection: (\n            Literal[\"platecarree\", \"perspective\", \"orthographic\"] | ccrs.Projection\n        ) = ccrs.Orthographic(),\n        central_latitude: float | ArrayLike | None = None,\n        central_longitude: float | ArrayLike | None = None,\n        grid_color: ColorLike | None = None,\n        border_color: ColorLike | None = None,\n        coastline_color: ColorLike | None = None,\n        show_grid: bool = True,\n        show_grid_labels: bool = True,\n        show_geo_labels: bool = True,\n        show_top_labels: bool = True,\n        show_bottom_labels: bool = True,\n        show_right_labels: bool = True,\n        show_left_labels: bool = True,\n        show_text_time: bool = True,\n        show_text_frame: bool = True,\n        show_text_overpass: bool = True,\n        show_night_shade: bool = True,\n        timestamp: TimestampLike | None = None,\n        extent: Iterable | None = None,\n        lod: int = 2,\n        coastlines_resolution: Literal[\"10m\", \"50m\", \"110m\"] = \"110m\",\n        azimuth: float = 0,\n        pad: float | list[float] = 0.05,\n        background_alpha: float = 1.0,\n        colorbar_tick_scale: float | None = None,\n        fig_height_scale: float = 1.0,\n        fig_width_scale: float = 1.0,\n    ):\n        figsize = (figsize[0] * fig_width_scale, figsize[1] * fig_height_scale)\n        self.figsize = _validate_figsize(figsize)\n        self.fig, self.ax = _ensure_figure_and_main_axis(ax, figsize=figsize, dpi=dpi)\n\n        self.dpi = dpi\n        self.title = title\n        self.style = style\n        self.grid_color = Color.from_optional(grid_color)\n        self.border_color = Color.from_optional(border_color)\n        self.coastline_color = Color.from_optional(coastline_color)\n        self.show_grid = show_grid\n        self.show_grid_labels = show_grid_labels\n        self.show_geo_labels = show_grid_labels and show_geo_labels\n        self.show_top_labels = show_grid_labels and show_top_labels\n        self.show_bottom_labels = show_grid_labels and show_bottom_labels\n        self.show_right_labels = show_grid_labels and show_right_labels\n        self.show_left_labels = show_grid_labels and show_left_labels\n        if (\n            not self.show_top_labels\n            and not self.show_bottom_labels\n            and not self.show_right_labels\n            and not self.show_left_labels\n        ):\n            self.show_grid_labels = False\n        self.show_text_time = show_text_time\n        self.show_text_frame = show_text_frame\n        self.show_text_overpass = show_text_overpass\n        if timestamp is not None:\n            timestamp = to_timestamp(timestamp)\n        self.timestamp = timestamp\n        self.extent: list | None = None\n        if isinstance(extent, Iterable):\n            self.extent = list(extent)\n\n        if central_latitude is not None and central_longitude is not None:\n            central_latitude, central_longitude = get_central_coords(\n                central_latitude, central_longitude\n            )\n        else:\n            if central_latitude is not None:\n                central_latitude = get_central_latitude(central_latitude)\n            if central_longitude is not None:\n                central_longitude = get_central_longitude(central_longitude)\n        self.projection_type, clat, clon = _validate_projection(projection)\n        self.central_latitude: float | None = central_latitude\n        self.central_longitude: float | None = central_longitude\n        if central_latitude is None:\n            self.central_latitude = clat\n        if central_longitude is None:\n            self.central_longitude = clon\n\n        self.lod = lod\n        self.coastlines_resolution = coastlines_resolution\n        self.azimuth = azimuth\n        self.colorbar: Colorbar | None = None\n        self.colorbar_tick_scale: float | None = colorbar_tick_scale\n        self.pad = _validate_pad(pad)\n        self.background_alpha = background_alpha\n\n        self.grid_lines: Gridliner | None = None\n\n        self.show_night_shade = show_night_shade\n\n        self._init_axes()\n\n    def set_view(\n        self, lats: ArrayLike, lons: ArrayLike, pad: float | Iterable | None = None\n    ) -&gt; Axes:\n        if isinstance(pad, (float | int | Iterable)):\n            self.pad = _validate_pad(pad)\n        self.ax = set_view(\n            self.ax,\n            self.projection,\n            lats,\n            lons,\n            pad_xmin=self.pad[0],\n            pad_xmax=self.pad[1],\n            pad_ymin=self.pad[2],\n            pad_ymax=self.pad[3],\n        )\n        return self.ax\n\n    def set_extent(\n        self, extent: list | None = None, pad: float | Iterable | None = None\n    ) -&gt; \"MapFigure\":\n        if isinstance(extent, Iterable):\n            self.extent = extent\n            self.set_view(\n                lons=np.array(self.extent[0:2]),\n                lats=np.array(self.extent[2:4]),\n                pad=pad,\n            )\n        return self\n\n    def _init_axes(self) -&gt; None:\n        if self.projection_type == ccrs.PlateCarree:\n            self.projection = self.projection_type(self.central_longitude)\n        elif self.projection_type == ccrs.NearsidePerspective:\n            self.projection = self.projection_type(\n                central_longitude=self.central_longitude,\n                central_latitude=self.central_latitude,\n            )\n        elif self.projection_type == ccrs.Orthographic:\n            self.projection = self.projection_type(\n                central_longitude=self.central_longitude,\n                central_latitude=self.central_latitude,\n            )\n        elif self.projection_type == ccrs.ObliqueMercator:\n            if self.central_longitude is None:\n                self.central_longitude = 0\n            if self.central_latitude is None:\n                self.central_latitude = 0\n            self.projection = self.projection_type(\n                central_longitude=self.central_longitude,\n                central_latitude=self.central_latitude,\n                azimuth=self.azimuth,\n            )\n        elif self.projection_type == ccrs.Stereographic:\n            self.projection = self.projection_type(\n                central_longitude=self.central_longitude,\n                central_latitude=self.central_latitude,\n            )\n        else:\n            self.projection = self.projection_type()\n        self.transform = ccrs.Geodetic()  # ccrs.PlateCarree()\n\n        # making sure axis projection is setup correctly\n        if not isinstance(self.ax, Axes):\n            self.fig, self.ax = plt.subplots(\n                subplot_kw={\"projection\": self.projection}, figsize=self.figsize\n            )\n        elif not (\n            hasattr(self.ax, \"projection\")\n            and type(self.ax.projection) == type(self.projection)\n        ):\n            tmp = self.ax.get_figure()\n            if not isinstance(tmp, (Figure, SubFigure)):\n                raise ValueError(f\"Invalid Figure\")\n            self.fig = tmp  # type: ignore\n            self.ax = self.ax\n\n            pos = self.ax.get_position()\n            self.ax.remove()\n            self.ax = self.fig.add_subplot(pos, projection=self.projection)  # type: ignore\n\n        # self.ax.set_facecolor(\"white\")\n        # self.ax.set_facecolor(\"none\")\n\n        if self.title:\n            self.fig.suptitle(self.title)\n\n        self.ax.axis(\"equal\")\n\n        # Earth image\n        grid_color = Color(\"#000000\")\n        coastline_color = Color(\"#000000\")\n\n        if not isinstance(self.style, str):\n            raise TypeError(\n                f\"style has wrong type '{type(self.style).__name__}'. Expected 'str'\"\n            )\n        if self.style == \"none\":\n            pass\n        elif self.style == \"stock_img\":\n            img = self.ax.stock_img()  # type: ignore\n            grid_color = Color(\"#3f4d53\")\n            coastline_color = Color(\"#537585\")\n        elif self.style == \"gray\":\n            img = add_gray_stock_img(self.ax)\n            grid_color = Color(\"#6d6d6db3\")\n            coastline_color = Color(\"#C0C0C0\")\n        elif self.style == \"osm\":\n            request = cimgt.OSM()\n            img = self.ax.add_image(\n                request,\n                self.lod,\n                interpolation=\"spline36\",\n                regrid_shape=2000,\n            )  # type: ignore\n            grid_color = Color(\"#6d6d6db3\")\n            coastline_color = Color(\"#C0C0C0\")\n        elif self.style == \"satellite\":\n            request = cimgt.QuadtreeTiles()\n            img = self.ax.add_image(\n                request,\n                self.lod,\n                interpolation=\"spline36\",\n                regrid_shape=2000,\n            )  # type: ignore\n            grid_color = Color(\"#C0C0C099\")\n            coastline_color = Color(\"#C0C0C099\")\n        elif self.style == \"blue_marble\":\n\n            wms = WebMapService(\n                \"https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi?\",\n                version=\"1.1.1\",\n            )\n            layer = \"BlueMarble_ShadedRelief_Bathymetry\"\n            self.ax.add_wms(wms, layer)  # type: ignore\n            grid_color = Color(\"#C7C7C799\")\n            coastline_color = Color(\"ec:lightblue\")\n\n            width, height = 1024, 512\n            white_overlay = np.ones((height, width, 4))\n            white_overlay[..., 3] = 0.2\n\n            self.ax.imshow(\n                white_overlay,\n                origin=\"upper\",\n                transform=ccrs.PlateCarree(),\n            )\n        else:\n            if not isinstance(self.timestamp, pd.Timestamp):\n                msg = f\"Missing timestamp for {self.style.upper()} data request for 'https://view.eumetsat.int' (timestamp={self.timestamp})\"\n                warnings.warn(msg)\n            else:\n                if self.style == \"mtg\":\n                    if self.timestamp &lt; to_timestamp(\"2024-09-23T02:00\"):\n                        self.style = \"msg\"\n                        msg = (\n                            f\"Switching to MSG since MTG is only available from 2024-09-23 02:00 UTC onwards\"\n                            f\"(timestamp given: {time_to_iso(self.timestamp, format='%Y-%m-%d %H:%M:%S')})\"\n                        )\n                        warnings.warn(msg)\n                img = add_gray_stock_img(self.ax)\n                grid_color = Color(\"#3f4d53\")\n                coastline_color = Color(\"white\").blend(0.5)  # Color(\"#3f4d53\")\n\n                date_str = (\n                    pd.Timestamp(self.timestamp, tz=\"UTC\")\n                    .round(\"h\")\n                    .isoformat()\n                    .replace(\"+00:00\", \"Z\")\n                )\n                # Connect to NASA GIBS\n                url = \"https://view.eumetsat.int/geoserver/ows\"\n\n                wms = WebMapService(url)\n                if self.style == \"mtg\":\n                    layer = \"mtg_fd:rgb_geocolour\"  # \"mtg_fd:ir105_hrfi\" #\"mumi:worldcloudmap_ir108\" #\"MODIS_Terra_SurfaceReflectance_Bands143\"\n                elif self.style == \"msg\":\n                    layer = \"msg_fes:rgb_naturalenhncd\"\n                elif self.style == \"nasa\":\n                    wms = WebMapService(\n                        \"https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi?\",\n                        version=\"1.1.1\",\n                    )\n                    layer = \"MODIS_Terra_CorrectedReflectance_TrueColor\"\n                elif \"nasa:\" in self.style:\n                    self.style = self.style.replace(\"nasa:\", \"\")\n                    layer = self.style\n                    wms = WebMapService(\n                        \"https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi?\",\n                        version=\"1.1.1\",\n                    )\n                else:\n                    layer = self.style\n                    # raise NotImplementedError()\n                wms_kwargs = {\n                    \"time\": date_str,\n                }\n\n                self.ax.add_wms(wms, layer, wms_kwargs=wms_kwargs)  # type: ignore\n\n        # Overlay white transparent layer\n        if self.background_alpha &lt; 1.0:\n            width, height = 1024, 512\n            white_overlay = np.ones((height, width, 4))\n            white_overlay[..., 3] = 1 - self.background_alpha\n\n            self.ax.imshow(\n                white_overlay,\n                origin=\"upper\",\n                transform=ccrs.PlateCarree(),\n            )\n        # else:\n        #     raise ValueError(\n        #         f'invalid style \"{self.style}\". Valid styles are: \"gray\", \"osm\", \"satellite\"'\n        #     )\n\n        # Grid lines\n        _grid_color = self.grid_color\n        if _grid_color is None:\n            _grid_color = grid_color\n\n        _border_color = self.border_color\n        if _border_color is None:\n            _border_color = _grid_color\n\n        _coastline_color = self.coastline_color\n        if _coastline_color is None:\n            _coastline_color = coastline_color\n\n        if self.show_grid:\n            self.grid_lines = self.ax.gridlines(draw_labels=True, color=_grid_color, linewidth=0.5, linestyle=\"dashed\")  # type: ignore\n            self.grid_lines.geo_labels = self.show_geo_labels\n            self.grid_lines.top_labels = self.show_top_labels\n            self.grid_lines.bottom_labels = self.show_bottom_labels\n            self.grid_lines.right_labels = self.show_right_labels\n            self.grid_lines.left_labels = self.show_left_labels\n        # self.ax.coastlines(  # type: ignore\n        #     color=coastlines_color, resolution=self.coastlines_resolution\n        # )  # type: ignore\n        self.ax.add_feature(cfeature.COASTLINE.with_scale(self.coastlines_resolution), edgecolor=_coastline_color)  # type: ignore\n        # self.ax.add_feature(  # type: ignore\n        #     cfeature.BORDERS,\n        #     linewidth=0.5,\n        #     linestyle=\"solid\",\n        #     edgecolor=_coastline_color,\n        # )  # type: ignore\n        self.ax.spines[\"geo\"].set_edgecolor(_border_color)\n\n        # Night shade\n        if self.timestamp is not None:\n            self.timestamp = to_timestamp(self.timestamp)\n            if self.show_night_shade:\n                night_shade_alpha = 0.15\n                night_shade_color = Color(\"#000000\")\n                self.ax.add_feature(  # type: ignore\n                    Nightshade(\n                        self.timestamp,\n                        alpha=night_shade_alpha,\n                        color=night_shade_color,\n                        linewidth=0,\n                    )\n                )  # type: ignore\n\n    def plot_track(\n        self,\n        latitude: NDArray,\n        longitude: NDArray,\n        marker: str | None = None,\n        markersize: float | int | None = None,\n        linestyle: str | None = None,\n        linewidth: float | int = 2,\n        color: Color | ColorLike | None = None,\n        alpha: float | None = 1.0,\n        highlight_first: bool = True,\n        highlight_first_color: Color | None = None,\n        highlight_last: bool = True,\n        highlight_last_color: Color | None = None,\n        zorder: float = 4,\n        z: NDArray | None = None,\n        cmap: Cmap | str = \"viridis\",\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        show_border: bool = False,\n        border_linewidth: float = 1,\n        border_color=\"black\",\n        colorbar: bool = True,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"bottom\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.3,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        label: str = \"\",\n        units: str = \"\",\n        line_overlap: int = 20,\n    ) -&gt; \"MapFigure\":\n        latitude = np.asarray(latitude)\n        longitude = np.asarray(longitude)\n\n        if z is not None:\n            z = np.asarray(z)\n            line_overlap = min(line_overlap, int(len(z) * 0.01))\n            cmap, value_range, norm = self._init_cmap(\n                cmap, value_range, log_scale, norm\n            )\n\n            coords = np.column_stack([longitude, latitude])\n            segments = [s for s in np.stack([coords[:-1], coords[1:]], axis=1)]\n            coords_borders = np.array(\n                [coords[0]]\n                + [\n                    get_coord_between(s[0][::-1], s[1][::-1])[::-1] for s in segments\n                ]  # Reverse lon/lat to lat/lon for get_coord_between and back again\n                + [coords[-1]] * (line_overlap + 1)\n            )\n            segments = [\n                s for s in np.stack([coords_borders[:-1], coords_borders[1:]], axis=1)\n            ]\n\n            def _stack_points(points, line_overlap):\n                n_stacks = line_overlap + 2\n                return np.stack(\n                    [\n                        points[i : len(points) - (n_stacks - 1) + i]\n                        for i in range(n_stacks)\n                    ],\n                    axis=1,\n                )\n\n            segments = [\n                s for s in _stack_points(coords_borders, line_overlap=line_overlap)\n            ]\n            z_segments = z\n\n            if show_border:\n                _l_border = self.ax.plot(\n                    coords[:, 0],\n                    coords[:, 1],\n                    linestyle=\"solid\",\n                    linewidth=linewidth + border_linewidth * 2,\n                    transform=self.transform,\n                    zorder=zorder,\n                    color=border_color,\n                    solid_capstyle=\"butt\",\n                )\n\n            _lc = LineCollection(\n                segments,\n                cmap=cmap,\n                norm=norm,\n                linewidth=linewidth,\n                transform=self.transform,\n                zorder=zorder,\n                antialiased=True,\n            )\n            _lc.set_array(z_segments)\n            self.ax.add_collection(_lc)\n\n            if colorbar and not self.colorbar:\n                cb_kwargs = dict(\n                    label=format_var_label(label, units),\n                    position=colorbar_position,\n                    alignment=colorbar_alignment,\n                    width=colorbar_width,\n                    spacing=colorbar_spacing,\n                    length_ratio=colorbar_length_ratio,\n                    label_outside=colorbar_label_outside,\n                    ticks_outside=colorbar_ticks_outside,\n                    ticks_both=colorbar_ticks_both,\n                )\n                self.colorbar = add_colorbar(\n                    fig=self.fig,\n                    ax=self.ax,\n                    data=_lc,\n                    cmap=cmap,\n                    **cb_kwargs,  # type: ignore\n                )\n                self.set_colorbar_tick_scale(multiplier=self.colorbar_tick_scale)\n\n            return self\n\n        color = Color.from_optional(color)\n        highlight_first_color = Color.from_optional(highlight_first_color)\n        highlight_last_color = Color.from_optional(highlight_last_color)\n\n        p = self.ax.plot(\n            longitude,\n            latitude,\n            marker=marker,\n            markersize=markersize,\n            linestyle=linestyle,\n            linewidth=linewidth,\n            zorder=zorder,\n            transform=self.transform,\n            color=color,\n            alpha=alpha,\n            markeredgewidth=linewidth,\n        )\n        color = p[0].get_color()  # type: ignore\n        if highlight_first_color is None:\n            highlight_first_color = color\n        if highlight_last_color is None:\n            highlight_last_color = color\n\n        if highlight_first:\n            self.ax.plot(\n                [longitude[0]],\n                [latitude[0]],\n                marker=\"o\",\n                markersize=markersize,\n                linestyle=\"none\",\n                zorder=zorder if zorder is not None else 4,\n                transform=self.transform,\n                color=highlight_first_color,\n                alpha=alpha,\n            )\n\n        if highlight_last:\n            tmp_i = 0\n            for i in range(len(longitude)):\n                if (longitude[-1], latitude[-1]) != (\n                    longitude[-2 - i],\n                    latitude[-2 - i],\n                ):\n                    tmp_i = -2 - i\n                    break\n            arrow_style = get_arrow_style(linewidth)\n            self.ax.annotate(\n                \"\",\n                xy=(longitude[-1], latitude[-1]),\n                xytext=(longitude[tmp_i], latitude[tmp_i]),\n                transform=self.transform,\n                clip_on=True,\n                annotation_clip=True,\n                arrowprops=dict(\n                    arrowstyle=arrow_style,\n                    color=highlight_last_color,\n                    lw=linewidth,\n                    shrinkA=0,\n                    shrinkB=0,\n                    alpha=alpha,\n                    connectionstyle=\"arc3,rad=0\",\n                    mutation_scale=10,\n                ),\n                zorder=zorder,\n            )\n        return self\n\n    def plot_text(\n        self,\n        latitude: int | float,\n        longitude: int | float,\n        text: str,\n        color: Color | ColorLike | None = \"black\",\n        text_side: Literal[\"left\", \"right\"] = \"left\",\n        zorder: int | float = 8,\n        padding: str = \"  \",\n        rotation: int = 0,\n    ) -&gt; \"MapFigure\":\n        if isinstance(text_side, str):\n            if text_side == \"left\":\n                horizontalalignment = \"right\"\n                text = f\"{text}{padding}\"\n            elif text_side == \"right\":\n                horizontalalignment = \"left\"\n                text = f\"{padding}{text}\"\n            else:\n                raise ValueError(\n                    f'got invalid text_side \"{text_side}\". expected \"left\" or \"right\".'\n                )\n        else:\n            raise TypeError(\n                f\"\"\"invalid type '{type(text_side).__name__}' for text_side. expected type 'str': \"left\" or \"right\".\"\"\"\n            )\n\n        t = self.ax.text(\n            longitude,\n            latitude,\n            text,\n            color=color,\n            verticalalignment=\"center\",\n            horizontalalignment=horizontalalignment,\n            transform=self.transform,\n            zorder=zorder,\n            clip_on=True,\n            rotation=rotation,\n            rotation_mode=\"anchor\",\n        )\n        t = add_shade_to_text(t)\n        return self\n\n    def plot_point(\n        self,\n        latitude: int | float,\n        longitude: int | float,\n        marker: str | None = \"D\",\n        markersize: int | float = 5,\n        color: Color | ColorLike | None = \"black\",\n        alpha: float = 1.0,\n        edgecolor: Color | ColorLike | None = \"white\",\n        edgealpha: float = 0.8,\n        zorder: int | float = 4,\n        text: str | None = None,\n        text_color: Color | ColorLike | None = \"black\",\n        text_side: Literal[\"left\", \"right\"] = \"right\",\n        text_zorder: int | float = 8,\n        text_padding: str = \"  \",\n    ) -&gt; \"MapFigure\":\n        _color = Color.from_optional(color, alpha=alpha)\n        _edgecolor = Color.from_optional(edgecolor, alpha=edgealpha)\n        self.ax.plot(\n            [longitude],\n            [latitude],\n            marker=marker,\n            markersize=markersize,\n            linestyle=\"none\",\n            transform=self.transform,\n            color=_color,\n            zorder=zorder,\n            markerfacecolor=_color,\n            markeredgecolor=_edgecolor,\n        )\n        if isinstance(text, str):\n            self.plot_text(\n                latitude=latitude,\n                longitude=longitude,\n                text=text,\n                color=text_color,\n                text_side=text_side,\n                zorder=text_zorder,\n                padding=text_padding,\n            )\n        return self\n\n    def plot_radius(\n        self,\n        latitude: int | float,\n        longitude: int | float,\n        radius_km: int | float,\n        color: Color | ColorLike | None = \"#000000\",\n        face_color: Color | ColorLike | None = \"#FFFFFF00\",\n        edge_color: Color | ColorLike | None = None,\n        text_color: Color | ColorLike | None = None,\n        point_color: Color | ColorLike | None = None,\n        edge_alpha: float = 0.8,\n        text: str | None = None,\n        text_side: Literal[\"left\", \"right\"] = \"right\",\n        marker: str | None = \"D\",\n        zorder: int | float = 4,\n        text_zorder: int | float = 8,\n    ) -&gt; \"MapFigure\":\n        _color: Color | None = Color.from_optional(color)\n        _face_color = Color.from_optional(face_color) or Color(\"#FFFFFF00\")\n        _edge_color = Color.from_optional(edge_color) or _color\n        _text_color = Color.from_optional(text_color) or Color(\"#000000\")\n        _point_color = Color.from_optional(point_color) or _color\n        if isinstance(_edge_color, Color):\n            _edge_color = _edge_color.set_alpha(edge_alpha)\n\n        # Draw circle\n        # TODO: workaround to avoid annoying warnings, need to change this later!\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\", message=\"Approximating coordinate system*\"\n            )\n            self.ax.tissot(  # type: ignore\n                rad_km=radius_km,\n                lons=longitude,\n                lats=latitude,\n                n_samples=128,\n                facecolor=_face_color,\n                edgecolor=_edge_color,\n                zorder=zorder,\n            )  # type: ignore\n\n        # Draw center point\n        self.plot_point(\n            longitude=longitude,\n            latitude=latitude,\n            marker=marker,\n            markersize=5,\n            color=_point_color,\n            zorder=zorder,\n            text=text,\n            text_color=_text_color,\n            text_side=text_side,\n            text_zorder=text_zorder,\n            text_padding=\"  \",\n        )\n\n        return self\n\n    def _plot_overpass(\n        self,\n        lat_selection: NDArray,\n        lon_selection: NDArray,\n        lat_total: NDArray,\n        lon_total: NDArray,\n        site: GroundSite,\n        radius_km: int | float,\n        site_color: Color | ColorLike | None = \"black\",\n        radius_color: Color | ColorLike | None = None,\n        color_selection: Color | ColorLike | None = \"ec:earthcare\",\n        linewidth_selection: float = 3,\n        linestyle_selection: str | None = \"solid\",\n        color_total: Color | ColorLike | None = \"ec:blue\",\n        linewidth_total: float = 2.5,\n        linestyle_total: str | None = \"solid\",\n        site_text_side: Literal[\"left\", \"right\"] = \"right\",\n        timestamp: pd.Timestamp | None = None,\n        view: Literal[\"global\", \"data\", \"overpass\"] = \"overpass\",\n        show_highlights: bool = True,\n    ) -&gt; \"MapFigure\":\n        if radius_color is None:\n            if self.style in [\"satellite\", \"blue_marble\"]:\n                radius_color = \"white\"\n            elif self.style in [\"gray\"]:\n                radius_color = \"black\"\n\n        lat_selection = np.asarray(lat_selection)\n        lon_selection = np.asarray(lon_selection)\n        lat_total = np.asarray(lat_total)\n        lon_total = np.asarray(lon_total)\n\n        site_lat = site.latitude\n        site_lon = site.longitude\n        site_alt = site.altitude\n        site_name = site.name\n\n        self.central_latitude = site_lat\n        self.central_longitude = site_lon\n\n        if view == \"overpass\":\n            self.lod = get_osm_lod(\n                (lat_selection[0], lon_selection[0]),\n                (lat_selection[-1], lon_selection[-1]),\n            )\n            self.coastlines_resolution = \"10m\"\n        elif view == \"data\":\n            self.lod = get_osm_lod(\n                (lat_total[0], lon_total[0]), (lat_total[-1], lon_total[-1])\n            )\n            self.coastlines_resolution = \"50m\"\n        else:\n            self.lod = 2\n            self.coastlines_resolution = \"110m\"\n\n        if timestamp is not None:\n            self.timestamp = to_timestamp(timestamp)\n\n        pos = self.ax.get_position()\n        self.fig.delaxes(self.ax)\n        self.ax = self.fig.add_axes(pos)  # type: ignore\n        self._init_axes()\n\n        # FIXME: workaround to avoid annoying warnings, need to change this later!\n        warnings.filterwarnings(\"ignore\", message=\"Approximating coordinate system*\")\n        self.plot_radius(\n            latitude=site_lat,\n            longitude=site_lon,\n            radius_km=radius_km,\n            text=site_name,\n            text_side=site_text_side,\n            color=radius_color,\n            point_color=site_color,\n            text_color=site_color,\n        )\n\n        highlight_last = False if view == \"overpass\" else True\n        self.plot_track(\n            latitude=lat_total,\n            longitude=lon_total,\n            linewidth=linewidth_total,\n            linestyle=linestyle_total,\n            highlight_first=show_highlights and False,\n            highlight_last=show_highlights and highlight_last,\n            color=color_total,\n        )\n        highlight_first = True if view == \"overpass\" else False\n        highlight_last = True if view == \"overpass\" else False\n        self.plot_track(\n            latitude=lat_selection,\n            longitude=lon_selection,\n            linewidth=linewidth_selection,\n            linestyle=linestyle_selection,\n            highlight_first=show_highlights and highlight_first,\n            highlight_last=show_highlights and highlight_last,\n            color=color_selection,\n        )\n\n        self.ax.axis(\"equal\")\n        # if view == \"overpass\":\n        #     extent = compute_bbox(np.vstack((lat_selection, lon_selection)).T)\n        # else:\n        #     extent = compute_bbox(np.vstack((lat_total, lon_total)).T)\n\n        if view == \"global\":\n            self.ax.set_global()  # type: ignore\n        elif view == \"overpass\":\n            zoom_radius_meters = radius_km * 1e3 * 1.3\n            if isinstance(self.projection, ccrs.PlateCarree):\n                self.set_view(lats=lat_selection, lons=lon_selection)\n            else:\n                self.ax.set_xlim(-zoom_radius_meters, zoom_radius_meters)\n                self.ax.set_ylim(-zoom_radius_meters, zoom_radius_meters)\n        elif view == \"data\":\n            _lats = lat_total\n            is_polar_track: bool = not ismonotonic(lat_total)\n            if is_polar_track:\n                _lats = np.nanmin(_lats)\n            if isinstance(self.projection, ccrs.PlateCarree) or not is_polar_track:\n                self.set_view(lats=_lats, lons=lon_total)\n            else:\n                _dist = haversine(\n                    (self.central_latitude, self.central_longitude),\n                    (lat_total[0], lon_total[0]),\n                    units=\"m\",\n                )\n\n                _dist2 = haversine(\n                    (self.central_latitude, self.central_longitude),\n                    (lat_total[-1], lon_total[-1]),\n                    units=\"m\",\n                )\n                _ratio = np.max([(_dist / np.max([_dist2, 1.0])) * 0.5, 1.0])\n                print(f\"{_ratio=}\")\n\n                self.ax.set_xlim(-_dist / _ratio, _dist / _ratio)\n                if lat_total[0] &lt; lat_total[1]:\n                    self.ax.set_ylim(-_dist / _ratio, _dist)\n                else:\n                    self.ax.set_ylim(-_dist, _dist / _ratio)\n\n            # zoom_radius_meters = (\n            #     haversine(\n            #         (lat_total[0], lon_total[0]),\n            #         (lat_total[-1], lon_total[-1]),\n            #         units=\"m\",\n            #     )\n            #     * 1.3\n            # ) / 2\n            # if isinstance(self.projection, ccrs.PlateCarree):\n            #     self.set_view(lats=lat_total, lons=lon_total)\n            # else:\n            #     self.ax.set_xlim(-zoom_radius_meters, zoom_radius_meters)\n            #     self.ax.set_ylim(-zoom_radius_meters, zoom_radius_meters)\n\n            # _diameter = haversine(\n            #     (lat_total[0], lon_total[0]),\n            #     (lat_total[-1], lon_total[-1]),\n            #     units=\"m\",\n            # )\n            # _radius = _diameter / 2\n            # zoom_radius_meters = _radius * 1e3 * 1.3\n            # if isinstance(self.projection, ccrs.PlateCarree):\n            #     self.set_view(lats=lat_total, lons=lon_total)\n            # else:\n            #     self.ax.set_xlim(-zoom_radius_meters, zoom_radius_meters)\n            #     self.ax.set_ylim(-zoom_radius_meters, zoom_radius_meters)\n\n        return self\n\n    def ecplot(\n        self,\n        ds: xr.Dataset,\n        var: str | None = None,\n        *,\n        lat_var: str = TRACK_LAT_VAR,\n        lon_var: str = TRACK_LON_VAR,\n        swath_lat_var: str = SWATH_LAT_VAR,\n        swath_lon_var: str = SWATH_LON_VAR,\n        time_var: str = TIME_VAR,\n        along_track_dim: str = ALONG_TRACK_DIM,\n        across_track_dim: str = ACROSS_TRACK_DIM,\n        site: str | GroundSite | None = None,\n        radius_km: float = 100.0,\n        time_range: TimeRangeLike | None = None,\n        view: Literal[\"global\", \"data\", \"overpass\"] = \"global\",\n        zoom_tmin: TimestampLike | None = None,\n        zoom_tmax: TimestampLike | None = None,\n        color: ColorLike | None = \"ec:earthcare\",\n        linewidth: float = 3,\n        linestyle: str | None = \"solid\",\n        color2: ColorLike | None = \"ec:blue\",\n        linewidth2: float | None = None,\n        linestyle2: str | None = None,\n        cmap: str | Cmap | None = None,\n        zoom_radius_km: float | None = None,\n        extent: list[float] | None = None,\n        central_latitude: float | None = None,\n        central_longitude: float | None = None,\n        value_range: ValueRangeLike | Literal[\"default\"] | None = \"default\",\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        colorbar: bool = True,\n        pad: float | list[float] | None = None,\n        show_text_time: bool | None = None,\n        show_text_frame: bool | None = None,\n        show_text_overpass: bool | None = None,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"bottom\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.3,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        selection_max_time_margin: (\n            TimedeltaLike | Sequence[TimedeltaLike] | None\n        ) = None,\n    ) -&gt; \"MapFigure\":\n        \"\"\"\n        Plot the EarthCARE satellite track on a map, optionally showing a 2D swath variable if `var` is provided.\n\n        This method collects all required data from an EarthCARE `xarray.Dataset`.\n        If `var` is given, the corresponding swath variable is plotted on the map using a\n        color scale. Otherwise, the satellite ground track is plotted as a colored line.\n        If `time_range` or `site` is given, the selected track section within the selected time range or in proximity to ground sites are highlighted.\n\n        Args:\n            ds (xr.Dataset): The EarthCARE dataset from which data will be plotted.\n            var (str | None, optional): Name of a 2D swath variable to plot. If None, only the satellite ground track is shown. Defaults to None.\n            lat_var (str, optional): Name of the latitude variable for the along-track data. Defaults to TRACK_LAT_VAR.\n            lon_var (str, optional): Name of the longitude variable for the along-track data. Defaults to TRACK_LON_VAR.\n            swath_lat_var (str, optional): Name of the latitude variable for the swath. Defaults to SWATH_LAT_VAR.\n            swath_lon_var (str, optional): Name of the longitude variable for the swath. Defaults to SWATH_LON_VAR.\n            time_var (str, optional): Name of the time variable. Defaults to TIME_VAR.\n            along_track_dim (str, optional): Dimension name representing the along-track direction. Defaults to ALONG_TRACK_DIM.\n            across_track_dim (str, optional): Dimension name representing the across-track direction. Defaults to ACROSS_TRACK_DIM.\n            site (str | GroundSite | None, optional): Highlights data within `radius_km` of a ground site (given either as a `GroundSite` object or name string); ignored if not set. Defaults to None.\n            radius_km (float, optional): Radius around the ground site to highlight data from; ignored if `site` not set. Defaults to 100.0.\n            time_range (TimeRangeLike | None, optional): Time range to highlight as selection area; ignored if `site` is set. Defaults to None.\n            view (Literal[\"global\", \"data\", \"overpass\"], optional): Map extent mode: \"global\" for full world, \"data\" for tight bounds, or \"overpass\" to zoom around `site` or time range. Defaults to \"global\".\n            zoom_tmin (TimestampLike | None, optional): Optional lower time bound used for zooming map around track. Defaults to None.\n            zoom_tmax (TimestampLike | None, optional): Optional upper time bound used for zooming map around track. Defaults to None.\n            color (ColorLike | None, optional): Color used for selected section of the track or entire track if no selection. Defaults to \"ec:earthcare\".\n            linewidth (float, optional): Line width for selected track section. Defaults to 3.\n            linestyle (str | None, optional): Line style for selected track section. Defaults to \"solid\".\n            color2 (ColorLike | None, optional): Color used for unselected sections of the track. Defaults to \"ec:blue\".\n            linewidth2 (float, optional): Line width for unselected sections. Defaults to None.\n            linestyle2 (str | None, optional): Line style for unselected sections. Defaults to None.\n            cmap (str | Cmap | None, optional): Colormap to use when plotting a swath variable. Defaults to None.\n            zoom_radius_km (float | None, optional): If set, overrides map extent derived from `view` to use a fixed radius around the site or selection. Defaults to None.\n            extent (list[float] | None, optional): Map extent in the form [lon_min, lon_max, lat_min, lat_max]. If given, overrides map extent derived from `view`. Defaults to None.\n            central_latitude (float | None, optional): Central latitude used for the map projection. Defaults to None.\n            central_longitude (float | None, optional): Central longitude used for the map projection. Defaults to None.\n            value_range (ValueRangeLike | None, optional): Min and max range for the variable values; ignored if `var` is None. Defaults to None.\n            log_scale (bool | None, optional): Whether to apply a logarithmic color scale to the variable. Defaults to None.\n            norm (Normalize | None, optional): Matplotlib norm to use for color scaling. Defaults to None.\n            colorbar (bool, optional): Whether to display a colorbar for the variable. Defaults to True.\n            pad (float | list[float] | None, optional): Padding around the map extent; ignored if `extent` is given. Defaults to None.\n            show_text_time (bool | None, optional): Whether to display the UTC time start and end of the selected track. Defaults to None.\n            show_text_frame (bool | None, optional): Whether to display EarthCARE frame information. Defaults to None.\n            show_text_overpass (bool | None, optional): Whether to display overpass site name and related info. Defaults to None.\n\n        Returns:\n            MapFigure: The figure object containing the map with track or swath.\n\n        Example:\n            ```python\n            import earthcarekit as eck\n\n            filepath = \"path/to/mydata/ECA_EXAE_ATL_NOM_1B_20250606T132535Z_20250606T150730Z_05813D.h5\"\n            with eck.read_product(filepath) as ds:\n                mf = eck.MapFigure()\n                mf = mf.ecplot(ds)\n            ```\n        \"\"\"\n        if pad is not None:\n            self.pad = _validate_pad(pad)\n        if show_text_time is not None:\n            self.show_text_time = show_text_time\n        if show_text_frame is not None:\n            self.show_text_frame = show_text_frame\n        if show_text_overpass is not None:\n            self.show_text_overpass = show_text_overpass\n\n        _lat_var: str = lat_var\n        _lon_var: str = lon_var\n\n        _linewidth: float = linewidth\n        _linewidth2: float\n        if isinstance(linewidth2, (float, int)):\n            _linewidth2 = float(linewidth2)\n        else:\n            _linewidth2 = linewidth * 0.7\n\n        if isinstance(var, str):\n            ds = ensure_updated_msi_rgb_if_required(\n                ds, var, time_range, time_var=time_var\n            )\n            _linewidth = linewidth * 0.5\n            linestyle = \"dashed\"\n            _linewidth2 = linewidth * 0.2\n            if all_in(\n                (along_track_dim, across_track_dim), [str(d) for d in ds[var].dims]\n            ):\n                _lat_var = swath_lat_var\n                _lon_var = swath_lon_var\n\n        _site: GroundSite | None = None\n        if isinstance(site, GroundSite):\n            _site = site\n        elif isinstance(site, str):\n            _site = get_ground_site(site)\n\n        coords_whole_flight = get_coords(ds, lat_var=lat_var, lon_var=lon_var)\n\n        if time_range is not None:\n            if zoom_tmin is None and time_range[0] is not None:\n                zoom_tmin = to_timestamp(time_range[0])\n            if zoom_tmax is None and time_range[1] is not None:\n                zoom_tmax = to_timestamp(time_range[1])\n        if zoom_tmin or zoom_tmax:\n            ds_zoomed_in = filter_time(ds, time_range=[zoom_tmin, zoom_tmax])\n            coords_zoomed_in = get_coords(\n                ds_zoomed_in, lat_var=_lat_var, lon_var=_lon_var, flatten=True\n            )\n            coords_zoomed_in_track = get_coords(\n                ds_zoomed_in, lat_var=lat_var, lon_var=lon_var\n            )\n        else:\n            coords_zoomed_in = coords_whole_flight\n            coords_zoomed_in_track = get_coords(ds, lat_var=lat_var, lon_var=lon_var)\n\n        is_polar_track: bool = False\n\n        if isinstance(_site, GroundSite):\n            ds_overpass = filter_radius(\n                ds,\n                radius_km=radius_km,\n                site=_site,\n                lat_var=lat_var,\n                lon_var=lon_var,\n                along_track_dim=along_track_dim,\n            )\n            info_overpass = get_overpass_info(\n                ds_overpass,\n                site_radius_km=radius_km,\n                site=_site,\n                time_var=time_var,\n                lat_var=lat_var,\n                lon_var=lon_var,\n                along_track_dim=along_track_dim,\n            )\n\n            _coords_whole_flight = coords_whole_flight.copy()\n            _selection_max_time_margin: tuple[pd.Timedelta, pd.Timedelta] | None = None\n\n            if selection_max_time_margin is not None:\n                if isinstance(selection_max_time_margin, str):\n                    _selection_max_time_margin = (\n                        to_timedelta(selection_max_time_margin),\n                        to_timedelta(selection_max_time_margin),\n                    )\n                elif isinstance(selection_max_time_margin, (Sequence, np.ndarray)):\n                    _selection_max_time_margin = (\n                        to_timedelta(selection_max_time_margin[0]),\n                        to_timedelta(selection_max_time_margin[1]),\n                    )\n                else:\n                    raise ValueError(\n                        f\"invalid selection_max_time_margin: {selection_max_time_margin}\"\n                    )\n\n                _ds = filter_time(\n                    ds=ds,\n                    time_range=(\n                        to_timestamp(ds_overpass[time_var].values[0])\n                        - _selection_max_time_margin[0],\n                        to_timestamp(ds_overpass[time_var].values[1])\n                        + _selection_max_time_margin[1],\n                    ),\n                    time_var=time_var,\n                )\n                _coords_whole_flight = get_coords(_ds, lat_var=lat_var, lon_var=lon_var)\n\n            coords_overpass = get_coords(ds_overpass, lat_var=lat_var, lon_var=lon_var)\n            _ = self._plot_overpass(\n                lat_selection=coords_overpass[:, 0],\n                lon_selection=coords_overpass[:, 1],\n                lat_total=_coords_whole_flight[:, 0],\n                lon_total=_coords_whole_flight[:, 1],\n                site=_site,\n                radius_km=radius_km,\n                view=view,\n                timestamp=info_overpass.closest_time,\n                color_selection=color,\n                linewidth_selection=_linewidth,\n                linestyle_selection=linestyle,\n                color_total=color2,\n                linewidth_total=_linewidth2,\n                linestyle_total=linestyle2,\n                show_highlights=view == \"overpass\"\n                or not isinstance(_selection_max_time_margin, tuple),\n                radius_color=None,\n            )\n\n            if isinstance(_selection_max_time_margin, tuple):\n                self.plot_track(\n                    latitude=coords_whole_flight[:, 0],\n                    longitude=coords_whole_flight[:, 1],\n                    color=\"white\",\n                    linestyle=\"solid\",\n                    linewidth=2,\n                    highlight_first=False,\n                    highlight_last=True,\n                    zorder=3,\n                )\n\n            if view == \"overpass\":\n                if self.show_text_overpass:\n                    add_text_overpass_info(self.ax, info_overpass)\n            if self.show_text_time:\n                add_title_earthcare_time(\n                    self.ax, tmin=info_overpass.start_time, tmax=info_overpass.end_time\n                )\n        else:\n            if isinstance(central_latitude, (int, float)):\n                self.central_latitude = central_latitude\n            else:\n                self.central_latitude = np.nanmean(coords_zoomed_in_track[:, 0])\n            if isinstance(central_longitude, (int, float)):\n                self.central_longitude = central_longitude\n            else:\n                if not ismonotonic(coords_whole_flight[:, 0]):\n                    is_polar_track = True\n                    self.central_longitude = coords_whole_flight[-1, 1]\n                else:\n                    self.central_longitude = circular_nanmean(coords_whole_flight[:, 1])\n            logger.debug(\n                f\"Set central coords to (lat={self.central_latitude}, lon={self.central_longitude})\"\n            )\n\n            time = ds[time_var].values\n            timestamp = time[len(time) // 2]\n            self.timestamp = to_timestamp(timestamp)\n            if view == \"overpass\":\n                self.lod = get_osm_lod(coords_zoomed_in[0], coords_zoomed_in[-1])\n                if extent is None:\n                    extent = compute_bbox(coords_zoomed_in)\n                    self.extent = extent\n            pos = self.ax.get_position()\n            self.fig.delaxes(self.ax)\n            self.ax = self.fig.add_axes(pos)  # type: ignore\n            self._init_axes()\n            if time_range is not None:\n                _highlight_last = view in [\"global\", \"data\"]\n                _ = self.plot_track(\n                    latitude=coords_whole_flight[:, 0],\n                    longitude=coords_whole_flight[:, 1],\n                    linewidth=_linewidth2,\n                    linestyle=linestyle,\n                    highlight_first=False,\n                    highlight_last=_highlight_last,\n                    color=color2,\n                )\n\n                _highlight_last = view == \"overpass\"\n                _ = self.plot_track(\n                    latitude=coords_zoomed_in_track[:, 0],\n                    longitude=coords_zoomed_in_track[:, 1],\n                    linewidth=_linewidth,\n                    linestyle=linestyle,\n                    highlight_first=False,\n                    highlight_last=_highlight_last,\n                    color=color,\n                )\n            else:\n                _ = self.plot_track(\n                    latitude=coords_whole_flight[:, 0],\n                    longitude=coords_whole_flight[:, 1],\n                    linewidth=_linewidth,\n                    linestyle=linestyle,\n                    highlight_first=False,\n                    highlight_last=True,\n                    color=color,\n                )\n            self.ax.axis(\"equal\")\n            if view == \"global\":\n                self.ax.set_global()  # type: ignore\n            elif view == \"data\":\n                _lats = coords_whole_flight[:, 0]\n                if is_polar_track:\n                    _lats = np.nanmin(_lats)\n                if isinstance(self.projection, ccrs.PlateCarree) or not is_polar_track:\n                    self.set_view(lats=_lats, lons=coords_whole_flight[:, 1])\n                else:\n                    _dist = haversine(\n                        (self.central_latitude, self.central_longitude),  # type: ignore\n                        coords_whole_flight[0],\n                        units=\"m\",\n                    )\n                    self.ax.set_xlim(-_dist / 2, _dist / 2)\n                    if coords_whole_flight[0, 0] &lt; coords_whole_flight[1, 0]:\n                        self.ax.set_ylim(-_dist / 2, _dist)\n                    else:\n                        self.ax.set_ylim(-_dist, _dist / 2)\n            else:\n                _lats = coords_zoomed_in[:, 0]\n                if is_polar_track:\n                    _lats = np.nanmin(_lats)\n                if isinstance(self.projection, ccrs.PlateCarree) or not is_polar_track:\n                    self.set_view(lats=_lats, lons=coords_zoomed_in[:, 1])\n                else:\n                    _dist = haversine(\n                        (self.central_latitude, self.central_longitude),  # type: ignore\n                        coords_zoomed_in[0],\n                        units=\"m\",\n                    )\n                    self.ax.set_xlim(-_dist / 2, _dist / 2)\n                    if coords_zoomed_in[0, 0] &lt; coords_zoomed_in[1, 0]:\n                        self.ax.set_ylim(-_dist / 2, _dist)\n                    else:\n                        self.ax.set_ylim(-_dist, _dist / 2)\n                # _lats = coords_zoomed_in[:, 0]\n                # if is_polar_track:\n                #     _lats = np.nanmin(_lats)\n                # self.set_view(lats=_lats, lons=coords_zoomed_in[:, 1])\n\n            if self.show_text_time:\n                add_title_earthcare_time(self.ax, ds=ds, tmin=zoom_tmin, tmax=zoom_tmax)\n\n        if isinstance(var, str):\n            if cmap is None:\n                cmap = get_default_cmap(var, ds)\n            if isinstance(value_range, str) and value_range == \"default\":\n                value_range = None\n                if log_scale is None and norm is None:\n                    norm = get_default_norm(var, file_type=ds)\n            lats = ds[swath_lat_var].values\n            lons = ds[swath_lon_var].values\n            values = ds[var].values\n            label = getattr(ds[var], \"long_name\", \"\")\n            units = getattr(ds[var], \"units\", \"\")\n            _ = self.plot_swath(\n                lats,\n                lons,\n                values,\n                cmap=cmap,\n                label=label,\n                units=units,\n                value_range=value_range,\n                log_scale=log_scale,\n                norm=norm,\n                colorbar=colorbar,\n                colorbar_position=colorbar_position,\n                colorbar_alignment=colorbar_alignment,\n                colorbar_width=colorbar_width,\n                colorbar_spacing=colorbar_spacing,\n                colorbar_length_ratio=colorbar_length_ratio,\n                colorbar_label_outside=colorbar_label_outside,\n                colorbar_ticks_outside=colorbar_ticks_outside,\n                colorbar_ticks_both=colorbar_ticks_both,\n            )\n\n        # if view == \"data\":\n        #     self.set_view(lats=lats, lons=lons)\n\n        # if zoom_tmin or zoom_tmax:\n        #     extent = compute_bbox(coords_zoomed_in)\n        #     self.ax.set_extent(extent, crs=ccrs.PlateCarree())  # type: ignore\n        if self.show_text_frame:\n            add_title_earthcare_frame(self.ax, ds=ds)\n\n        self.zoom(extent=extent, radius_km=zoom_radius_km)\n\n        return self\n\n    def _init_cmap(\n        self,\n        cmap: str | Cmap | None = None,\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n    ) -&gt; tuple[Cmap, tuple, Normalize]:\n        cmap = get_cmap(cmap)\n\n        if isinstance(value_range, Iterable):\n            if len(value_range) != 2:\n                raise ValueError(\n                    f\"invalid `value_range`: {value_range}, expecting (vmin, vmax)\"\n                )\n        else:\n            value_range = (None, None)\n\n        if isinstance(cmap, Cmap) and cmap.categorical == True:\n            norm = cmap.norm\n        elif isinstance(norm, Normalize):\n            if log_scale == True and not isinstance(norm, LogNorm):\n                norm = LogNorm(norm.vmin, norm.vmax)\n            elif log_scale == False and isinstance(norm, LogNorm):\n                norm = Normalize(norm.vmin, norm.vmax)\n            if value_range[0] is not None:\n                norm.vmin = value_range[0]  # type: ignore # FIXME\n            if value_range[1] is not None:\n                norm.vmax = value_range[1]  # type: ignore # FIXME\n        else:\n            if log_scale == True:\n                norm = LogNorm(value_range[0], value_range[1])  # type: ignore # FIXME\n            else:\n                norm = Normalize(value_range[0], value_range[1])  # type: ignore # FIXME\n\n        assert isinstance(norm, Normalize)\n        value_range = (norm.vmin, norm.vmax)\n\n        return (cmap, value_range, norm)\n\n    def plot_swath(\n        self,\n        lats: NDArray,\n        lons: NDArray,\n        values: NDArray,\n        label: str = \"\",\n        units: str = \"\",\n        cmap: str | Cmap | None = None,\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        colorbar: bool = True,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"bottom\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.3,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        show_swath_border: bool = True,\n    ) -&gt; \"MapFigure\":\n        cmap, value_range, norm = self._init_cmap(cmap, value_range, log_scale, norm)\n\n        if len(values.shape) == 3 and values.shape[2] == 3:\n            mesh = self.ax.pcolormesh(\n                lons.T,\n                lats.T,\n                values,\n                shading=\"auto\",\n                transform=ccrs.PlateCarree(),\n                rasterized=True,\n            )\n        else:\n            mesh = self.ax.pcolormesh(\n                lons,\n                lats,\n                values,\n                cmap=cmap,\n                norm=norm,\n                shading=\"auto\",\n                transform=ccrs.PlateCarree(),\n                rasterized=True,\n            )\n            if colorbar:\n                cb_kwargs = dict(\n                    label=format_var_label(label, units),\n                    position=colorbar_position,\n                    alignment=colorbar_alignment,\n                    width=colorbar_width,\n                    spacing=colorbar_spacing,\n                    length_ratio=colorbar_length_ratio,\n                    label_outside=colorbar_label_outside,\n                    ticks_outside=colorbar_ticks_outside,\n                    ticks_both=colorbar_ticks_both,\n                )\n                self.colorbar = add_colorbar(\n                    fig=self.fig,\n                    ax=self.ax,\n                    data=mesh,\n                    cmap=cmap,\n                    **cb_kwargs,  # type: ignore\n                )\n                self.set_colorbar_tick_scale(multiplier=self.colorbar_tick_scale)\n        if show_swath_border:\n            edgecolor = Color(\"white\").set_alpha(0.5)\n            _ = self.plot_track(\n                lats[:, 0],\n                lons[:, 0],\n                highlight_first=False,\n                highlight_last=False,\n                color=edgecolor,\n                linewidth=1,\n            )\n            _ = self.plot_track(\n                lats[:, -1],\n                lons[:, -1],\n                highlight_first=False,\n                highlight_last=False,\n                color=edgecolor,\n                linewidth=1,\n            )\n            _ = self.plot_track(\n                lats[0, :],\n                lons[0, :],\n                highlight_first=False,\n                highlight_last=False,\n                color=edgecolor,\n                linewidth=1,\n            )\n            _ = self.plot_track(\n                lats[-1, :],\n                lons[-1, :],\n                highlight_first=False,\n                highlight_last=False,\n                color=edgecolor,\n                linewidth=1,\n            )\n\n        return self\n\n    def zoom(\n        self, extent: ArrayLike | None = None, radius_km: float | None = None\n    ) -&gt; \"MapFigure\":\n        radius_meters: float = 0\n\n        if extent is not None:\n            extent = np.asarray(extent)\n            if extent.shape[0] != 4:\n                ValueError(\n                    f\"'extent' has wrong size ({extent.shape[0]}), expecting size of 4 (min_lon, max_lon, min_lat, max_lat)\"\n                )\n            lon_extent_km = haversine([extent[2], extent[0]], [extent[2], extent[1]])\n            lat_extent_km = haversine([extent[2], extent[0]], [extent[3], extent[0]])\n            radius_meters = np.max([lon_extent_km, lat_extent_km]) * 1e3\n\n        if isinstance(radius_km, (int, float)):\n            radius_meters = radius_km * 1e3\n\n        if isinstance(self.projection, ccrs.PlateCarree) and extent is not None:\n            self.ax.set_extent(extent, crs=ccrs.PlateCarree())  # type: ignore\n        elif (\n            not isinstance(self.projection, ccrs.PlateCarree) and radius_km is not None\n        ):\n            self.ax.set_xlim(-radius_meters, radius_meters)\n            self.ax.set_ylim(-radius_meters, radius_meters)\n\n        return self\n\n    def to_texture(\n        self, remove_images: bool = True, remove_features: bool = True\n    ) -&gt; \"MapFigure\":\n        \"\"\"Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.\"\"\"\n        # Remove anchored text and other artist text objects\n        for artist in reversed(self.ax.artists):\n            if isinstance(artist, (Text, AnchoredOffsetbox)):\n                artist.remove()\n\n        # Completely remove axis ticks and labels\n        self.ax.axis(\"off\")\n\n        # Remove white frame around figure\n        self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n        # Remove ticks, tick labels, and gridlines\n        self.ax.set_xticks([])\n        self.ax.set_yticks([])\n        self.ax.xaxis.set_ticklabels([])\n        self.ax.yaxis.set_ticklabels([])\n        self.ax.grid(False)\n\n        # Remove outline box around map\n        self.ax.spines[\"geo\"].set_visible(False)\n\n        # Make the map fill the whole figure\n        self.ax.set_position((0.0, 0.0, 1.0, 1.0))\n\n        if self.colorbar:\n            self.colorbar.remove()\n\n        if self.grid_lines:\n            self.grid_lines.remove()\n\n        if remove_images:\n            for img in self.ax.get_images():\n                img.remove()\n\n        if remove_features:\n            for c in self.ax.get_children():\n                if isinstance(c, FeatureArtist):\n                    c.remove()\n\n        # for c in self.ax.get_children():\n        #     if isinstance(c, _ViewClippedPathPatch):\n        #         c.set_alpha(0)\n\n        for c in self.fig.get_children():\n            if isinstance(c, Rectangle):\n                c.set_alpha(0)\n\n        self.ax.set_facecolor(\"none\")\n\n        return self\n\n    def set_colorbar_tick_scale(\n        self,\n        multiplier: float | None = None,\n        fontsize: float | str | None = None,\n    ) -&gt; \"MapFigure\":\n        _cb = self.colorbar\n        cb: Colorbar\n        if isinstance(_cb, Colorbar):\n            cb = _cb\n        else:\n            return self\n\n        if fontsize is not None:\n            cb.ax.tick_params(labelsize=fontsize)\n            return self\n\n        if multiplier is not None:\n            tls = cb.ax.yaxis.get_ticklabels()\n            if len(tls) == 0:\n                tls = cb.ax.xaxis.get_ticklabels()\n            if len(tls) == 0:\n                return self\n            _fontsize = tls[0].get_fontsize()\n            if isinstance(_fontsize, str):\n                from matplotlib import font_manager\n\n                fp = font_manager.FontProperties(size=_fontsize)\n                _fontsize = fp.get_size_in_points()\n            cb.ax.tick_params(labelsize=_fontsize * multiplier)\n        return self\n\n    def show(self) -&gt; None:\n        import IPython\n        import matplotlib.pyplot as plt\n        from IPython.display import display\n\n        if IPython.get_ipython() is not None:\n            display(self.fig)\n        else:\n            plt.show()\n\n    def save(\n        self,\n        filename: str = \"\",\n        filepath: str | None = None,\n        ds: xr.Dataset | None = None,\n        ds_filepath: str | None = None,\n        dpi: float | Literal[\"figure\"] = \"figure\",\n        orbit_and_frame: str | None = None,\n        utc_timestamp: TimestampLike | None = None,\n        use_utc_creation_timestamp: bool = False,\n        site_name: str | None = None,\n        hmax: int | float | None = None,\n        radius: int | float | None = None,\n        extra: str | None = None,\n        transparent_outside: bool = False,\n        verbose: bool = True,\n        print_prefix: str = \"\",\n        create_dirs: bool = False,\n        transparent_background: bool = False,\n        resolution: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n        Args:\n            figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n            filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n            filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n            ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n            ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n            pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n            dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n            orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n            site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n            transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n            verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n            print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n            create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n            transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n            **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n        \"\"\"\n        save_plot(\n            fig=self.fig,\n            filename=filename,\n            filepath=filepath,\n            ds=ds,\n            ds_filepath=ds_filepath,\n            dpi=dpi,\n            orbit_and_frame=orbit_and_frame,\n            utc_timestamp=utc_timestamp,\n            use_utc_creation_timestamp=use_utc_creation_timestamp,\n            site_name=site_name,\n            hmax=hmax,\n            radius=radius,\n            extra=extra,\n            transparent_outside=transparent_outside,\n            verbose=verbose,\n            print_prefix=print_prefix,\n            create_dirs=create_dirs,\n            transparent_background=transparent_background,\n            resolution=resolution,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_ref/#earthcarekit.MapFigure.ecplot","title":"ecplot","text":"<pre><code>ecplot(\n    ds,\n    var=None,\n    *,\n    lat_var=TRACK_LAT_VAR,\n    lon_var=TRACK_LON_VAR,\n    swath_lat_var=SWATH_LAT_VAR,\n    swath_lon_var=SWATH_LON_VAR,\n    time_var=TIME_VAR,\n    along_track_dim=ALONG_TRACK_DIM,\n    across_track_dim=ACROSS_TRACK_DIM,\n    site=None,\n    radius_km=100.0,\n    time_range=None,\n    view=\"global\",\n    zoom_tmin=None,\n    zoom_tmax=None,\n    color=\"ec:earthcare\",\n    linewidth=3,\n    linestyle=\"solid\",\n    color2=\"ec:blue\",\n    linewidth2=None,\n    linestyle2=None,\n    cmap=None,\n    zoom_radius_km=None,\n    extent=None,\n    central_latitude=None,\n    central_longitude=None,\n    value_range=\"default\",\n    log_scale=None,\n    norm=None,\n    colorbar=True,\n    pad=None,\n    show_text_time=None,\n    show_text_frame=None,\n    show_text_overpass=None,\n    colorbar_position=\"bottom\",\n    colorbar_alignment=\"center\",\n    colorbar_width=DEFAULT_COLORBAR_WIDTH,\n    colorbar_spacing=0.3,\n    colorbar_length_ratio=\"100%\",\n    colorbar_label_outside=True,\n    colorbar_ticks_outside=True,\n    colorbar_ticks_both=False,\n    selection_max_time_margin=None\n)\n</code></pre> <p>Plot the EarthCARE satellite track on a map, optionally showing a 2D swath variable if <code>var</code> is provided.</p> <p>This method collects all required data from an EarthCARE <code>xarray.Dataset</code>. If <code>var</code> is given, the corresponding swath variable is plotted on the map using a color scale. Otherwise, the satellite ground track is plotted as a colored line. If <code>time_range</code> or <code>site</code> is given, the selected track section within the selected time range or in proximity to ground sites are highlighted.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The EarthCARE dataset from which data will be plotted.</p> required <code>var</code> <code>str | None</code> <p>Name of a 2D swath variable to plot. If None, only the satellite ground track is shown. Defaults to None.</p> <code>None</code> <code>lat_var</code> <code>str</code> <p>Name of the latitude variable for the along-track data. Defaults to TRACK_LAT_VAR.</p> <code>TRACK_LAT_VAR</code> <code>lon_var</code> <code>str</code> <p>Name of the longitude variable for the along-track data. Defaults to TRACK_LON_VAR.</p> <code>TRACK_LON_VAR</code> <code>swath_lat_var</code> <code>str</code> <p>Name of the latitude variable for the swath. Defaults to SWATH_LAT_VAR.</p> <code>SWATH_LAT_VAR</code> <code>swath_lon_var</code> <code>str</code> <p>Name of the longitude variable for the swath. Defaults to SWATH_LON_VAR.</p> <code>SWATH_LON_VAR</code> <code>time_var</code> <code>str</code> <p>Name of the time variable. Defaults to TIME_VAR.</p> <code>TIME_VAR</code> <code>along_track_dim</code> <code>str</code> <p>Dimension name representing the along-track direction. Defaults to ALONG_TRACK_DIM.</p> <code>ALONG_TRACK_DIM</code> <code>across_track_dim</code> <code>str</code> <p>Dimension name representing the across-track direction. Defaults to ACROSS_TRACK_DIM.</p> <code>ACROSS_TRACK_DIM</code> <code>site</code> <code>str | GroundSite | None</code> <p>Highlights data within <code>radius_km</code> of a ground site (given either as a <code>GroundSite</code> object or name string); ignored if not set. Defaults to None.</p> <code>None</code> <code>radius_km</code> <code>float</code> <p>Radius around the ground site to highlight data from; ignored if <code>site</code> not set. Defaults to 100.0.</p> <code>100.0</code> <code>time_range</code> <code>TimeRangeLike | None</code> <p>Time range to highlight as selection area; ignored if <code>site</code> is set. Defaults to None.</p> <code>None</code> <code>view</code> <code>Literal['global', 'data', 'overpass']</code> <p>Map extent mode: \"global\" for full world, \"data\" for tight bounds, or \"overpass\" to zoom around <code>site</code> or time range. Defaults to \"global\".</p> <code>'global'</code> <code>zoom_tmin</code> <code>TimestampLike | None</code> <p>Optional lower time bound used for zooming map around track. Defaults to None.</p> <code>None</code> <code>zoom_tmax</code> <code>TimestampLike | None</code> <p>Optional upper time bound used for zooming map around track. Defaults to None.</p> <code>None</code> <code>color</code> <code>ColorLike | None</code> <p>Color used for selected section of the track or entire track if no selection. Defaults to \"ec:earthcare\".</p> <code>'ec:earthcare'</code> <code>linewidth</code> <code>float</code> <p>Line width for selected track section. Defaults to 3.</p> <code>3</code> <code>linestyle</code> <code>str | None</code> <p>Line style for selected track section. Defaults to \"solid\".</p> <code>'solid'</code> <code>color2</code> <code>ColorLike | None</code> <p>Color used for unselected sections of the track. Defaults to \"ec:blue\".</p> <code>'ec:blue'</code> <code>linewidth2</code> <code>float</code> <p>Line width for unselected sections. Defaults to None.</p> <code>None</code> <code>linestyle2</code> <code>str | None</code> <p>Line style for unselected sections. Defaults to None.</p> <code>None</code> <code>cmap</code> <code>str | Cmap | None</code> <p>Colormap to use when plotting a swath variable. Defaults to None.</p> <code>None</code> <code>zoom_radius_km</code> <code>float | None</code> <p>If set, overrides map extent derived from <code>view</code> to use a fixed radius around the site or selection. Defaults to None.</p> <code>None</code> <code>extent</code> <code>list[float] | None</code> <p>Map extent in the form [lon_min, lon_max, lat_min, lat_max]. If given, overrides map extent derived from <code>view</code>. Defaults to None.</p> <code>None</code> <code>central_latitude</code> <code>float | None</code> <p>Central latitude used for the map projection. Defaults to None.</p> <code>None</code> <code>central_longitude</code> <code>float | None</code> <p>Central longitude used for the map projection. Defaults to None.</p> <code>None</code> <code>value_range</code> <code>ValueRangeLike | None</code> <p>Min and max range for the variable values; ignored if <code>var</code> is None. Defaults to None.</p> <code>'default'</code> <code>log_scale</code> <code>bool | None</code> <p>Whether to apply a logarithmic color scale to the variable. Defaults to None.</p> <code>None</code> <code>norm</code> <code>Normalize | None</code> <p>Matplotlib norm to use for color scaling. Defaults to None.</p> <code>None</code> <code>colorbar</code> <code>bool</code> <p>Whether to display a colorbar for the variable. Defaults to True.</p> <code>True</code> <code>pad</code> <code>float | list[float] | None</code> <p>Padding around the map extent; ignored if <code>extent</code> is given. Defaults to None.</p> <code>None</code> <code>show_text_time</code> <code>bool | None</code> <p>Whether to display the UTC time start and end of the selected track. Defaults to None.</p> <code>None</code> <code>show_text_frame</code> <code>bool | None</code> <p>Whether to display EarthCARE frame information. Defaults to None.</p> <code>None</code> <code>show_text_overpass</code> <code>bool | None</code> <p>Whether to display overpass site name and related info. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MapFigure</code> <code>MapFigure</code> <p>The figure object containing the map with track or swath.</p> Example <pre><code>import earthcarekit as eck\n\nfilepath = \"path/to/mydata/ECA_EXAE_ATL_NOM_1B_20250606T132535Z_20250606T150730Z_05813D.h5\"\nwith eck.read_product(filepath) as ds:\n    mf = eck.MapFigure()\n    mf = mf.ecplot(ds)\n</code></pre> Source code in <code>earthcarekit/plot/figure/map.py</code> <pre><code>def ecplot(\n    self,\n    ds: xr.Dataset,\n    var: str | None = None,\n    *,\n    lat_var: str = TRACK_LAT_VAR,\n    lon_var: str = TRACK_LON_VAR,\n    swath_lat_var: str = SWATH_LAT_VAR,\n    swath_lon_var: str = SWATH_LON_VAR,\n    time_var: str = TIME_VAR,\n    along_track_dim: str = ALONG_TRACK_DIM,\n    across_track_dim: str = ACROSS_TRACK_DIM,\n    site: str | GroundSite | None = None,\n    radius_km: float = 100.0,\n    time_range: TimeRangeLike | None = None,\n    view: Literal[\"global\", \"data\", \"overpass\"] = \"global\",\n    zoom_tmin: TimestampLike | None = None,\n    zoom_tmax: TimestampLike | None = None,\n    color: ColorLike | None = \"ec:earthcare\",\n    linewidth: float = 3,\n    linestyle: str | None = \"solid\",\n    color2: ColorLike | None = \"ec:blue\",\n    linewidth2: float | None = None,\n    linestyle2: str | None = None,\n    cmap: str | Cmap | None = None,\n    zoom_radius_km: float | None = None,\n    extent: list[float] | None = None,\n    central_latitude: float | None = None,\n    central_longitude: float | None = None,\n    value_range: ValueRangeLike | Literal[\"default\"] | None = \"default\",\n    log_scale: bool | None = None,\n    norm: Normalize | None = None,\n    colorbar: bool = True,\n    pad: float | list[float] | None = None,\n    show_text_time: bool | None = None,\n    show_text_frame: bool | None = None,\n    show_text_overpass: bool | None = None,\n    colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"bottom\",\n    colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n    colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n    colorbar_spacing: float = 0.3,\n    colorbar_length_ratio: float | str = \"100%\",\n    colorbar_label_outside: bool = True,\n    colorbar_ticks_outside: bool = True,\n    colorbar_ticks_both: bool = False,\n    selection_max_time_margin: (\n        TimedeltaLike | Sequence[TimedeltaLike] | None\n    ) = None,\n) -&gt; \"MapFigure\":\n    \"\"\"\n    Plot the EarthCARE satellite track on a map, optionally showing a 2D swath variable if `var` is provided.\n\n    This method collects all required data from an EarthCARE `xarray.Dataset`.\n    If `var` is given, the corresponding swath variable is plotted on the map using a\n    color scale. Otherwise, the satellite ground track is plotted as a colored line.\n    If `time_range` or `site` is given, the selected track section within the selected time range or in proximity to ground sites are highlighted.\n\n    Args:\n        ds (xr.Dataset): The EarthCARE dataset from which data will be plotted.\n        var (str | None, optional): Name of a 2D swath variable to plot. If None, only the satellite ground track is shown. Defaults to None.\n        lat_var (str, optional): Name of the latitude variable for the along-track data. Defaults to TRACK_LAT_VAR.\n        lon_var (str, optional): Name of the longitude variable for the along-track data. Defaults to TRACK_LON_VAR.\n        swath_lat_var (str, optional): Name of the latitude variable for the swath. Defaults to SWATH_LAT_VAR.\n        swath_lon_var (str, optional): Name of the longitude variable for the swath. Defaults to SWATH_LON_VAR.\n        time_var (str, optional): Name of the time variable. Defaults to TIME_VAR.\n        along_track_dim (str, optional): Dimension name representing the along-track direction. Defaults to ALONG_TRACK_DIM.\n        across_track_dim (str, optional): Dimension name representing the across-track direction. Defaults to ACROSS_TRACK_DIM.\n        site (str | GroundSite | None, optional): Highlights data within `radius_km` of a ground site (given either as a `GroundSite` object or name string); ignored if not set. Defaults to None.\n        radius_km (float, optional): Radius around the ground site to highlight data from; ignored if `site` not set. Defaults to 100.0.\n        time_range (TimeRangeLike | None, optional): Time range to highlight as selection area; ignored if `site` is set. Defaults to None.\n        view (Literal[\"global\", \"data\", \"overpass\"], optional): Map extent mode: \"global\" for full world, \"data\" for tight bounds, or \"overpass\" to zoom around `site` or time range. Defaults to \"global\".\n        zoom_tmin (TimestampLike | None, optional): Optional lower time bound used for zooming map around track. Defaults to None.\n        zoom_tmax (TimestampLike | None, optional): Optional upper time bound used for zooming map around track. Defaults to None.\n        color (ColorLike | None, optional): Color used for selected section of the track or entire track if no selection. Defaults to \"ec:earthcare\".\n        linewidth (float, optional): Line width for selected track section. Defaults to 3.\n        linestyle (str | None, optional): Line style for selected track section. Defaults to \"solid\".\n        color2 (ColorLike | None, optional): Color used for unselected sections of the track. Defaults to \"ec:blue\".\n        linewidth2 (float, optional): Line width for unselected sections. Defaults to None.\n        linestyle2 (str | None, optional): Line style for unselected sections. Defaults to None.\n        cmap (str | Cmap | None, optional): Colormap to use when plotting a swath variable. Defaults to None.\n        zoom_radius_km (float | None, optional): If set, overrides map extent derived from `view` to use a fixed radius around the site or selection. Defaults to None.\n        extent (list[float] | None, optional): Map extent in the form [lon_min, lon_max, lat_min, lat_max]. If given, overrides map extent derived from `view`. Defaults to None.\n        central_latitude (float | None, optional): Central latitude used for the map projection. Defaults to None.\n        central_longitude (float | None, optional): Central longitude used for the map projection. Defaults to None.\n        value_range (ValueRangeLike | None, optional): Min and max range for the variable values; ignored if `var` is None. Defaults to None.\n        log_scale (bool | None, optional): Whether to apply a logarithmic color scale to the variable. Defaults to None.\n        norm (Normalize | None, optional): Matplotlib norm to use for color scaling. Defaults to None.\n        colorbar (bool, optional): Whether to display a colorbar for the variable. Defaults to True.\n        pad (float | list[float] | None, optional): Padding around the map extent; ignored if `extent` is given. Defaults to None.\n        show_text_time (bool | None, optional): Whether to display the UTC time start and end of the selected track. Defaults to None.\n        show_text_frame (bool | None, optional): Whether to display EarthCARE frame information. Defaults to None.\n        show_text_overpass (bool | None, optional): Whether to display overpass site name and related info. Defaults to None.\n\n    Returns:\n        MapFigure: The figure object containing the map with track or swath.\n\n    Example:\n        ```python\n        import earthcarekit as eck\n\n        filepath = \"path/to/mydata/ECA_EXAE_ATL_NOM_1B_20250606T132535Z_20250606T150730Z_05813D.h5\"\n        with eck.read_product(filepath) as ds:\n            mf = eck.MapFigure()\n            mf = mf.ecplot(ds)\n        ```\n    \"\"\"\n    if pad is not None:\n        self.pad = _validate_pad(pad)\n    if show_text_time is not None:\n        self.show_text_time = show_text_time\n    if show_text_frame is not None:\n        self.show_text_frame = show_text_frame\n    if show_text_overpass is not None:\n        self.show_text_overpass = show_text_overpass\n\n    _lat_var: str = lat_var\n    _lon_var: str = lon_var\n\n    _linewidth: float = linewidth\n    _linewidth2: float\n    if isinstance(linewidth2, (float, int)):\n        _linewidth2 = float(linewidth2)\n    else:\n        _linewidth2 = linewidth * 0.7\n\n    if isinstance(var, str):\n        ds = ensure_updated_msi_rgb_if_required(\n            ds, var, time_range, time_var=time_var\n        )\n        _linewidth = linewidth * 0.5\n        linestyle = \"dashed\"\n        _linewidth2 = linewidth * 0.2\n        if all_in(\n            (along_track_dim, across_track_dim), [str(d) for d in ds[var].dims]\n        ):\n            _lat_var = swath_lat_var\n            _lon_var = swath_lon_var\n\n    _site: GroundSite | None = None\n    if isinstance(site, GroundSite):\n        _site = site\n    elif isinstance(site, str):\n        _site = get_ground_site(site)\n\n    coords_whole_flight = get_coords(ds, lat_var=lat_var, lon_var=lon_var)\n\n    if time_range is not None:\n        if zoom_tmin is None and time_range[0] is not None:\n            zoom_tmin = to_timestamp(time_range[0])\n        if zoom_tmax is None and time_range[1] is not None:\n            zoom_tmax = to_timestamp(time_range[1])\n    if zoom_tmin or zoom_tmax:\n        ds_zoomed_in = filter_time(ds, time_range=[zoom_tmin, zoom_tmax])\n        coords_zoomed_in = get_coords(\n            ds_zoomed_in, lat_var=_lat_var, lon_var=_lon_var, flatten=True\n        )\n        coords_zoomed_in_track = get_coords(\n            ds_zoomed_in, lat_var=lat_var, lon_var=lon_var\n        )\n    else:\n        coords_zoomed_in = coords_whole_flight\n        coords_zoomed_in_track = get_coords(ds, lat_var=lat_var, lon_var=lon_var)\n\n    is_polar_track: bool = False\n\n    if isinstance(_site, GroundSite):\n        ds_overpass = filter_radius(\n            ds,\n            radius_km=radius_km,\n            site=_site,\n            lat_var=lat_var,\n            lon_var=lon_var,\n            along_track_dim=along_track_dim,\n        )\n        info_overpass = get_overpass_info(\n            ds_overpass,\n            site_radius_km=radius_km,\n            site=_site,\n            time_var=time_var,\n            lat_var=lat_var,\n            lon_var=lon_var,\n            along_track_dim=along_track_dim,\n        )\n\n        _coords_whole_flight = coords_whole_flight.copy()\n        _selection_max_time_margin: tuple[pd.Timedelta, pd.Timedelta] | None = None\n\n        if selection_max_time_margin is not None:\n            if isinstance(selection_max_time_margin, str):\n                _selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin),\n                    to_timedelta(selection_max_time_margin),\n                )\n            elif isinstance(selection_max_time_margin, (Sequence, np.ndarray)):\n                _selection_max_time_margin = (\n                    to_timedelta(selection_max_time_margin[0]),\n                    to_timedelta(selection_max_time_margin[1]),\n                )\n            else:\n                raise ValueError(\n                    f\"invalid selection_max_time_margin: {selection_max_time_margin}\"\n                )\n\n            _ds = filter_time(\n                ds=ds,\n                time_range=(\n                    to_timestamp(ds_overpass[time_var].values[0])\n                    - _selection_max_time_margin[0],\n                    to_timestamp(ds_overpass[time_var].values[1])\n                    + _selection_max_time_margin[1],\n                ),\n                time_var=time_var,\n            )\n            _coords_whole_flight = get_coords(_ds, lat_var=lat_var, lon_var=lon_var)\n\n        coords_overpass = get_coords(ds_overpass, lat_var=lat_var, lon_var=lon_var)\n        _ = self._plot_overpass(\n            lat_selection=coords_overpass[:, 0],\n            lon_selection=coords_overpass[:, 1],\n            lat_total=_coords_whole_flight[:, 0],\n            lon_total=_coords_whole_flight[:, 1],\n            site=_site,\n            radius_km=radius_km,\n            view=view,\n            timestamp=info_overpass.closest_time,\n            color_selection=color,\n            linewidth_selection=_linewidth,\n            linestyle_selection=linestyle,\n            color_total=color2,\n            linewidth_total=_linewidth2,\n            linestyle_total=linestyle2,\n            show_highlights=view == \"overpass\"\n            or not isinstance(_selection_max_time_margin, tuple),\n            radius_color=None,\n        )\n\n        if isinstance(_selection_max_time_margin, tuple):\n            self.plot_track(\n                latitude=coords_whole_flight[:, 0],\n                longitude=coords_whole_flight[:, 1],\n                color=\"white\",\n                linestyle=\"solid\",\n                linewidth=2,\n                highlight_first=False,\n                highlight_last=True,\n                zorder=3,\n            )\n\n        if view == \"overpass\":\n            if self.show_text_overpass:\n                add_text_overpass_info(self.ax, info_overpass)\n        if self.show_text_time:\n            add_title_earthcare_time(\n                self.ax, tmin=info_overpass.start_time, tmax=info_overpass.end_time\n            )\n    else:\n        if isinstance(central_latitude, (int, float)):\n            self.central_latitude = central_latitude\n        else:\n            self.central_latitude = np.nanmean(coords_zoomed_in_track[:, 0])\n        if isinstance(central_longitude, (int, float)):\n            self.central_longitude = central_longitude\n        else:\n            if not ismonotonic(coords_whole_flight[:, 0]):\n                is_polar_track = True\n                self.central_longitude = coords_whole_flight[-1, 1]\n            else:\n                self.central_longitude = circular_nanmean(coords_whole_flight[:, 1])\n        logger.debug(\n            f\"Set central coords to (lat={self.central_latitude}, lon={self.central_longitude})\"\n        )\n\n        time = ds[time_var].values\n        timestamp = time[len(time) // 2]\n        self.timestamp = to_timestamp(timestamp)\n        if view == \"overpass\":\n            self.lod = get_osm_lod(coords_zoomed_in[0], coords_zoomed_in[-1])\n            if extent is None:\n                extent = compute_bbox(coords_zoomed_in)\n                self.extent = extent\n        pos = self.ax.get_position()\n        self.fig.delaxes(self.ax)\n        self.ax = self.fig.add_axes(pos)  # type: ignore\n        self._init_axes()\n        if time_range is not None:\n            _highlight_last = view in [\"global\", \"data\"]\n            _ = self.plot_track(\n                latitude=coords_whole_flight[:, 0],\n                longitude=coords_whole_flight[:, 1],\n                linewidth=_linewidth2,\n                linestyle=linestyle,\n                highlight_first=False,\n                highlight_last=_highlight_last,\n                color=color2,\n            )\n\n            _highlight_last = view == \"overpass\"\n            _ = self.plot_track(\n                latitude=coords_zoomed_in_track[:, 0],\n                longitude=coords_zoomed_in_track[:, 1],\n                linewidth=_linewidth,\n                linestyle=linestyle,\n                highlight_first=False,\n                highlight_last=_highlight_last,\n                color=color,\n            )\n        else:\n            _ = self.plot_track(\n                latitude=coords_whole_flight[:, 0],\n                longitude=coords_whole_flight[:, 1],\n                linewidth=_linewidth,\n                linestyle=linestyle,\n                highlight_first=False,\n                highlight_last=True,\n                color=color,\n            )\n        self.ax.axis(\"equal\")\n        if view == \"global\":\n            self.ax.set_global()  # type: ignore\n        elif view == \"data\":\n            _lats = coords_whole_flight[:, 0]\n            if is_polar_track:\n                _lats = np.nanmin(_lats)\n            if isinstance(self.projection, ccrs.PlateCarree) or not is_polar_track:\n                self.set_view(lats=_lats, lons=coords_whole_flight[:, 1])\n            else:\n                _dist = haversine(\n                    (self.central_latitude, self.central_longitude),  # type: ignore\n                    coords_whole_flight[0],\n                    units=\"m\",\n                )\n                self.ax.set_xlim(-_dist / 2, _dist / 2)\n                if coords_whole_flight[0, 0] &lt; coords_whole_flight[1, 0]:\n                    self.ax.set_ylim(-_dist / 2, _dist)\n                else:\n                    self.ax.set_ylim(-_dist, _dist / 2)\n        else:\n            _lats = coords_zoomed_in[:, 0]\n            if is_polar_track:\n                _lats = np.nanmin(_lats)\n            if isinstance(self.projection, ccrs.PlateCarree) or not is_polar_track:\n                self.set_view(lats=_lats, lons=coords_zoomed_in[:, 1])\n            else:\n                _dist = haversine(\n                    (self.central_latitude, self.central_longitude),  # type: ignore\n                    coords_zoomed_in[0],\n                    units=\"m\",\n                )\n                self.ax.set_xlim(-_dist / 2, _dist / 2)\n                if coords_zoomed_in[0, 0] &lt; coords_zoomed_in[1, 0]:\n                    self.ax.set_ylim(-_dist / 2, _dist)\n                else:\n                    self.ax.set_ylim(-_dist, _dist / 2)\n            # _lats = coords_zoomed_in[:, 0]\n            # if is_polar_track:\n            #     _lats = np.nanmin(_lats)\n            # self.set_view(lats=_lats, lons=coords_zoomed_in[:, 1])\n\n        if self.show_text_time:\n            add_title_earthcare_time(self.ax, ds=ds, tmin=zoom_tmin, tmax=zoom_tmax)\n\n    if isinstance(var, str):\n        if cmap is None:\n            cmap = get_default_cmap(var, ds)\n        if isinstance(value_range, str) and value_range == \"default\":\n            value_range = None\n            if log_scale is None and norm is None:\n                norm = get_default_norm(var, file_type=ds)\n        lats = ds[swath_lat_var].values\n        lons = ds[swath_lon_var].values\n        values = ds[var].values\n        label = getattr(ds[var], \"long_name\", \"\")\n        units = getattr(ds[var], \"units\", \"\")\n        _ = self.plot_swath(\n            lats,\n            lons,\n            values,\n            cmap=cmap,\n            label=label,\n            units=units,\n            value_range=value_range,\n            log_scale=log_scale,\n            norm=norm,\n            colorbar=colorbar,\n            colorbar_position=colorbar_position,\n            colorbar_alignment=colorbar_alignment,\n            colorbar_width=colorbar_width,\n            colorbar_spacing=colorbar_spacing,\n            colorbar_length_ratio=colorbar_length_ratio,\n            colorbar_label_outside=colorbar_label_outside,\n            colorbar_ticks_outside=colorbar_ticks_outside,\n            colorbar_ticks_both=colorbar_ticks_both,\n        )\n\n    # if view == \"data\":\n    #     self.set_view(lats=lats, lons=lons)\n\n    # if zoom_tmin or zoom_tmax:\n    #     extent = compute_bbox(coords_zoomed_in)\n    #     self.ax.set_extent(extent, crs=ccrs.PlateCarree())  # type: ignore\n    if self.show_text_frame:\n        add_title_earthcare_frame(self.ax, ds=ds)\n\n    self.zoom(extent=extent, radius_km=zoom_radius_km)\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.MapFigure.save","title":"save","text":"<pre><code>save(\n    filename=\"\",\n    filepath=None,\n    ds=None,\n    ds_filepath=None,\n    dpi=\"figure\",\n    orbit_and_frame=None,\n    utc_timestamp=None,\n    use_utc_creation_timestamp=False,\n    site_name=None,\n    hmax=None,\n    radius=None,\n    extra=None,\n    transparent_outside=False,\n    verbose=True,\n    print_prefix=\"\",\n    create_dirs=False,\n    transparent_background=False,\n    resolution=None,\n    **kwargs\n)\n</code></pre> <p>Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure | HasFigure</code> <p>A figure object (<code>matplotlib.figure.Figure</code>) or objects exposing a <code>.fig</code> attribute containing a figure (e.g., <code>CurtainFigure</code>).</p> required <code>filename</code> <code>str</code> <p>The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.</p> <code>''</code> <code>filepath</code> <code>str | None</code> <p>The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.</p> <code>None</code> <code>ds</code> <code>Dataset | None</code> <p>A EarthCARE dataset from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>ds_filepath</code> <code>str | None</code> <p>A path to a EarthCARE product from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>pad</code> <code>float</code> <p>Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.</p> required <code>dpi</code> <code>float | figure</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.</p> <code>'figure'</code> <code>orbit_and_frame</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>utc_timestamp</code> <code>TimestampLike | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>use_utc_creation_timestamp</code> <code>bool</code> <p>Whether the time of image creation should be included in the file name. Defaults to False.</p> <code>False</code> <code>site_name</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>hmax</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>radius</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>extra</code> <code>str | None</code> <p>A custom string to be included in the file name. Defaults to None.</p> <code>None</code> <code>transparent_outside</code> <code>bool</code> <p>Whether the area outside figures should be transparent. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether the progress of image creation should be printed to the console. Defaults to True.</p> <code>True</code> <code>print_prefix</code> <code>str</code> <p>A prefix string to all console messages. Defaults to \"\".</p> <code>''</code> <code>create_dirs</code> <code>bool</code> <p>Whether images should be saved in a folder structure based on provided metadata. Defaults to False.</p> <code>False</code> <code>transparent_background</code> <code>bool</code> <p>Whether the background inside and outside of figures should be transparent. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments passed to wrapped function call of <code>matplotlib.pyplot.savefig</code>.</p> <code>{}</code> Source code in <code>earthcarekit/plot/figure/map.py</code> <pre><code>def save(\n    self,\n    filename: str = \"\",\n    filepath: str | None = None,\n    ds: xr.Dataset | None = None,\n    ds_filepath: str | None = None,\n    dpi: float | Literal[\"figure\"] = \"figure\",\n    orbit_and_frame: str | None = None,\n    utc_timestamp: TimestampLike | None = None,\n    use_utc_creation_timestamp: bool = False,\n    site_name: str | None = None,\n    hmax: int | float | None = None,\n    radius: int | float | None = None,\n    extra: str | None = None,\n    transparent_outside: bool = False,\n    verbose: bool = True,\n    print_prefix: str = \"\",\n    create_dirs: bool = False,\n    transparent_background: bool = False,\n    resolution: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n    Args:\n        figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n        filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n        filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n        ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n        ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n        pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n        dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n        orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n        site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n        transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n        verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n        print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n        create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n        transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n        **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n    \"\"\"\n    save_plot(\n        fig=self.fig,\n        filename=filename,\n        filepath=filepath,\n        ds=ds,\n        ds_filepath=ds_filepath,\n        dpi=dpi,\n        orbit_and_frame=orbit_and_frame,\n        utc_timestamp=utc_timestamp,\n        use_utc_creation_timestamp=use_utc_creation_timestamp,\n        site_name=site_name,\n        hmax=hmax,\n        radius=radius,\n        extra=extra,\n        transparent_outside=transparent_outside,\n        verbose=verbose,\n        print_prefix=print_prefix,\n        create_dirs=create_dirs,\n        transparent_background=transparent_background,\n        resolution=resolution,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.MapFigure.to_texture","title":"to_texture","text":"<pre><code>to_texture(remove_images=True, remove_features=True)\n</code></pre> <p>Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.</p> Source code in <code>earthcarekit/plot/figure/map.py</code> <pre><code>def to_texture(\n    self, remove_images: bool = True, remove_features: bool = True\n) -&gt; \"MapFigure\":\n    \"\"\"Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.\"\"\"\n    # Remove anchored text and other artist text objects\n    for artist in reversed(self.ax.artists):\n        if isinstance(artist, (Text, AnchoredOffsetbox)):\n            artist.remove()\n\n    # Completely remove axis ticks and labels\n    self.ax.axis(\"off\")\n\n    # Remove white frame around figure\n    self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n    # Remove ticks, tick labels, and gridlines\n    self.ax.set_xticks([])\n    self.ax.set_yticks([])\n    self.ax.xaxis.set_ticklabels([])\n    self.ax.yaxis.set_ticklabels([])\n    self.ax.grid(False)\n\n    # Remove outline box around map\n    self.ax.spines[\"geo\"].set_visible(False)\n\n    # Make the map fill the whole figure\n    self.ax.set_position((0.0, 0.0, 1.0, 1.0))\n\n    if self.colorbar:\n        self.colorbar.remove()\n\n    if self.grid_lines:\n        self.grid_lines.remove()\n\n    if remove_images:\n        for img in self.ax.get_images():\n            img.remove()\n\n    if remove_features:\n        for c in self.ax.get_children():\n            if isinstance(c, FeatureArtist):\n                c.remove()\n\n    # for c in self.ax.get_children():\n    #     if isinstance(c, _ViewClippedPathPatch):\n    #         c.set_alpha(0)\n\n    for c in self.fig.get_children():\n        if isinstance(c, Rectangle):\n            c.set_alpha(0)\n\n    self.ax.set_facecolor(\"none\")\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProductInfo","title":"ProductInfo  <code>dataclass</code>","text":"<p>Class storing all info gathered from a EarthCARE product's file path.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>@dataclass\nclass ProductInfo:\n    \"\"\"Class storing all info gathered from a EarthCARE product's file path.\"\"\"\n\n    mission_id: FileMissionID\n    agency: FileAgency\n    latency: FileLatency\n    baseline: str\n    file_type: FileType\n    start_sensing_time: pd.Timestamp\n    start_processing_time: pd.Timestamp\n    orbit_number: int\n    frame_id: str\n    orbit_and_frame: str\n    name: str\n    filepath: str\n    hdr_filepath: str\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns data stored in `ProductInfo` as a `dict`.\"\"\"\n        return asdict(self)\n\n    def to_dataframe(self) -&gt; \"ProductDataFrame\":\n        return ProductDataFrame([self])\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProductInfo.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Returns data stored in <code>ProductInfo</code> as a <code>dict</code>.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns data stored in `ProductInfo` as a `dict`.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData","title":"ProfileData  <code>dataclass</code>","text":"<p>Container for atmospheric profile data.</p> <p>Stores profile values together with their time/height bins and, optionally, their coordinates and metadata in a consistent structure, making profiles easier to handle, compare and visualise.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>NDArray</code> <p>Profile data, either a single vertical profile or a time series of profiles (time x height).</p> <code>height</code> <code>NDArray</code> <p>Height bin centers, ascending. Can be fixed or vary with time.</p> <code>time</code> <code>NDArray</code> <p>Timestamps corresponding to each profile.</p> <code>latitude</code> <code>NDArray | None</code> <p>Ground latitudes for the profiles, optional.</p> <code>longitude</code> <code>NDArray | None</code> <p>Ground longitudes for the profiles, optional.</p> <code>color</code> <code>str | None</code> <p>Color for plotting, optional.</p> <code>label</code> <code>str | None</code> <p>Variable label for plot annotations, optional.</p> <code>units</code> <code>str | None</code> <p>Units for plot annotations, optional.</p> <code>platform</code> <code>str | None</code> <p>Name or type of measurement platform/instrument, optional.</p> <code>error</code> <code>NDArray | None</code> <p>Associated uncertainties for the profile values, optional.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>@dataclass\nclass ProfileData:\n    \"\"\"Container for atmospheric profile data.\n\n    Stores profile values together with their time/height bins and,\n    optionally, their coordinates and metadata in a consistent structure,\n    making profiles easier to handle, compare and visualise.\n\n    Attributes:\n        values (NDArray): Profile data, either a single vertical profile\n            or a time series of profiles (time x height).\n        height (NDArray): Height bin centers, ascending. Can be fixed or\n            vary with time.\n        time (NDArray): Timestamps corresponding to each profile.\n        latitude (NDArray | None): Ground latitudes for the profiles, optional.\n        longitude (NDArray | None): Ground longitudes for the profiles, optional.\n        color (str | None): Color for plotting, optional.\n        label (str | None): Variable label for plot annotations, optional.\n        units (str | None): Units for plot annotations, optional.\n        platform (str | None): Name or type of measurement platform/instrument,\n            optional.\n        error (NDArray | None): Associated uncertainties for the profile\n            values, optional.\n    \"\"\"\n\n    values: NDArray\n    height: NDArray\n    time: NDArray\n    latitude: NDArray | None = None\n    longitude: NDArray | None = None\n    color: str | None = None\n    label: str | None = None\n    units: str | None = None\n    platform: str | None = None\n    error: NDArray | None = None\n\n    def __post_init__(self: \"ProfileData\") -&gt; None:\n\n        is_increasing: bool = False\n        if isinstance(self.height, Iterable):\n            self.height = np.asarray(self.height)\n            mask_nan_heights = ~np.isnan(np.atleast_2d(self.height)).any(axis=0)\n            self.height = _apply_nan_height_mask(self.height, mask_nan_heights)\n            is_increasing = ismonotonic(self.height, mode=\"increasing\")\n            if not is_increasing:\n                if len(self.height.shape) == 2:\n                    self.height = self.height[:, ::-1]\n                else:\n                    self.height = self.height[::-1]\n        if isinstance(self.values, Iterable):\n            self.values = np.atleast_2d(self.values)\n            self.values = _apply_nan_height_mask(self.values, mask_nan_heights)\n            if not is_increasing:\n                self.values = self.values[:, ::-1]\n        if isinstance(self.time, Iterable):\n            self.time = pd.to_datetime(np.asarray(self.time)).to_numpy()\n        if isinstance(self.latitude, Iterable):\n            self.latitude = np.asarray(self.latitude)\n        if isinstance(self.longitude, Iterable):\n            self.longitude = np.asarray(self.longitude)\n        if isinstance(self.error, Iterable):\n            self.error = np.atleast_2d(self.error)\n            self.error = _apply_nan_height_mask(self.error, mask_nan_heights)\n            if not is_increasing:\n                self.error = self.error[:, ::-1]\n            if self.values.shape != self.error.shape:\n                raise ValueError(\n                    f\"`error` must have same shape as `values`: values.shape={self.values.shape} != error.shape={self.error.shape}\"\n                )\n        if isinstance(self.units, str):\n            self.units = parse_units(self.units)\n\n        validate_profile_data_dimensions(\n            values=self.values,\n            height=self.height,\n            time=self.time,\n            latitude=self.latitude,\n            longitude=self.longitude,\n        )\n\n    @property\n    def shape(self):\n        return self.values.shape\n\n    def __add__(self, other):\n        result = self.copy()\n        result.values = result.values + other.values\n        return result\n\n    def __sub__(self, other):\n        result = self.copy()\n        result.values = result.values - other.values\n        return result\n\n    def __mul__(self, other):\n        result = self.copy()\n        if isinstance(other, ProfileData):\n            result.values = result.values * other.values\n            return result\n        else:\n            result.values = result.values * other\n            return result\n\n    def __truediv__(self, other):\n        result = self.copy()\n        if isinstance(other, ProfileData):\n            result.values = result.values / other.values\n            return result\n        else:\n            result.values = result.values / other\n            return result\n\n    def __pow__(self, other):\n        result = self.copy()\n        if isinstance(other, ProfileData):\n            result.values = result.values**other.values\n            return result\n        else:\n            result.values = result.values**other\n            return result\n\n    def __eq__(self, other):\n        if isinstance(other, (np.ndarray, Number)):\n            return self.values == other\n        if not isinstance(other, ProfileData):\n            raise TypeError(\"Can only compare two ProfileData instances\")\n        return self.values == other.values\n\n    def __lt__(self, other):\n        if isinstance(other, (np.ndarray, Number)):\n            return self.values &lt; other\n        if not isinstance(other, ProfileData):\n            raise TypeError(\"Can only compare two ProfileData instances\")\n        return self.values &lt; other.values\n\n    def __le__(self, other):\n        if isinstance(other, (np.ndarray, Number)):\n            return self.values &lt;= other\n        if not isinstance(other, ProfileData):\n            raise TypeError(\"Can only compare two ProfileData instances\")\n        return self.values &lt;= other.values\n\n    def __gt__(self, other):\n        if isinstance(other, (np.ndarray, Number)):\n            return self.values &gt; other\n        if not isinstance(other, ProfileData):\n            raise TypeError(\"Can only compare two ProfileData instances\")\n        return self.values &gt; other.values\n\n    def __ge__(self, other):\n        if isinstance(other, (np.ndarray, Number)):\n            return self.values &gt;= other\n        if not isinstance(other, ProfileData):\n            raise TypeError(\"Can only compare two ProfileData instances\")\n        return self.values &gt;= other.values\n\n    @classmethod\n    def from_dataset(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        error_var: str | None = None,\n        height_var: str = HEIGHT_VAR,\n        time_var: str = TIME_VAR,\n        lat_var: str = TRACK_LAT_VAR,\n        lon_var: str = TRACK_LON_VAR,\n        color: str | None = None,\n        label: str | None = None,\n        units: str | None = None,\n        platform: str | None = None,\n    ) -&gt; \"ProfileData\":\n        values = ds[var].values\n        height = ds[height_var].values\n        time = ds[time_var].values\n\n        latitude: NDArray | None = None\n        if lat_var in ds:\n            latitude = ds[lat_var].values\n\n        longitude: NDArray | None = None\n        if lon_var in ds:\n            longitude = ds[lon_var].values\n\n        if not isinstance(label, str):\n            label = None if not hasattr(ds[var], \"long_name\") else ds[var].long_name\n\n        if not isinstance(label, str):\n            label = None if not hasattr(ds[var], \"name\") else ds[var].name  # type: ignore\n\n        if not isinstance(label, str):\n            label = None if not hasattr(ds[var], \"label\") else ds[var].label\n\n        if not isinstance(units, str):\n            units = None if not hasattr(ds[var], \"units\") else ds[var].units\n\n        if not isinstance(units, str):\n            units = None if not hasattr(ds[var], \"unit\") else ds[var].unit\n\n        error: NDArray | None = None\n        if isinstance(error_var, str):\n            error = ds[error_var].values\n\n        return ProfileData(\n            values=values,\n            height=height,\n            time=time,\n            latitude=latitude,\n            longitude=longitude,\n            color=color,\n            label=label,\n            units=units,\n            platform=platform,\n            error=error,\n        )\n\n    def print_shapes(self):\n        if isinstance(self.values, Iterable):\n            print(f\"values={self.values.shape}\")\n        if isinstance(self.height, Iterable):\n            print(f\"height={self.height.shape}\")\n        if isinstance(self.time, Iterable):\n            print(f\"time={self.time.shape}\")\n        if isinstance(self.latitude, Iterable):\n            print(f\"latitude={self.latitude.shape}\")\n        if isinstance(self.longitude, Iterable):\n            print(f\"longitude={self.longitude.shape}\")\n\n    def mean(self) -&gt; \"ProfileData\":\n        \"\"\"Returns mean profile.\"\"\"\n        new_values = _mean_2d(self.values)\n        new_height = _mean_2d(self.height)\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = _mean_2d(self.error)\n\n        if isinstance(self.time, np.ndarray):\n            new_time = _mean_1d(self.time)\n        else:\n            new_time = None\n\n        if isinstance(self.latitude, np.ndarray):\n            new_latitude = _mean_1d(self.latitude)\n        else:\n            new_latitude = None\n\n        if isinstance(self.longitude, np.ndarray):\n            new_longitude = _mean_1d(self.longitude)\n        else:\n            new_longitude = None\n\n        new_color = self.color\n        new_label = self.label\n        new_units = self.units\n        new_platform = self.platform\n\n        return ProfileData(\n            values=new_values,\n            height=new_height,\n            time=new_time,\n            latitude=new_latitude,\n            longitude=new_longitude,\n            color=new_color,\n            label=new_label,\n            units=new_units,\n            platform=new_platform,\n            error=new_error,\n        )\n\n    def std(self) -&gt; \"ProfileData\":\n        \"\"\"Returns standard deviation profile.\"\"\"\n        new_values = _std_2d(self.values)\n        new_height = _mean_2d(self.height)\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = _mean_2d(self.error)\n\n        if isinstance(self.time, np.ndarray):\n            new_time = _mean_1d(self.time)\n        else:\n            new_time = None\n\n        if isinstance(self.latitude, np.ndarray):\n            new_latitude = _mean_1d(self.latitude)\n        else:\n            new_latitude = None\n\n        if isinstance(self.longitude, np.ndarray):\n            new_longitude = _mean_1d(self.longitude)\n        else:\n            new_longitude = None\n\n        new_color = self.color\n        new_label = self.label\n        new_units = self.units\n        new_platform = self.platform\n\n        return ProfileData(\n            values=new_values,\n            height=new_height,\n            time=new_time,\n            latitude=new_latitude,\n            longitude=new_longitude,\n            color=new_color,\n            label=new_label,\n            units=new_units,\n            platform=new_platform,\n            error=new_error,\n        )\n\n    def rolling_mean(self, window_size: int, axis: Literal[0, 1] = 0) -&gt; \"ProfileData\":\n        \"\"\"Returns mean profile.\"\"\"\n        if len(self.values.shape) == 2:\n            new_values = rolling_mean_2d(self.values, w=window_size, axis=axis)\n            new_error: NDArray | None = None\n            if isinstance(self.error, np.ndarray):\n                new_error = self.error\n            return ProfileData(\n                values=new_values,\n                height=self.height,\n                time=self.time,\n                latitude=self.latitude,\n                longitude=self.longitude,\n                color=self.color,\n                label=self.label,\n                units=self.units,\n                platform=self.platform,\n                error=new_error,\n            )\n\n        msg = f\"VerticalProfile contains only one profile and thus {self.rolling_mean.__name__}() is not applied.\"\n        warnings.warn(msg)\n        return self\n\n    def layer_mean(self, hmin: float, hmax: float) -&gt; NDArray:\n        \"\"\"Returns layer mean values.\"\"\"\n        layer_mask = np.logical_and(hmin &lt;= self.height, self.height &lt;= hmax)\n        layer_mean_values = self.values\n        layer_mean_values[~layer_mask] = np.nan\n        if len(layer_mean_values.shape) == 2:\n            layer_mean_values = _mean_2d(layer_mean_values, axis=1)\n        else:\n            layer_mean_values = np.array(nan_mean(layer_mean_values))\n        return layer_mean_values\n\n    def rebin_height(\n        self,\n        height_bin_centers: Iterable[float] | NDArray,\n        method: Literal[\"interpolate\", \"mean\"] = \"mean\",\n    ) -&gt; \"ProfileData\":\n        \"\"\"\n        Rebins profiles to new height bins.\n\n        Parameters:\n            new_height (np.ndarray):\n                Target height bin centers as a 1D array (shape represents vertical dimension)\n\n        Returns:\n            rebinned_profiles (VerticalProfiles):\n                Profiles rebinned along the vertical dimension according to `height_bin_centers`.\n        \"\"\"\n        if self.height.shape == np.array(height_bin_centers).shape and np.all(\n            np.array(self.height) == np.array(height_bin_centers)\n        ):\n            return ProfileData(\n                values=self.values,\n                height=self.height,\n                time=self.time,\n                latitude=self.latitude,\n                longitude=self.longitude,\n                color=self.color,\n                label=self.label,\n                units=self.units,\n                platform=self.platform,\n                error=self.error,\n            )\n\n        new_values = rebin_height(\n            self.values,\n            self.height,\n            height_bin_centers,\n            method=method,\n        )\n        new_height = np.asarray(height_bin_centers)\n        if len(new_values.shape) == 2:\n            new_height = np.atleast_2d(new_height)\n            if new_height.shape[0] == 1:\n                new_height = new_height[0]\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = rebin_height(\n                self.error,\n                self.height,\n                height_bin_centers,\n                method=method,\n            )\n        return ProfileData(\n            values=new_values,\n            height=new_height,\n            time=self.time,\n            latitude=self.latitude,\n            longitude=self.longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=new_error,\n        )\n\n    def rebin_time(\n        self,\n        time_bin_centers: Sequence[TimestampLike] | ArrayLike,\n        method: Literal[\"interpolate\", \"mean\"] = \"mean\",\n    ) -&gt; \"ProfileData\":\n        \"\"\"\n        Rebins profiles to new time bins.\n\n        Args:\n            time_bin_centers (Iterable[TimestampLike] | ArrayLike):\n                Target time bin centers as a 1D array (shape represents temporal dimension)\n\n        Returns:\n            rebinned_profiles (VerticalProfiles):\n                Profiles rebinned along the temporal dimension according to `height_bin_centers`.\n        \"\"\"\n        time_bin_centers = to_timestamps(time_bin_centers)\n        new_values = rebin_time(self.values, self.time, time_bin_centers, method=method)\n        if len(self.height.shape) == 2:\n            new_height = rebin_time(\n                self.height, self.time, time_bin_centers, method=method\n            )\n        else:\n            new_height = self.height\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = rebin_time(\n                self.error, self.time, time_bin_centers, method=method\n            )\n\n        if isinstance(self.latitude, np.ndarray) and isinstance(\n            self.longitude, np.ndarray\n        ):\n            new_coords = rebin_time(\n                np.vstack([self.latitude, self.longitude]).T,\n                self.time,\n                time_bin_centers,\n                is_geo=True,\n                method=method,\n            )\n            new_latitude = new_coords[:, 0]\n            new_longitude = new_coords[:, 0]\n        else:\n            new_latitude = None\n            new_longitude = None\n        return ProfileData(\n            values=new_values,\n            height=new_height,\n            time=pd.to_datetime(to_timestamps(time_bin_centers)).to_numpy(),\n            latitude=new_latitude,\n            longitude=new_longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=new_error,\n        )\n\n    def rebin_along_track(\n        self,\n        latitude_bin_centers: ArrayLike,\n        longitude_bin_centers: ArrayLike,\n    ) -&gt; \"ProfileData\":\n        \"\"\"\n        Rebins profiles to new time bins.\n\n        Args:\n            latitude_bin_centers (ArrayLike):\n                Target time bin centers as a 1D array (shape represents temporal dimension)\n\n        Returns:\n            rebinned_profiles (VerticalProfiles):\n                Profiles rebinned along the temporal dimension according to `height_bin_centers`.\n        \"\"\"\n        has_lat = self.latitude is not None\n        has_lon = self.longitude is not None\n\n        if not has_lat or not has_lon:\n            missing = []\n            if not has_lat:\n                missing.append(\"latitude\")\n            if not has_lon:\n                missing.append(\"longitude\")\n            raise ValueError(\n                f\"{ProfileData.__name__} instance is missing {' and '.join(missing)} data\"\n            )\n\n        latitude_bin_centers = np.asarray(latitude_bin_centers)\n        longitude_bin_centers = np.asarray(longitude_bin_centers)\n\n        new_values = rebin_along_track(\n            self.values,\n            np.asarray(self.latitude),\n            np.asarray(self.longitude),\n            latitude_bin_centers,\n            longitude_bin_centers,\n        )\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = rebin_along_track(\n                self.error,\n                np.asarray(self.latitude),\n                np.asarray(self.longitude),\n                latitude_bin_centers,\n                longitude_bin_centers,\n            )\n        new_times = rebin_along_track(\n            self.time,\n            np.asarray(self.latitude),\n            np.asarray(self.longitude),\n            latitude_bin_centers,\n            longitude_bin_centers,\n        )\n        return ProfileData(\n            values=new_values,\n            height=self.height,\n            time=new_times,\n            latitude=np.array(latitude_bin_centers),\n            longitude=np.array(longitude_bin_centers),\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=new_error,\n        )\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns stored profile data as `dict`.\"\"\"\n        return asdict(self)\n\n    def select_height_range(\n        self,\n        height_range: DistanceRangeLike,\n        pad_idx: int = 0,\n    ) -&gt; \"ProfileData\":\n        \"\"\"\n        Returns only data within the specified `height_range`.\n\n        Args:\n            height_range (DistanceRangeLike): Pair of minimum and maximum height in meters.\n            pad_idx (int): Number of indexes that will be appended to the result before and after given height range. Defaults to 0.\n\n        Returns:\n            ProfileData: New instance of ProfileData filtered by given height range.\n        \"\"\"\n        height_range = validate_height_range(height_range)\n\n        if len(self.height.shape) == 2:\n            ref_height = self.height[0]\n        else:\n            ref_height = self.height\n\n        mask = np.logical_and(\n            height_range[0] &lt;= ref_height, ref_height &lt;= height_range[1]\n        )\n        mask = pad_true_sequence(mask, pad_idx)\n\n        sel_values = self.values[:, mask]\n        sel_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            sel_error = self.error[:, mask]\n\n        if len(self.height.shape) == 2:\n            sel_height = self.height[:, mask]\n        else:\n            sel_height = self.height[mask]\n\n        return ProfileData(\n            values=sel_values,\n            height=sel_height,\n            time=self.time,\n            latitude=self.latitude,\n            longitude=self.longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=sel_error,\n        )\n\n    def select_time_range(\n        self,\n        time_range: TimeRangeLike | None,\n        pad_idxs: int = 0,\n    ) -&gt; \"ProfileData\":\n        \"\"\"\n        Returns only data within the specified `time_range`.\n\n        Args:\n            time_range (TimeRangeLike | None): Pair of minimum and maximum timestamps or None.\n            pad_idx (int): Number of indexes that will be appended to the result before and after given time range. Defaults to 0.\n\n        Returns:\n            ProfileData: New instance of ProfileData filtered by given time range.\n        \"\"\"\n        if time_range is None:\n            return self\n        elif not isinstance(self.time, np.ndarray):\n            raise ValueError(\n                f\"{ProfileData.__name__}.{self.select_time_range.__name__}() missing `time` data\"\n            )\n\n        time_range = validate_time_range(time_range)\n\n        times = to_timestamps(self.time)\n        mask = np.logical_and(time_range[0] &lt;= times, times &lt;= time_range[1])\n        mask = pad_true_sequence(mask, pad_idxs)\n\n        sel_values = self.values[mask]\n        sel_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            sel_error = self.error[:, mask]\n        sel_time = self.time[mask]\n\n        if len(self.height.shape) == 2:\n            sel_height = self.height[mask]\n        else:\n            sel_height = self.height\n\n        if isinstance(self.latitude, np.ndarray):\n            sel_latitude = self.latitude[mask]\n        else:\n            sel_latitude = None\n\n        if isinstance(self.longitude, np.ndarray):\n            sel_longitude = self.longitude[mask]\n        else:\n            sel_longitude = None\n\n        return ProfileData(\n            values=sel_values,\n            height=sel_height,\n            time=sel_time,\n            latitude=sel_latitude,\n            longitude=sel_longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=sel_error,\n        )\n\n    def coarsen_mean(self, n: int, is_bin: bool = False) -&gt; \"ProfileData\":\n        \"\"\"Returns downsampled profile data.\"\"\"\n        if len(self.values.shape) == 2:\n            new_values: NDArray\n            new_values = coarsen_mean(self.values, n=n, is_bin=is_bin)\n            new_error: NDArray | None = None\n            if isinstance(self.error, np.ndarray):\n                new_error = coarsen_mean(self.error, n=n, is_bin=is_bin)\n            new_time: NDArray = coarsen_mean(self.time, n=n)\n\n            new_height: NDArray\n            if len(self.height.shape) == 2:\n                new_height = coarsen_mean(self.height, n=n)\n            else:\n                new_height = self.height\n\n            new_latitude: NDArray | None\n            if isinstance(self.latitude, np.ndarray):\n                new_latitude = coarsen_mean(self.latitude, n=n)\n            else:\n                new_latitude = None\n\n            new_longitude: NDArray | None\n            if isinstance(self.longitude, np.ndarray):\n                new_longitude = coarsen_mean(self.longitude, n=n)\n            else:\n                new_longitude = None\n\n            return ProfileData(\n                values=new_values,\n                height=new_height,\n                time=new_time,\n                latitude=new_latitude,\n                longitude=new_longitude,\n                color=self.color,\n                label=self.label,\n                units=self.units,\n                platform=self.platform,\n                error=new_error,\n            )\n\n        msg = f\"VerticalProfile contains only one profile and thus {self.coarsen_mean.__name__}() is not applied.\"\n        warnings.warn(msg)\n        return self\n\n    def stats(\n        self,\n        height_range: DistanceRangeLike | None = None,\n    ) -&gt; ProfileStatResults:\n        p = self\n        _hmin: float = float(np.nanmin(p.height))\n        _hmax: float = float(np.nanmax(p.height))\n        if height_range is not None:\n            height_range = validate_height_range(height_range)\n            _hmin = height_range[0]\n            _hmax = height_range[1]\n            p = p.select_height_range(height_range)\n\n        p = p.mean()\n        _mean: float = float(stats.nan_mean(p.values))\n        _std: float = float(stats.nan_std(p.values))\n        _mean_error: float | None = None\n        if isinstance(p.error, np.ndarray):\n            _mean_error = float(stats.nan_mean(p.error))\n        return ProfileStatResults(\n            hmin=_hmin,\n            hmax=_hmax,\n            mean=_mean,\n            std=_std,\n            mean_error=_mean_error,\n        )\n\n    def compare_to(\n        self,\n        target: \"ProfileData\",\n        height_range: DistanceRangeLike | None = None,\n    ) -&gt; ProfileComparisonResults:\n        p = self.copy()\n        p = p.mean()\n        t = target.copy()\n        t = t.mean()\n\n        get_mean_abs_diff = lambda x: float(np.nanmean(np.abs(np.diff(x))))\n        if get_mean_abs_diff(p.height) &gt; get_mean_abs_diff(t.height):\n            t = t.rebin_height(p.height)\n        else:\n            p = p.rebin_height(t.height)\n\n        _hmin: float = float(np.nanmin(p.height))\n        _hmax: float = float(np.nanmax(p.height))\n        if height_range is not None:\n            height_range = validate_height_range(height_range)\n            _hmin = height_range[0]\n            _hmax = height_range[1]\n            p = p.select_height_range(height_range)\n            t = t.select_height_range(height_range)\n\n        stats_pred = p.stats()\n        stats_targ = t.stats()\n\n        if np.nanmean(np.diff(self.height)) &gt; np.nanmean(np.diff(target.height)):\n            height_bins = target.height\n        else:\n            height_bins = self.height\n\n        _diff_of_means: float = float(stats.nan_diff_of_means(p.values, t.values))\n        _mae: float = float(stats.nan_mae(p.values, t.values))\n        _rmse: float = float(stats.nan_rmse(p.values, t.values))\n        _mean_diff: float = float(stats.nan_mean_diff(p.values, t.values))\n\n        return ProfileComparisonResults(\n            hmin=_hmin,\n            hmax=_hmax,\n            diff_of_means=_diff_of_means,\n            mae=_mae,\n            rmse=_rmse,\n            mean_diff=_mean_diff,\n            prediction=stats_pred,\n            target=stats_targ,\n        )\n\n    def to_mega(self) -&gt; \"ProfileData\":\n        import logging\n\n        logger = logging.getLogger()\n\n        if isinstance(self.units, str):\n            if self.units in [\"m-1 sr-1\", \"m-1\"]:\n                return ProfileData(\n                    values=self.values * 1e6,\n                    height=self.height,\n                    time=self.time,\n                    latitude=self.latitude,\n                    longitude=self.longitude,\n                    color=self.color,\n                    label=self.label,\n                    units=f\"M{self.units}\",\n                    platform=self.platform,\n                    error=(\n                        None\n                        if not isinstance(self.error, np.ndarray)\n                        else self.error * 1e6\n                    ),\n                )\n            elif self.units in [\"Mm-1 sr-1\", \"Mm-1\"]:\n                logger.warning(\n                    f\"\"\"Profile units already converted to \"{self.units}\".\"\"\"\n                )\n                return self.copy()\n            else:\n                logger.warning(\n                    f\"\"\"Can not convert profile to \"Mm-1 sr-1\" or \"Mm-1\" since it's original units are: \"{self.units}\".\"\"\"\n                )\n                return self.copy()\n        logger.warning(\n            f\"\"\"Can not convert profile to \"Mm-1 sr-1\" or \"Mm-1\" since units are not given.\"\"\"\n        )\n\n        return self.copy()\n\n    def copy(self) -&gt; \"ProfileData\":\n        return ProfileData(\n            values=self.values,\n            height=self.height,\n            time=self.time,\n            latitude=self.latitude,\n            longitude=self.longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=self.error,\n        )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.coarsen_mean","title":"coarsen_mean","text":"<pre><code>coarsen_mean(n, is_bin=False)\n</code></pre> <p>Returns downsampled profile data.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def coarsen_mean(self, n: int, is_bin: bool = False) -&gt; \"ProfileData\":\n    \"\"\"Returns downsampled profile data.\"\"\"\n    if len(self.values.shape) == 2:\n        new_values: NDArray\n        new_values = coarsen_mean(self.values, n=n, is_bin=is_bin)\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = coarsen_mean(self.error, n=n, is_bin=is_bin)\n        new_time: NDArray = coarsen_mean(self.time, n=n)\n\n        new_height: NDArray\n        if len(self.height.shape) == 2:\n            new_height = coarsen_mean(self.height, n=n)\n        else:\n            new_height = self.height\n\n        new_latitude: NDArray | None\n        if isinstance(self.latitude, np.ndarray):\n            new_latitude = coarsen_mean(self.latitude, n=n)\n        else:\n            new_latitude = None\n\n        new_longitude: NDArray | None\n        if isinstance(self.longitude, np.ndarray):\n            new_longitude = coarsen_mean(self.longitude, n=n)\n        else:\n            new_longitude = None\n\n        return ProfileData(\n            values=new_values,\n            height=new_height,\n            time=new_time,\n            latitude=new_latitude,\n            longitude=new_longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=new_error,\n        )\n\n    msg = f\"VerticalProfile contains only one profile and thus {self.coarsen_mean.__name__}() is not applied.\"\n    warnings.warn(msg)\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.layer_mean","title":"layer_mean","text":"<pre><code>layer_mean(hmin, hmax)\n</code></pre> <p>Returns layer mean values.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def layer_mean(self, hmin: float, hmax: float) -&gt; NDArray:\n    \"\"\"Returns layer mean values.\"\"\"\n    layer_mask = np.logical_and(hmin &lt;= self.height, self.height &lt;= hmax)\n    layer_mean_values = self.values\n    layer_mean_values[~layer_mask] = np.nan\n    if len(layer_mean_values.shape) == 2:\n        layer_mean_values = _mean_2d(layer_mean_values, axis=1)\n    else:\n        layer_mean_values = np.array(nan_mean(layer_mean_values))\n    return layer_mean_values\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.mean","title":"mean","text":"<pre><code>mean()\n</code></pre> <p>Returns mean profile.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def mean(self) -&gt; \"ProfileData\":\n    \"\"\"Returns mean profile.\"\"\"\n    new_values = _mean_2d(self.values)\n    new_height = _mean_2d(self.height)\n    new_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        new_error = _mean_2d(self.error)\n\n    if isinstance(self.time, np.ndarray):\n        new_time = _mean_1d(self.time)\n    else:\n        new_time = None\n\n    if isinstance(self.latitude, np.ndarray):\n        new_latitude = _mean_1d(self.latitude)\n    else:\n        new_latitude = None\n\n    if isinstance(self.longitude, np.ndarray):\n        new_longitude = _mean_1d(self.longitude)\n    else:\n        new_longitude = None\n\n    new_color = self.color\n    new_label = self.label\n    new_units = self.units\n    new_platform = self.platform\n\n    return ProfileData(\n        values=new_values,\n        height=new_height,\n        time=new_time,\n        latitude=new_latitude,\n        longitude=new_longitude,\n        color=new_color,\n        label=new_label,\n        units=new_units,\n        platform=new_platform,\n        error=new_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.rebin_along_track","title":"rebin_along_track","text":"<pre><code>rebin_along_track(latitude_bin_centers, longitude_bin_centers)\n</code></pre> <p>Rebins profiles to new time bins.</p> <p>Parameters:</p> Name Type Description Default <code>latitude_bin_centers</code> <code>ArrayLike</code> <p>Target time bin centers as a 1D array (shape represents temporal dimension)</p> required <p>Returns:</p> Name Type Description <code>rebinned_profiles</code> <code>VerticalProfiles</code> <p>Profiles rebinned along the temporal dimension according to <code>height_bin_centers</code>.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def rebin_along_track(\n    self,\n    latitude_bin_centers: ArrayLike,\n    longitude_bin_centers: ArrayLike,\n) -&gt; \"ProfileData\":\n    \"\"\"\n    Rebins profiles to new time bins.\n\n    Args:\n        latitude_bin_centers (ArrayLike):\n            Target time bin centers as a 1D array (shape represents temporal dimension)\n\n    Returns:\n        rebinned_profiles (VerticalProfiles):\n            Profiles rebinned along the temporal dimension according to `height_bin_centers`.\n    \"\"\"\n    has_lat = self.latitude is not None\n    has_lon = self.longitude is not None\n\n    if not has_lat or not has_lon:\n        missing = []\n        if not has_lat:\n            missing.append(\"latitude\")\n        if not has_lon:\n            missing.append(\"longitude\")\n        raise ValueError(\n            f\"{ProfileData.__name__} instance is missing {' and '.join(missing)} data\"\n        )\n\n    latitude_bin_centers = np.asarray(latitude_bin_centers)\n    longitude_bin_centers = np.asarray(longitude_bin_centers)\n\n    new_values = rebin_along_track(\n        self.values,\n        np.asarray(self.latitude),\n        np.asarray(self.longitude),\n        latitude_bin_centers,\n        longitude_bin_centers,\n    )\n    new_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        new_error = rebin_along_track(\n            self.error,\n            np.asarray(self.latitude),\n            np.asarray(self.longitude),\n            latitude_bin_centers,\n            longitude_bin_centers,\n        )\n    new_times = rebin_along_track(\n        self.time,\n        np.asarray(self.latitude),\n        np.asarray(self.longitude),\n        latitude_bin_centers,\n        longitude_bin_centers,\n    )\n    return ProfileData(\n        values=new_values,\n        height=self.height,\n        time=new_times,\n        latitude=np.array(latitude_bin_centers),\n        longitude=np.array(longitude_bin_centers),\n        color=self.color,\n        label=self.label,\n        units=self.units,\n        platform=self.platform,\n        error=new_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.rebin_height","title":"rebin_height","text":"<pre><code>rebin_height(height_bin_centers, method='mean')\n</code></pre> <p>Rebins profiles to new height bins.</p> <p>Parameters:</p> Name Type Description Default <code>new_height</code> <code>ndarray</code> <p>Target height bin centers as a 1D array (shape represents vertical dimension)</p> required <p>Returns:</p> Name Type Description <code>rebinned_profiles</code> <code>VerticalProfiles</code> <p>Profiles rebinned along the vertical dimension according to <code>height_bin_centers</code>.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def rebin_height(\n    self,\n    height_bin_centers: Iterable[float] | NDArray,\n    method: Literal[\"interpolate\", \"mean\"] = \"mean\",\n) -&gt; \"ProfileData\":\n    \"\"\"\n    Rebins profiles to new height bins.\n\n    Parameters:\n        new_height (np.ndarray):\n            Target height bin centers as a 1D array (shape represents vertical dimension)\n\n    Returns:\n        rebinned_profiles (VerticalProfiles):\n            Profiles rebinned along the vertical dimension according to `height_bin_centers`.\n    \"\"\"\n    if self.height.shape == np.array(height_bin_centers).shape and np.all(\n        np.array(self.height) == np.array(height_bin_centers)\n    ):\n        return ProfileData(\n            values=self.values,\n            height=self.height,\n            time=self.time,\n            latitude=self.latitude,\n            longitude=self.longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=self.error,\n        )\n\n    new_values = rebin_height(\n        self.values,\n        self.height,\n        height_bin_centers,\n        method=method,\n    )\n    new_height = np.asarray(height_bin_centers)\n    if len(new_values.shape) == 2:\n        new_height = np.atleast_2d(new_height)\n        if new_height.shape[0] == 1:\n            new_height = new_height[0]\n    new_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        new_error = rebin_height(\n            self.error,\n            self.height,\n            height_bin_centers,\n            method=method,\n        )\n    return ProfileData(\n        values=new_values,\n        height=new_height,\n        time=self.time,\n        latitude=self.latitude,\n        longitude=self.longitude,\n        color=self.color,\n        label=self.label,\n        units=self.units,\n        platform=self.platform,\n        error=new_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.rebin_time","title":"rebin_time","text":"<pre><code>rebin_time(time_bin_centers, method='mean')\n</code></pre> <p>Rebins profiles to new time bins.</p> <p>Parameters:</p> Name Type Description Default <code>time_bin_centers</code> <code>Iterable[TimestampLike] | ArrayLike</code> <p>Target time bin centers as a 1D array (shape represents temporal dimension)</p> required <p>Returns:</p> Name Type Description <code>rebinned_profiles</code> <code>VerticalProfiles</code> <p>Profiles rebinned along the temporal dimension according to <code>height_bin_centers</code>.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def rebin_time(\n    self,\n    time_bin_centers: Sequence[TimestampLike] | ArrayLike,\n    method: Literal[\"interpolate\", \"mean\"] = \"mean\",\n) -&gt; \"ProfileData\":\n    \"\"\"\n    Rebins profiles to new time bins.\n\n    Args:\n        time_bin_centers (Iterable[TimestampLike] | ArrayLike):\n            Target time bin centers as a 1D array (shape represents temporal dimension)\n\n    Returns:\n        rebinned_profiles (VerticalProfiles):\n            Profiles rebinned along the temporal dimension according to `height_bin_centers`.\n    \"\"\"\n    time_bin_centers = to_timestamps(time_bin_centers)\n    new_values = rebin_time(self.values, self.time, time_bin_centers, method=method)\n    if len(self.height.shape) == 2:\n        new_height = rebin_time(\n            self.height, self.time, time_bin_centers, method=method\n        )\n    else:\n        new_height = self.height\n    new_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        new_error = rebin_time(\n            self.error, self.time, time_bin_centers, method=method\n        )\n\n    if isinstance(self.latitude, np.ndarray) and isinstance(\n        self.longitude, np.ndarray\n    ):\n        new_coords = rebin_time(\n            np.vstack([self.latitude, self.longitude]).T,\n            self.time,\n            time_bin_centers,\n            is_geo=True,\n            method=method,\n        )\n        new_latitude = new_coords[:, 0]\n        new_longitude = new_coords[:, 0]\n    else:\n        new_latitude = None\n        new_longitude = None\n    return ProfileData(\n        values=new_values,\n        height=new_height,\n        time=pd.to_datetime(to_timestamps(time_bin_centers)).to_numpy(),\n        latitude=new_latitude,\n        longitude=new_longitude,\n        color=self.color,\n        label=self.label,\n        units=self.units,\n        platform=self.platform,\n        error=new_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.rolling_mean","title":"rolling_mean","text":"<pre><code>rolling_mean(window_size, axis=0)\n</code></pre> <p>Returns mean profile.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def rolling_mean(self, window_size: int, axis: Literal[0, 1] = 0) -&gt; \"ProfileData\":\n    \"\"\"Returns mean profile.\"\"\"\n    if len(self.values.shape) == 2:\n        new_values = rolling_mean_2d(self.values, w=window_size, axis=axis)\n        new_error: NDArray | None = None\n        if isinstance(self.error, np.ndarray):\n            new_error = self.error\n        return ProfileData(\n            values=new_values,\n            height=self.height,\n            time=self.time,\n            latitude=self.latitude,\n            longitude=self.longitude,\n            color=self.color,\n            label=self.label,\n            units=self.units,\n            platform=self.platform,\n            error=new_error,\n        )\n\n    msg = f\"VerticalProfile contains only one profile and thus {self.rolling_mean.__name__}() is not applied.\"\n    warnings.warn(msg)\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.select_height_range","title":"select_height_range","text":"<pre><code>select_height_range(height_range, pad_idx=0)\n</code></pre> <p>Returns only data within the specified <code>height_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>height_range</code> <code>DistanceRangeLike</code> <p>Pair of minimum and maximum height in meters.</p> required <code>pad_idx</code> <code>int</code> <p>Number of indexes that will be appended to the result before and after given height range. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>ProfileData</code> <code>ProfileData</code> <p>New instance of ProfileData filtered by given height range.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def select_height_range(\n    self,\n    height_range: DistanceRangeLike,\n    pad_idx: int = 0,\n) -&gt; \"ProfileData\":\n    \"\"\"\n    Returns only data within the specified `height_range`.\n\n    Args:\n        height_range (DistanceRangeLike): Pair of minimum and maximum height in meters.\n        pad_idx (int): Number of indexes that will be appended to the result before and after given height range. Defaults to 0.\n\n    Returns:\n        ProfileData: New instance of ProfileData filtered by given height range.\n    \"\"\"\n    height_range = validate_height_range(height_range)\n\n    if len(self.height.shape) == 2:\n        ref_height = self.height[0]\n    else:\n        ref_height = self.height\n\n    mask = np.logical_and(\n        height_range[0] &lt;= ref_height, ref_height &lt;= height_range[1]\n    )\n    mask = pad_true_sequence(mask, pad_idx)\n\n    sel_values = self.values[:, mask]\n    sel_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        sel_error = self.error[:, mask]\n\n    if len(self.height.shape) == 2:\n        sel_height = self.height[:, mask]\n    else:\n        sel_height = self.height[mask]\n\n    return ProfileData(\n        values=sel_values,\n        height=sel_height,\n        time=self.time,\n        latitude=self.latitude,\n        longitude=self.longitude,\n        color=self.color,\n        label=self.label,\n        units=self.units,\n        platform=self.platform,\n        error=sel_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.select_time_range","title":"select_time_range","text":"<pre><code>select_time_range(time_range, pad_idxs=0)\n</code></pre> <p>Returns only data within the specified <code>time_range</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time_range</code> <code>TimeRangeLike | None</code> <p>Pair of minimum and maximum timestamps or None.</p> required <code>pad_idx</code> <code>int</code> <p>Number of indexes that will be appended to the result before and after given time range. Defaults to 0.</p> required <p>Returns:</p> Name Type Description <code>ProfileData</code> <code>ProfileData</code> <p>New instance of ProfileData filtered by given time range.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def select_time_range(\n    self,\n    time_range: TimeRangeLike | None,\n    pad_idxs: int = 0,\n) -&gt; \"ProfileData\":\n    \"\"\"\n    Returns only data within the specified `time_range`.\n\n    Args:\n        time_range (TimeRangeLike | None): Pair of minimum and maximum timestamps or None.\n        pad_idx (int): Number of indexes that will be appended to the result before and after given time range. Defaults to 0.\n\n    Returns:\n        ProfileData: New instance of ProfileData filtered by given time range.\n    \"\"\"\n    if time_range is None:\n        return self\n    elif not isinstance(self.time, np.ndarray):\n        raise ValueError(\n            f\"{ProfileData.__name__}.{self.select_time_range.__name__}() missing `time` data\"\n        )\n\n    time_range = validate_time_range(time_range)\n\n    times = to_timestamps(self.time)\n    mask = np.logical_and(time_range[0] &lt;= times, times &lt;= time_range[1])\n    mask = pad_true_sequence(mask, pad_idxs)\n\n    sel_values = self.values[mask]\n    sel_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        sel_error = self.error[:, mask]\n    sel_time = self.time[mask]\n\n    if len(self.height.shape) == 2:\n        sel_height = self.height[mask]\n    else:\n        sel_height = self.height\n\n    if isinstance(self.latitude, np.ndarray):\n        sel_latitude = self.latitude[mask]\n    else:\n        sel_latitude = None\n\n    if isinstance(self.longitude, np.ndarray):\n        sel_longitude = self.longitude[mask]\n    else:\n        sel_longitude = None\n\n    return ProfileData(\n        values=sel_values,\n        height=sel_height,\n        time=sel_time,\n        latitude=sel_latitude,\n        longitude=sel_longitude,\n        color=self.color,\n        label=self.label,\n        units=self.units,\n        platform=self.platform,\n        error=sel_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.std","title":"std","text":"<pre><code>std()\n</code></pre> <p>Returns standard deviation profile.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def std(self) -&gt; \"ProfileData\":\n    \"\"\"Returns standard deviation profile.\"\"\"\n    new_values = _std_2d(self.values)\n    new_height = _mean_2d(self.height)\n    new_error: NDArray | None = None\n    if isinstance(self.error, np.ndarray):\n        new_error = _mean_2d(self.error)\n\n    if isinstance(self.time, np.ndarray):\n        new_time = _mean_1d(self.time)\n    else:\n        new_time = None\n\n    if isinstance(self.latitude, np.ndarray):\n        new_latitude = _mean_1d(self.latitude)\n    else:\n        new_latitude = None\n\n    if isinstance(self.longitude, np.ndarray):\n        new_longitude = _mean_1d(self.longitude)\n    else:\n        new_longitude = None\n\n    new_color = self.color\n    new_label = self.label\n    new_units = self.units\n    new_platform = self.platform\n\n    return ProfileData(\n        values=new_values,\n        height=new_height,\n        time=new_time,\n        latitude=new_latitude,\n        longitude=new_longitude,\n        color=new_color,\n        label=new_label,\n        units=new_units,\n        platform=new_platform,\n        error=new_error,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileData.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Returns stored profile data as <code>dict</code>.</p> Source code in <code>earthcarekit/utils/profile_data/profile_data.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns stored profile data as `dict`.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileFigure","title":"ProfileFigure","text":"Source code in <code>earthcarekit/plot/figure/profile.py</code> <pre><code>class ProfileFigure:\n    def __init__(\n        self,\n        ax: Axes | None = None,\n        figsize: tuple[float, float] = (3, 4),\n        dpi: int | None = None,\n        title: str | None = None,\n        height_axis: Literal[\"x\", \"y\"] = \"y\",\n        show_grid: bool = True,\n        flip_height_axis: bool = False,\n        show_legend: bool = False,\n        show_height_ticks: bool = True,\n        show_height_label: bool = True,\n        height_range: DistanceRangeLike | None = None,\n        value_range: ValueRangeLike | None = (0, None),\n        label: str = \"\",\n        units: str = \"\",\n    ):\n        self.fig: Figure\n        if isinstance(ax, Axes):\n            tmp = ax.get_figure()\n            if not isinstance(tmp, (Figure, SubFigure)):\n                raise ValueError(f\"Invalid Figure\")\n            self.fig = tmp  # type: ignore\n            self.ax = ax\n        else:\n            # self.fig: Figure = plt.figure(figsize=figsize, dpi=dpi)  # type: ignore\n            # self.ax = self.fig.add_subplot()\n            self.fig = plt.figure(figsize=figsize, dpi=dpi)\n            self.ax = self.fig.add_axes((0.0, 0.0, 1.0, 1.0))\n        self.title = title\n        if isinstance(self.title, str):\n            add_title(self.ax, title=self.title)\n            # self.fig.suptitle(self.title)\n\n        self.selection_time_range: tuple[pd.Timestamp, pd.Timestamp] | None = None\n        self.info_text: AnchoredText | None = None\n\n        self.ax_fill_between = (\n            self.ax.fill_betweenx if height_axis == \"y\" else self.ax.fill_between\n        )\n        self.ax_set_hlim = self.ax.set_ylim if height_axis == \"y\" else self.ax.set_xlim\n        self.ax_set_vlim = self.ax.set_ylim if height_axis == \"x\" else self.ax.set_xlim\n\n        self.hmin: Number | None = 0\n        self.hmax: Number | None = 40e3\n        if isinstance(height_range, (Sequence, np.ndarray)):\n            self.hmin = height_range[0]\n            self.hmax = height_range[1]\n\n        self.vmin: Number | None = None\n        self.vmax: Number | None = None\n        if isinstance(value_range, (Sequence, np.ndarray)):\n            self.vmin = value_range[0]\n            self.vmax = value_range[1]\n\n        self.height_axis: Literal[\"x\", \"y\"] = height_axis\n        self.flip_height_axis = flip_height_axis\n        self.value_axis: Literal[\"x\", \"y\"] = \"x\" if height_axis == \"y\" else \"y\"\n\n        self.show_grid: bool = show_grid\n\n        self.label: str | None = label\n        self.units: str | None = units\n\n        self.ax_right: Axes | None = None\n        self.ax_top: Axes | None = None\n\n        self.show_legend: bool = show_legend\n        self.legend_handles: list = []\n        self.legend_labels: list[str] = []\n        self.legend: Legend | None = None\n\n        self.show_height_ticks: bool = show_height_ticks\n        self.show_height_label: bool = show_height_label\n\n        self._init_axes()\n\n    def _init_axes(self) -&gt; None:\n        self.ax.grid(self.show_grid)\n\n        _hmin: float | None = None if self.hmin is None else float(self.hmin)\n        _hmax: float | None = None if self.hmax is None else float(self.hmax)\n        _vmin: float | None = None if self.vmin is None else float(self.vmin)\n        _vmax: float | None = None if self.vmax is None else float(self.vmax)\n        self.ax_set_hlim(_hmin, _hmax)\n        if _vmin is not None or _vmax is not None:\n            if _vmin is not None and np.isnan(_vmin):\n                _vmin = None\n            if _vmax is not None and np.isnan(_vmax):\n                _vmax = None\n            self.ax_set_vlim(_vmin, _vmax)\n\n        is_init = not isinstance(self.ax_right, Axes)\n\n        if isinstance(self.ax_right, Axes):\n            self.ax_right.remove()\n        self.ax_right = self.ax.twinx()\n        self.ax_right.set_ylim(self.ax.get_ylim())\n        self.ax_right.set_yticklabels([])\n\n        if isinstance(self.ax_top, Axes):\n            self.ax_top.remove()\n        self.ax_top = self.ax.twiny()\n        self.ax_top.set_xlim(self.ax.get_xlim())\n        format_numeric_ticks(\n            self.ax_top,\n            axis=self.value_axis,\n            label=format_var_label(self.label, self.units),\n            show_label=False,\n        )\n        self.ax_top.set_xticklabels([])\n\n        if self.flip_height_axis:\n            format_height_ticks(\n                self.ax_right,\n                axis=self.height_axis,\n                show_tick_labels=self.show_height_ticks,\n                label=\"Height\" if self.show_height_label else None,\n            )\n            self.ax.set_yticklabels([])\n        else:\n            format_height_ticks(\n                self.ax,\n                axis=self.height_axis,\n                show_tick_labels=self.show_height_ticks,\n                label=\"Height\" if self.show_height_label else None,\n            )\n        format_numeric_ticks(\n            self.ax,\n            axis=self.value_axis,\n            label=format_var_label(self.label, self.units),\n        )\n\n        if self.show_legend and len(self.legend_handles) &gt; 0:\n            self.legend = self.ax.legend(\n                handles=self.legend_handles,\n                labels=self.legend_labels,\n                fontsize=\"small\",\n                #   bbox_to_anchor=(1, 1),\n                #   loc=2,\n                bbox_to_anchor=(0, 1.015),\n                loc=\"lower left\",\n                borderaxespad=0.25,\n                edgecolor=\"white\",\n            )\n        elif isinstance(self.legend, Legend):\n            self.legend.remove()\n\n    def plot(\n        self,\n        profiles: ProfileData | None = None,\n        *,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        height: NDArray | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        error: NDArray | None = None,\n        # Common args for wrappers\n        label: str | None = None,\n        units: str | None = None,\n        value_range: ValueRangeLike | None = (0, None),\n        height_range: DistanceRangeLike | None = None,\n        time_range: TimeRangeLike | None = None,\n        selection_height_range: DistanceRangeLike | None = None,\n        show_mean: bool = True,\n        show_std: bool = True,\n        show_min: bool = False,\n        show_max: bool = False,\n        show_sem: bool = False,\n        show_error: bool = False,\n        color: str | ColorLike | None = None,\n        alpha: float = 1.0,\n        linestyle: str = \"solid\",\n        linewidth: Number = 1.5,\n        ribbon_alpha: float = 0.2,\n        show_grid: bool | None = None,\n        zorder: Number | None = 1,\n        legend_label: str | None = None,\n        show_legend: bool | None = None,\n        show_steps: bool = DEFAULT_PROFILE_SHOW_STEPS,\n    ) -&gt; \"ProfileFigure\":\n        \"\"\"TODO: documentation\n\n        Args:\n            profiles (ProfileData | None, optional): _description_. Defaults to None.\n            values (NDArray | None, optional): _description_. Defaults to None.\n            time (NDArray | None, optional): _description_. Defaults to None.\n            height (NDArray | None, optional): _description_. Defaults to None.\n            latitude (NDArray | None, optional): _description_. Defaults to None.\n            longitude (NDArray | None, optional): _description_. Defaults to None.\n            error (NDArray | None, optional): _description_. Defaults to None.\n            label (str | None, optional): _description_. Defaults to None.\n            units (str | None, optional): _description_. Defaults to None.\n            value_range (ValueRangeLike | None, optional): _description_. Defaults to (0, None).\n            height_range (DistanceRangeLike | None, optional): _description_. Defaults to None.\n            time_range (TimeRangeLike | None, optional): _description_. Defaults to None.\n            selection_height_range (DistanceRangeLike | None, optional): _description_. Defaults to None.\n            show_mean (bool, optional): _description_. Defaults to True.\n            show_std (bool, optional): _description_. Defaults to True.\n            show_min (bool, optional): _description_. Defaults to False.\n            show_max (bool, optional): _description_. Defaults to False.\n            show_sem (bool, optional): _description_. Defaults to False.\n            show_error (bool, optional): _description_. Defaults to False.\n            color (str | ColorLike | None, optional): _description_. Defaults to None.\n            alpha (float, optional): _description_. Defaults to 1.0.\n            linestyle (str, optional): _description_. Defaults to \"solid\".\n            linewidth (Number, optional): _description_. Defaults to 1.5.\n            ribbon_alpha (float, optional): _description_. Defaults to 0.2.\n            show_grid (bool | None, optional): _description_. Defaults to None.\n            zorder (Number | None, optional): _description_. Defaults to 1.\n            legend_label (str | None, optional): _description_. Defaults to None.\n            show_legend (bool | None, optional): _description_. Defaults to None.\n            show_steps (bool, optional): _description_. Defaults to DEFAULT_PROFILE_SHOW_STEPS.\n\n        Raises:\n            ValueError: _description_\n            ValueError: _description_\n\n        Returns:\n            ProfileFigure: _description_\n        \"\"\"\n        color = Color.from_optional(color)\n\n        if isinstance(show_legend, bool):\n            self.show_legend = show_legend\n\n        if isinstance(show_grid, bool):\n            self.show_grid = show_grid\n            self.ax.grid(self.show_grid)\n\n        if isinstance(value_range, Iterable):\n            if len(value_range) != 2:\n                raise ValueError(\n                    f\"invalid `value_range`: {value_range}, expecting (vmin, vmax)\"\n                )\n            else:\n                if value_range[0] is not None:\n                    self.vmin = value_range[0]\n                if value_range[1] is not None:\n                    self.vmax = value_range[1]\n        else:\n            value_range = (None, None)\n        logger.debug(f\"{value_range=}\")\n\n        if isinstance(profiles, ProfileData):\n            values = profiles.values\n            time = profiles.time\n            height = profiles.height\n            latitude = profiles.latitude\n            longitude = profiles.longitude\n            if not isinstance(label, str):\n                label = profiles.label\n            if not isinstance(units, str):\n                units = profiles.units\n            error = profiles.error\n        elif values is None or height is None:\n            raise ValueError(\n                \"Missing required arguments. Provide either a `VerticalProfiles` or all of `values` and `height`\"\n            )\n\n        values = np.asarray(np.atleast_2d(values))\n        if time is None:\n            time = np.array([pd.Timestamp.now()] * values.shape[0])\n        time = np.asarray(np.atleast_1d(time))\n        height = np.asarray(height)\n        is_single_profile_and_multiple_height_profiles = values.shape[0] == 1 and (\n            len(height.shape) &gt; 1 and height.shape[0] &gt; 1\n        )\n        if is_single_profile_and_multiple_height_profiles:\n            values = np.repeat(values, height.shape[0], axis=0)\n        if latitude is not None:\n            latitude = np.asarray(latitude)\n        if longitude is not None:\n            longitude = np.asarray(longitude)\n\n        vp = ProfileData(\n            values=values,\n            time=time,\n            height=height,\n            latitude=latitude,\n            longitude=longitude,\n            label=label,\n            units=units,\n            error=error,\n        )\n        if is_single_profile_and_multiple_height_profiles:\n            vp = vp.mean()\n\n        vp.select_time_range(time_range)\n\n        if isinstance(vp.label, str):\n            self.label = vp.label\n        if isinstance(vp.units, str):\n            self.units = vp.units\n\n        if height_range is not None:\n            if isinstance(height_range, Iterable) and len(height_range) == 2:\n                for i in [0, -1]:\n                    height_range = list(height_range)\n                    if height_range[i] is None:\n                        height_range[i] = np.atleast_2d(vp.height)[0, i]\n                    elif i == 0:\n                        self.hmin = height_range[0]\n                    elif i == -1:\n                        self.hmax = height_range[-1]\n                    height_range = tuple(height_range)\n        else:\n            height_range = (\n                np.atleast_2d(vp.height)[0, 0],\n                np.atleast_2d(vp.height)[0, -1],\n            )\n\n        if len(vp.height.shape) == 2 and vp.height.shape[0] == 1:\n            h = vp.height[0]\n        elif len(vp.height.shape) == 2:\n            h = nan_mean(vp.height, axis=0)\n        else:\n            h = vp.height\n\n        handle_mean: list[Line2D] | list[None] = [None]\n        handle_min: list[Line2D] | list[None] = [None]\n        handle_max: list[Line2D] | list[None] = [None]\n        handle_std: PolyCollection | None = None\n        handle_sem: PolyCollection | None = None\n\n        if show_mean:\n            if vp.values.shape[0] == 1:\n                vmean = vp.values[0]\n                show_std = False\n                show_sem = False\n                show_min = False\n                show_max = False\n            else:\n                vmean = nan_mean(vp.values, axis=0)\n            vnew, hnew = vmean, h\n            if show_steps:\n                vnew, hnew = _convert_vertical_profile_to_step_function(vmean, h)\n            xy = (vnew, hnew) if self.height_axis == \"y\" else (hnew, vnew)\n            handle_mean = self.ax.plot(\n                *xy,\n                color=color,\n                alpha=alpha,\n                zorder=zorder,\n                linestyle=linestyle,\n                linewidth=linewidth,\n            )\n            color = handle_mean[0].get_color()  # type: ignore\n\n            value_range = select_value_range(vmean, value_range, pad_frac=0.01)\n            if not (self.vmin is not None and self.vmin &lt; value_range[0]):\n                self.vmin = value_range[0]\n            if not (self.vmax is not None and self.vmax &gt; value_range[1]):\n                self.vmax = value_range[1]\n\n            if show_error and vp.error is not None:\n                verror = vp.error.flatten()\n                if show_steps:\n                    verror, _ = _convert_vertical_profile_to_step_function(verror, h)\n                handle_std = self.ax_fill_between(\n                    hnew,\n                    vnew - verror,\n                    vnew + verror,\n                    alpha=ribbon_alpha,\n                    color=color,\n                    linewidth=0,\n                )\n\n        if show_sem:\n            vsem = nan_sem(vp.values, axis=0)\n            if show_steps:\n                vsem, _ = _convert_vertical_profile_to_step_function(vsem, h)\n            handle_sem = self.ax_fill_between(\n                hnew,\n                vnew - vsem,\n                vnew + vsem,\n                alpha=ribbon_alpha,\n                color=color,\n                linewidth=0,\n            )\n        elif show_std:\n            vstd = nan_std(vp.values, axis=0)\n            if show_steps:\n                vstd, _ = _convert_vertical_profile_to_step_function(vstd, h)\n            handle_std = self.ax_fill_between(\n                hnew,\n                vnew - vstd,\n                vnew + vstd,\n                alpha=ribbon_alpha,\n                color=color,\n                linewidth=0,\n            )\n\n        if show_min:\n            vmin = nan_min(vp.values, axis=0)\n            vnew, hnew = vmin, h\n            if show_steps:\n                vnew, hnew = _convert_vertical_profile_to_step_function(vmin, h)\n            xy = (vnew, hnew) if self.height_axis == \"y\" else (hnew, vnew)\n            handle_min = self.ax.plot(\n                *xy,\n                color=color,\n                alpha=alpha,\n                zorder=zorder,\n                linestyle=\"dashed\",\n                linewidth=linewidth,\n            )\n            color = handle_min[0].get_color()  # type: ignore\n\n        if show_max:\n            vmax = nan_max(vp.values, axis=0)\n            vnew, hnew = vmax, h\n            if show_steps:\n                vnew, hnew = _convert_vertical_profile_to_step_function(vmax, h)\n            xy = (vnew, hnew) if self.height_axis == \"y\" else (hnew, vnew)\n            handle_max = self.ax.plot(\n                *xy,\n                color=color,\n                alpha=alpha,\n                zorder=zorder,\n                linestyle=\"dashed\",\n                linewidth=linewidth,\n            )\n            color = handle_max[0].get_color()  # type: ignore\n\n        # Legend labels\n        if isinstance(legend_label, str):\n            handle_std\n\n            _handle: tuple | list = [\n                *handle_mean,\n                handle_std,\n                handle_sem,\n                *handle_min,\n                *handle_max,\n            ]\n            _default_h = next(_h for _h in _handle if _h is not None)\n            _handle = tuple([_h if _h is not None else _default_h for _h in _handle])\n            self.legend_handles.append(_handle)\n            self.legend_labels.append(legend_label)\n\n        if selection_height_range:\n            _shr: tuple[float, float] = validate_numeric_range(selection_height_range)\n            _highlight_height_range(\n                ax=self.ax,\n                height_range=_shr,\n            )\n\n        self._init_axes()\n\n        # format_height_ticks(self.ax, axis=self.height_axis)\n        # format_numeric_ticks(self.ax, axis=self.value_axis, label=self.label)\n\n        return self\n\n    def ecplot(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        *,\n        time_var: str = TIME_VAR,\n        height_var: str = HEIGHT_VAR,\n        lat_var: str = TRACK_LAT_VAR,\n        lon_var: str = TRACK_LON_VAR,\n        error_var: str | None = None,\n        along_track_dim: str = ALONG_TRACK_DIM,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        height: NDArray | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        error: NDArray | None = None,\n        site: str | GroundSite | None = None,\n        radius_km: float = 100.0,\n        # Common args for wrappers\n        value_range: ValueRangeLike | None = None,\n        height_range: DistanceRangeLike | None = (0, 40e3),\n        time_range: TimeRangeLike | None = None,\n        selection_height_range: DistanceRangeLike | None = None,\n        label: str | None = None,\n        units: str | None = None,\n        zorder: Number | None = 1,\n        legend_label: str | None = \"EarthCARE\",\n        show_legend: bool | None = None,\n        show_steps: bool = DEFAULT_PROFILE_SHOW_STEPS,\n        **kwargs,\n    ) -&gt; \"ProfileFigure\":\n        # Collect all common args for wrapped plot function call\n        local_args = locals()\n        # Delete all args specific to this wrapper function\n        del local_args[\"self\"]\n        del local_args[\"ds\"]\n        del local_args[\"var\"]\n        del local_args[\"time_var\"]\n        del local_args[\"height_var\"]\n        del local_args[\"lat_var\"]\n        del local_args[\"lon_var\"]\n        del local_args[\"error_var\"]\n        del local_args[\"along_track_dim\"]\n        del local_args[\"site\"]\n        del local_args[\"radius_km\"]\n        # Delete kwargs to then merge it with the residual common args\n        del local_args[\"kwargs\"]\n        all_args = {**local_args, **kwargs}\n\n        if all_args[\"values\"] is None:\n            all_args[\"values\"] = ds[var].values\n        if all_args[\"time\"] is None:\n            all_args[\"time\"] = ds[time_var].values\n        if all_args[\"height\"] is None:\n            all_args[\"height\"] = ds[height_var].values\n        if all_args[\"latitude\"] is None:\n            all_args[\"latitude\"] = ds[lat_var].values\n        if all_args[\"longitude\"] is None:\n            all_args[\"longitude\"] = ds[lon_var].values\n        if all_args[\"error\"] is None and isinstance(error_var, str):\n            all_args[\"error\"] = ds[error_var].values\n\n        # Set default values depending on variable name\n        if label is None:\n            all_args[\"label\"] = (\n                \"Values\" if not hasattr(ds[var], \"long_name\") else ds[var].long_name\n            )\n        if units is None:\n            all_args[\"units\"] = \"-\" if not hasattr(ds[var], \"units\") else ds[var].units\n        if value_range is None:\n            all_args[\"value_range\"] = get_default_profile_range(var)\n\n        self.plot(**all_args)\n\n        return self\n\n    def invert_xaxis(self) -&gt; \"ProfileFigure\":\n        \"\"\"Invert the x-axis.\"\"\"\n        self.ax.invert_xaxis()\n        if self.ax_top:\n            self.ax_top.invert_xaxis()\n        return self\n\n    def invert_yaxis(self) -&gt; \"ProfileFigure\":\n        \"\"\"Invert the y-axis.\"\"\"\n        self.ax.invert_yaxis()\n        if self.ax_right:\n            self.ax_right.invert_yaxis()\n        return self\n\n    def show(self) -&gt; None:\n        import IPython\n        import matplotlib.pyplot as plt\n        from IPython.display import display\n\n        if IPython.get_ipython() is not None:\n            display(self.fig)\n        else:\n            plt.show()\n\n    def save(\n        self,\n        filename: str = \"\",\n        filepath: str | None = None,\n        ds: xr.Dataset | None = None,\n        ds_filepath: str | None = None,\n        dpi: float | Literal[\"figure\"] = \"figure\",\n        orbit_and_frame: str | None = None,\n        utc_timestamp: TimestampLike | None = None,\n        use_utc_creation_timestamp: bool = False,\n        site_name: str | None = None,\n        hmax: int | float | None = None,\n        radius: int | float | None = None,\n        extra: str | None = None,\n        transparent_outside: bool = False,\n        verbose: bool = True,\n        print_prefix: str = \"\",\n        create_dirs: bool = False,\n        transparent_background: bool = False,\n        resolution: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n        Args:\n            figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n            filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n            filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n            ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n            ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n            pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n            dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n            orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n            site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n            transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n            verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n            print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n            create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n            transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n            **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n        \"\"\"\n        save_plot(\n            fig=self.fig,\n            filename=filename,\n            filepath=filepath,\n            ds=ds,\n            ds_filepath=ds_filepath,\n            dpi=dpi,\n            orbit_and_frame=orbit_and_frame,\n            utc_timestamp=utc_timestamp,\n            use_utc_creation_timestamp=use_utc_creation_timestamp,\n            site_name=site_name,\n            hmax=hmax,\n            radius=radius,\n            extra=extra,\n            transparent_outside=transparent_outside,\n            verbose=verbose,\n            print_prefix=print_prefix,\n            create_dirs=create_dirs,\n            transparent_background=transparent_background,\n            resolution=resolution,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileFigure.invert_xaxis","title":"invert_xaxis","text":"<pre><code>invert_xaxis()\n</code></pre> <p>Invert the x-axis.</p> Source code in <code>earthcarekit/plot/figure/profile.py</code> <pre><code>def invert_xaxis(self) -&gt; \"ProfileFigure\":\n    \"\"\"Invert the x-axis.\"\"\"\n    self.ax.invert_xaxis()\n    if self.ax_top:\n        self.ax_top.invert_xaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileFigure.invert_yaxis","title":"invert_yaxis","text":"<pre><code>invert_yaxis()\n</code></pre> <p>Invert the y-axis.</p> Source code in <code>earthcarekit/plot/figure/profile.py</code> <pre><code>def invert_yaxis(self) -&gt; \"ProfileFigure\":\n    \"\"\"Invert the y-axis.\"\"\"\n    self.ax.invert_yaxis()\n    if self.ax_right:\n        self.ax_right.invert_yaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileFigure.plot","title":"plot","text":"<pre><code>plot(\n    profiles=None,\n    *,\n    values=None,\n    time=None,\n    height=None,\n    latitude=None,\n    longitude=None,\n    error=None,\n    label=None,\n    units=None,\n    value_range=(0, None),\n    height_range=None,\n    time_range=None,\n    selection_height_range=None,\n    show_mean=True,\n    show_std=True,\n    show_min=False,\n    show_max=False,\n    show_sem=False,\n    show_error=False,\n    color=None,\n    alpha=1.0,\n    linestyle=\"solid\",\n    linewidth=1.5,\n    ribbon_alpha=0.2,\n    show_grid=None,\n    zorder=1,\n    legend_label=None,\n    show_legend=None,\n    show_steps=DEFAULT_PROFILE_SHOW_STEPS\n)\n</code></pre> <p>TODO: documentation</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>ProfileData | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>values</code> <code>NDArray | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>time</code> <code>NDArray | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>height</code> <code>NDArray | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>latitude</code> <code>NDArray | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>longitude</code> <code>NDArray | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>error</code> <code>NDArray | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>units</code> <code>str | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>value_range</code> <code>ValueRangeLike | None</code> <p>description. Defaults to (0, None).</p> <code>(0, None)</code> <code>height_range</code> <code>DistanceRangeLike | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>time_range</code> <code>TimeRangeLike | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>selection_height_range</code> <code>DistanceRangeLike | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>show_mean</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>show_std</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>show_min</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>show_max</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>show_sem</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>show_error</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> <code>color</code> <code>str | ColorLike | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>description. Defaults to 1.0.</p> <code>1.0</code> <code>linestyle</code> <code>str</code> <p>description. Defaults to \"solid\".</p> <code>'solid'</code> <code>linewidth</code> <code>Number</code> <p>description. Defaults to 1.5.</p> <code>1.5</code> <code>ribbon_alpha</code> <code>float</code> <p>description. Defaults to 0.2.</p> <code>0.2</code> <code>show_grid</code> <code>bool | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>zorder</code> <code>Number | None</code> <p>description. Defaults to 1.</p> <code>1</code> <code>legend_label</code> <code>str | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>show_legend</code> <code>bool | None</code> <p>description. Defaults to None.</p> <code>None</code> <code>show_steps</code> <code>bool</code> <p>description. Defaults to DEFAULT_PROFILE_SHOW_STEPS.</p> <code>DEFAULT_PROFILE_SHOW_STEPS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <code>ValueError</code> <p>description</p> <p>Returns:</p> Name Type Description <code>ProfileFigure</code> <code>ProfileFigure</code> <p>description</p> Source code in <code>earthcarekit/plot/figure/profile.py</code> <pre><code>def plot(\n    self,\n    profiles: ProfileData | None = None,\n    *,\n    values: NDArray | None = None,\n    time: NDArray | None = None,\n    height: NDArray | None = None,\n    latitude: NDArray | None = None,\n    longitude: NDArray | None = None,\n    error: NDArray | None = None,\n    # Common args for wrappers\n    label: str | None = None,\n    units: str | None = None,\n    value_range: ValueRangeLike | None = (0, None),\n    height_range: DistanceRangeLike | None = None,\n    time_range: TimeRangeLike | None = None,\n    selection_height_range: DistanceRangeLike | None = None,\n    show_mean: bool = True,\n    show_std: bool = True,\n    show_min: bool = False,\n    show_max: bool = False,\n    show_sem: bool = False,\n    show_error: bool = False,\n    color: str | ColorLike | None = None,\n    alpha: float = 1.0,\n    linestyle: str = \"solid\",\n    linewidth: Number = 1.5,\n    ribbon_alpha: float = 0.2,\n    show_grid: bool | None = None,\n    zorder: Number | None = 1,\n    legend_label: str | None = None,\n    show_legend: bool | None = None,\n    show_steps: bool = DEFAULT_PROFILE_SHOW_STEPS,\n) -&gt; \"ProfileFigure\":\n    \"\"\"TODO: documentation\n\n    Args:\n        profiles (ProfileData | None, optional): _description_. Defaults to None.\n        values (NDArray | None, optional): _description_. Defaults to None.\n        time (NDArray | None, optional): _description_. Defaults to None.\n        height (NDArray | None, optional): _description_. Defaults to None.\n        latitude (NDArray | None, optional): _description_. Defaults to None.\n        longitude (NDArray | None, optional): _description_. Defaults to None.\n        error (NDArray | None, optional): _description_. Defaults to None.\n        label (str | None, optional): _description_. Defaults to None.\n        units (str | None, optional): _description_. Defaults to None.\n        value_range (ValueRangeLike | None, optional): _description_. Defaults to (0, None).\n        height_range (DistanceRangeLike | None, optional): _description_. Defaults to None.\n        time_range (TimeRangeLike | None, optional): _description_. Defaults to None.\n        selection_height_range (DistanceRangeLike | None, optional): _description_. Defaults to None.\n        show_mean (bool, optional): _description_. Defaults to True.\n        show_std (bool, optional): _description_. Defaults to True.\n        show_min (bool, optional): _description_. Defaults to False.\n        show_max (bool, optional): _description_. Defaults to False.\n        show_sem (bool, optional): _description_. Defaults to False.\n        show_error (bool, optional): _description_. Defaults to False.\n        color (str | ColorLike | None, optional): _description_. Defaults to None.\n        alpha (float, optional): _description_. Defaults to 1.0.\n        linestyle (str, optional): _description_. Defaults to \"solid\".\n        linewidth (Number, optional): _description_. Defaults to 1.5.\n        ribbon_alpha (float, optional): _description_. Defaults to 0.2.\n        show_grid (bool | None, optional): _description_. Defaults to None.\n        zorder (Number | None, optional): _description_. Defaults to 1.\n        legend_label (str | None, optional): _description_. Defaults to None.\n        show_legend (bool | None, optional): _description_. Defaults to None.\n        show_steps (bool, optional): _description_. Defaults to DEFAULT_PROFILE_SHOW_STEPS.\n\n    Raises:\n        ValueError: _description_\n        ValueError: _description_\n\n    Returns:\n        ProfileFigure: _description_\n    \"\"\"\n    color = Color.from_optional(color)\n\n    if isinstance(show_legend, bool):\n        self.show_legend = show_legend\n\n    if isinstance(show_grid, bool):\n        self.show_grid = show_grid\n        self.ax.grid(self.show_grid)\n\n    if isinstance(value_range, Iterable):\n        if len(value_range) != 2:\n            raise ValueError(\n                f\"invalid `value_range`: {value_range}, expecting (vmin, vmax)\"\n            )\n        else:\n            if value_range[0] is not None:\n                self.vmin = value_range[0]\n            if value_range[1] is not None:\n                self.vmax = value_range[1]\n    else:\n        value_range = (None, None)\n    logger.debug(f\"{value_range=}\")\n\n    if isinstance(profiles, ProfileData):\n        values = profiles.values\n        time = profiles.time\n        height = profiles.height\n        latitude = profiles.latitude\n        longitude = profiles.longitude\n        if not isinstance(label, str):\n            label = profiles.label\n        if not isinstance(units, str):\n            units = profiles.units\n        error = profiles.error\n    elif values is None or height is None:\n        raise ValueError(\n            \"Missing required arguments. Provide either a `VerticalProfiles` or all of `values` and `height`\"\n        )\n\n    values = np.asarray(np.atleast_2d(values))\n    if time is None:\n        time = np.array([pd.Timestamp.now()] * values.shape[0])\n    time = np.asarray(np.atleast_1d(time))\n    height = np.asarray(height)\n    is_single_profile_and_multiple_height_profiles = values.shape[0] == 1 and (\n        len(height.shape) &gt; 1 and height.shape[0] &gt; 1\n    )\n    if is_single_profile_and_multiple_height_profiles:\n        values = np.repeat(values, height.shape[0], axis=0)\n    if latitude is not None:\n        latitude = np.asarray(latitude)\n    if longitude is not None:\n        longitude = np.asarray(longitude)\n\n    vp = ProfileData(\n        values=values,\n        time=time,\n        height=height,\n        latitude=latitude,\n        longitude=longitude,\n        label=label,\n        units=units,\n        error=error,\n    )\n    if is_single_profile_and_multiple_height_profiles:\n        vp = vp.mean()\n\n    vp.select_time_range(time_range)\n\n    if isinstance(vp.label, str):\n        self.label = vp.label\n    if isinstance(vp.units, str):\n        self.units = vp.units\n\n    if height_range is not None:\n        if isinstance(height_range, Iterable) and len(height_range) == 2:\n            for i in [0, -1]:\n                height_range = list(height_range)\n                if height_range[i] is None:\n                    height_range[i] = np.atleast_2d(vp.height)[0, i]\n                elif i == 0:\n                    self.hmin = height_range[0]\n                elif i == -1:\n                    self.hmax = height_range[-1]\n                height_range = tuple(height_range)\n    else:\n        height_range = (\n            np.atleast_2d(vp.height)[0, 0],\n            np.atleast_2d(vp.height)[0, -1],\n        )\n\n    if len(vp.height.shape) == 2 and vp.height.shape[0] == 1:\n        h = vp.height[0]\n    elif len(vp.height.shape) == 2:\n        h = nan_mean(vp.height, axis=0)\n    else:\n        h = vp.height\n\n    handle_mean: list[Line2D] | list[None] = [None]\n    handle_min: list[Line2D] | list[None] = [None]\n    handle_max: list[Line2D] | list[None] = [None]\n    handle_std: PolyCollection | None = None\n    handle_sem: PolyCollection | None = None\n\n    if show_mean:\n        if vp.values.shape[0] == 1:\n            vmean = vp.values[0]\n            show_std = False\n            show_sem = False\n            show_min = False\n            show_max = False\n        else:\n            vmean = nan_mean(vp.values, axis=0)\n        vnew, hnew = vmean, h\n        if show_steps:\n            vnew, hnew = _convert_vertical_profile_to_step_function(vmean, h)\n        xy = (vnew, hnew) if self.height_axis == \"y\" else (hnew, vnew)\n        handle_mean = self.ax.plot(\n            *xy,\n            color=color,\n            alpha=alpha,\n            zorder=zorder,\n            linestyle=linestyle,\n            linewidth=linewidth,\n        )\n        color = handle_mean[0].get_color()  # type: ignore\n\n        value_range = select_value_range(vmean, value_range, pad_frac=0.01)\n        if not (self.vmin is not None and self.vmin &lt; value_range[0]):\n            self.vmin = value_range[0]\n        if not (self.vmax is not None and self.vmax &gt; value_range[1]):\n            self.vmax = value_range[1]\n\n        if show_error and vp.error is not None:\n            verror = vp.error.flatten()\n            if show_steps:\n                verror, _ = _convert_vertical_profile_to_step_function(verror, h)\n            handle_std = self.ax_fill_between(\n                hnew,\n                vnew - verror,\n                vnew + verror,\n                alpha=ribbon_alpha,\n                color=color,\n                linewidth=0,\n            )\n\n    if show_sem:\n        vsem = nan_sem(vp.values, axis=0)\n        if show_steps:\n            vsem, _ = _convert_vertical_profile_to_step_function(vsem, h)\n        handle_sem = self.ax_fill_between(\n            hnew,\n            vnew - vsem,\n            vnew + vsem,\n            alpha=ribbon_alpha,\n            color=color,\n            linewidth=0,\n        )\n    elif show_std:\n        vstd = nan_std(vp.values, axis=0)\n        if show_steps:\n            vstd, _ = _convert_vertical_profile_to_step_function(vstd, h)\n        handle_std = self.ax_fill_between(\n            hnew,\n            vnew - vstd,\n            vnew + vstd,\n            alpha=ribbon_alpha,\n            color=color,\n            linewidth=0,\n        )\n\n    if show_min:\n        vmin = nan_min(vp.values, axis=0)\n        vnew, hnew = vmin, h\n        if show_steps:\n            vnew, hnew = _convert_vertical_profile_to_step_function(vmin, h)\n        xy = (vnew, hnew) if self.height_axis == \"y\" else (hnew, vnew)\n        handle_min = self.ax.plot(\n            *xy,\n            color=color,\n            alpha=alpha,\n            zorder=zorder,\n            linestyle=\"dashed\",\n            linewidth=linewidth,\n        )\n        color = handle_min[0].get_color()  # type: ignore\n\n    if show_max:\n        vmax = nan_max(vp.values, axis=0)\n        vnew, hnew = vmax, h\n        if show_steps:\n            vnew, hnew = _convert_vertical_profile_to_step_function(vmax, h)\n        xy = (vnew, hnew) if self.height_axis == \"y\" else (hnew, vnew)\n        handle_max = self.ax.plot(\n            *xy,\n            color=color,\n            alpha=alpha,\n            zorder=zorder,\n            linestyle=\"dashed\",\n            linewidth=linewidth,\n        )\n        color = handle_max[0].get_color()  # type: ignore\n\n    # Legend labels\n    if isinstance(legend_label, str):\n        handle_std\n\n        _handle: tuple | list = [\n            *handle_mean,\n            handle_std,\n            handle_sem,\n            *handle_min,\n            *handle_max,\n        ]\n        _default_h = next(_h for _h in _handle if _h is not None)\n        _handle = tuple([_h if _h is not None else _default_h for _h in _handle])\n        self.legend_handles.append(_handle)\n        self.legend_labels.append(legend_label)\n\n    if selection_height_range:\n        _shr: tuple[float, float] = validate_numeric_range(selection_height_range)\n        _highlight_height_range(\n            ax=self.ax,\n            height_range=_shr,\n        )\n\n    self._init_axes()\n\n    # format_height_ticks(self.ax, axis=self.height_axis)\n    # format_numeric_ticks(self.ax, axis=self.value_axis, label=self.label)\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.ProfileFigure.save","title":"save","text":"<pre><code>save(\n    filename=\"\",\n    filepath=None,\n    ds=None,\n    ds_filepath=None,\n    dpi=\"figure\",\n    orbit_and_frame=None,\n    utc_timestamp=None,\n    use_utc_creation_timestamp=False,\n    site_name=None,\n    hmax=None,\n    radius=None,\n    extra=None,\n    transparent_outside=False,\n    verbose=True,\n    print_prefix=\"\",\n    create_dirs=False,\n    transparent_background=False,\n    resolution=None,\n    **kwargs\n)\n</code></pre> <p>Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure | HasFigure</code> <p>A figure object (<code>matplotlib.figure.Figure</code>) or objects exposing a <code>.fig</code> attribute containing a figure (e.g., <code>CurtainFigure</code>).</p> required <code>filename</code> <code>str</code> <p>The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.</p> <code>''</code> <code>filepath</code> <code>str | None</code> <p>The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.</p> <code>None</code> <code>ds</code> <code>Dataset | None</code> <p>A EarthCARE dataset from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>ds_filepath</code> <code>str | None</code> <p>A path to a EarthCARE product from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>pad</code> <code>float</code> <p>Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.</p> required <code>dpi</code> <code>float | figure</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.</p> <code>'figure'</code> <code>orbit_and_frame</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>utc_timestamp</code> <code>TimestampLike | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>use_utc_creation_timestamp</code> <code>bool</code> <p>Whether the time of image creation should be included in the file name. Defaults to False.</p> <code>False</code> <code>site_name</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>hmax</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>radius</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>extra</code> <code>str | None</code> <p>A custom string to be included in the file name. Defaults to None.</p> <code>None</code> <code>transparent_outside</code> <code>bool</code> <p>Whether the area outside figures should be transparent. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether the progress of image creation should be printed to the console. Defaults to True.</p> <code>True</code> <code>print_prefix</code> <code>str</code> <p>A prefix string to all console messages. Defaults to \"\".</p> <code>''</code> <code>create_dirs</code> <code>bool</code> <p>Whether images should be saved in a folder structure based on provided metadata. Defaults to False.</p> <code>False</code> <code>transparent_background</code> <code>bool</code> <p>Whether the background inside and outside of figures should be transparent. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments passed to wrapped function call of <code>matplotlib.pyplot.savefig</code>.</p> <code>{}</code> Source code in <code>earthcarekit/plot/figure/profile.py</code> <pre><code>def save(\n    self,\n    filename: str = \"\",\n    filepath: str | None = None,\n    ds: xr.Dataset | None = None,\n    ds_filepath: str | None = None,\n    dpi: float | Literal[\"figure\"] = \"figure\",\n    orbit_and_frame: str | None = None,\n    utc_timestamp: TimestampLike | None = None,\n    use_utc_creation_timestamp: bool = False,\n    site_name: str | None = None,\n    hmax: int | float | None = None,\n    radius: int | float | None = None,\n    extra: str | None = None,\n    transparent_outside: bool = False,\n    verbose: bool = True,\n    print_prefix: str = \"\",\n    create_dirs: bool = False,\n    transparent_background: bool = False,\n    resolution: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n    Args:\n        figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n        filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n        filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n        ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n        ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n        pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n        dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n        orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n        site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n        transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n        verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n        print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n        create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n        transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n        **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n    \"\"\"\n    save_plot(\n        fig=self.fig,\n        filename=filename,\n        filepath=filepath,\n        ds=ds,\n        ds_filepath=ds_filepath,\n        dpi=dpi,\n        orbit_and_frame=orbit_and_frame,\n        utc_timestamp=utc_timestamp,\n        use_utc_creation_timestamp=use_utc_creation_timestamp,\n        site_name=site_name,\n        hmax=hmax,\n        radius=radius,\n        extra=extra,\n        transparent_outside=transparent_outside,\n        verbose=verbose,\n        print_prefix=print_prefix,\n        create_dirs=create_dirs,\n        transparent_background=transparent_background,\n        resolution=resolution,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.SwathFigure","title":"SwathFigure","text":"<p>TODO: documentation</p> Source code in <code>earthcarekit/plot/figure/swath.py</code> <pre><code>class SwathFigure:\n    \"\"\"TODO: documentation\"\"\"\n\n    def __init__(\n        self,\n        ax: Axes | None = None,\n        figsize: tuple[float, float] = (FIGURE_WIDTH_SWATH, FIGURE_HEIGHT_SWATH),\n        dpi: int | None = None,\n        title: str | None = None,\n        ax_style_top: AlongTrackAxisStyle | str = \"geo\",\n        ax_style_bottom: AlongTrackAxisStyle | str = \"time\",\n        num_ticks: int = 10,\n        colorbar_tick_scale: float | None = None,\n        ax_style_y: Literal[\n            \"from_track_distance\",\n            \"across_track_distance\",\n            \"pixel\",\n        ] = \"from_track_distance\",\n        fig_height_scale: float = 1.0,\n        fig_width_scale: float = 1.0,\n    ):\n        figsize = (figsize[0] * fig_width_scale, figsize[1] * fig_height_scale)\n        self.fig: Figure\n        if isinstance(ax, Axes):\n            tmp = ax.get_figure()\n            if not isinstance(tmp, (Figure, SubFigure)):\n                raise ValueError(f\"Invalid Figure\")\n            self.fig = tmp  # type: ignore\n            self.ax = ax\n        else:\n            self.fig = plt.figure(figsize=figsize, dpi=dpi)\n            self.ax = self.fig.add_axes((0.0, 0.0, 1.0, 1.0))\n\n        self.title = title\n        if self.title:\n            self.fig.suptitle(self.title)\n\n        self.ax_top: Axes | None = None\n        self.ax_right: Axes | None = None\n        self.colorbar: Colorbar | None = None\n        self.colorbar_tick_scale: float | None = colorbar_tick_scale\n        self.selection_time_range: tuple[pd.Timestamp, pd.Timestamp] | None = None\n        self.ax_style_top: AlongTrackAxisStyle = AlongTrackAxisStyle.from_input(\n            ax_style_top\n        )\n        self.ax_style_bottom: AlongTrackAxisStyle = AlongTrackAxisStyle.from_input(\n            ax_style_bottom\n        )\n        self.ax_style_y: Literal[\n            \"from_track_distance\",\n            \"across_track_distance\",\n            \"pixel\",\n        ] = ax_style_y\n\n        self.info_text: AnchoredText | None = None\n        self.info_text_loc: str = \"upper right\"\n        self.num_ticks = num_ticks\n\n    def _set_info_text_loc(self, info_text_loc: str | None) -&gt; None:\n        if isinstance(info_text_loc, str):\n            self.info_text_loc = info_text_loc\n\n    def plot(\n        self,\n        swath: SwathData | None = None,\n        *,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        nadir_index: int | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        # Common args for wrappers\n        value_range: ValueRangeLike | None = None,\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        time_range: TimeRangeLike | None = None,\n        from_track_range: DistanceRangeLike | None = None,\n        label: str | None = None,\n        units: str | None = None,\n        cmap: str | Colormap | None = None,\n        colorbar: bool = True,\n        colorbar_ticks: ArrayLike | None = None,\n        colorbar_tick_labels: ArrayLike | None = None,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"right\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.2,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        selection_time_range: TimeRangeLike | None = None,\n        selection_color: str | None = Color(\"ec:earthcare\"),\n        selection_linestyle: str | None = \"dashed\",\n        selection_linewidth: float | int | None = 2.5,\n        selection_highlight: bool = False,\n        selection_highlight_inverted: bool = True,\n        selection_highlight_color: str = Color(\"white\"),\n        selection_highlight_alpha: float = 0.5,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n        ax_style_y: (\n            Literal[\"from_track_distance\", \"across_track_distance\", \"pixel\"] | None\n        ) = None,\n        show_nadir: bool = True,\n        nadir_color: ColorLike | None = \"red\",\n        nadir_linewidth: int | float = 1.5,\n        label_length: int = 25,\n        **kwargs,\n    ) -&gt; \"SwathFigure\":\n        if isinstance(value_range, Iterable):\n            if len(value_range) != 2:\n                raise ValueError(\n                    f\"invalid `value_range`: {value_range}, expecting (vmin, vmax)\"\n                )\n        else:\n            value_range = (None, None)\n\n        cmap = get_cmap(cmap)\n\n        if isinstance(cmap, Cmap) and cmap.categorical == True:\n            norm = cmap.norm\n        elif isinstance(norm, Normalize):\n            if log_scale == True and not isinstance(norm, LogNorm):\n                norm = LogNorm(norm.vmin, norm.vmax)\n            elif log_scale == False and isinstance(norm, LogNorm):\n                norm = Normalize(norm.vmin, norm.vmax)\n            if value_range[0] is not None:\n                norm.vmin = value_range[0]  # type: ignore\n            if value_range[1] is not None:\n                norm.vmax = value_range[1]  # type: ignore\n        else:\n            if log_scale == True:\n                norm = LogNorm(value_range[0], value_range[1])  # type: ignore\n            else:\n                norm = Normalize(value_range[0], value_range[1])  # type: ignore\n\n        assert isinstance(norm, Normalize)\n        value_range = (norm.vmin, norm.vmax)\n\n        if isinstance(swath, SwathData):\n            values = swath.values\n            time = swath.time\n            nadir_index = swath.nadir_index\n            latitude = swath.latitude\n            longitude = swath.longitude\n            label = swath.label\n            units = swath.units\n        elif (\n            values is None\n            or time is None\n            or nadir_index is None\n            or latitude is None\n            or longitude is None\n        ):\n            raise ValueError(\n                \"Missing required arguments. Provide either a `SwathData` or all of `values`, `time`, `nadir_index`, `latitude` and `longitude`\"\n            )\n\n        values = np.asarray(values)\n        time = np.asarray(time)\n        latitude = np.asarray(latitude)\n        longitude = np.asarray(longitude)\n\n        swath_data = SwathData(\n            values=values,\n            time=time,\n            latitude=latitude,\n            longitude=longitude,\n            nadir_index=nadir_index,\n            label=label,\n            units=units,\n        )\n\n        tmin_original = swath_data.time[0]\n        tmax_original = swath_data.time[-1]\n\n        if from_track_range is not None:\n            if isinstance(from_track_range, Iterable) and len(from_track_range) == 2:\n                from_track_range = list(from_track_range)\n                for i in [0, -1]:\n                    if from_track_range[i] is None:\n                        from_track_range[i] = swath_data.across_track_distance[i]\n            swath_data = swath_data.select_from_track_range(from_track_range)\n        else:\n            from_track_range = (\n                swath_data.across_track_distance[0],\n                swath_data.across_track_distance[-1],\n            )\n\n        if time_range is not None:\n            if isinstance(time_range, Iterable) and len(time_range) == 2:\n                time_range = list(time_range)\n                for i in [0, -1]:\n                    if time_range[i] is None:\n                        time_range[i] = to_timestamp(swath_data.time[i])\n                    else:\n                        time_range[i] = to_timestamp(time_range[i])\n            swath_data = swath_data.select_time_range(time_range)\n        else:\n            time_range = (swath_data.time[0], swath_data.time[-1])\n\n        values = swath_data.values\n        time = swath_data.time\n        latitude = swath_data.latitude\n        longitude = swath_data.longitude\n        across_track_distance = swath_data.across_track_distance\n        from_track_distance = swath_data.from_track_distance\n        label = swath_data.label\n        units = swath_data.units\n        nadir_index = swath_data.nadir_index\n\n        self.ax_style_y = ax_style_y or self.ax_style_y\n        if self.ax_style_y == \"from_track_distance\":\n            ydata = from_track_distance\n            ylabel = \"Distance from track\"\n        elif self.ax_style_y == \"across_track_distance\":\n            ydata = across_track_distance\n            ylabel = \"Distance\"\n        elif self.ax_style_y == \"pixel\":\n            ydata = np.arange(len(from_track_distance))\n            ylabel = \"Pixel\"\n        ynadir = ydata[nadir_index]\n\n        tmin = np.datetime64(time_range[0])\n        tmax = np.datetime64(time_range[1])\n\n        if len(values.shape) == 3 and values.shape[2] == 3:\n            mesh = self.ax.pcolormesh(\n                time,\n                ydata,\n                values,\n                rasterized=True,\n                **kwargs,\n            )\n        else:\n            mesh = self.ax.pcolormesh(\n                time,\n                ydata,\n                values.T,\n                norm=norm,\n                cmap=cmap,\n                rasterized=True,\n                **kwargs,\n            )\n\n            if colorbar:\n                cb_kwargs = dict(\n                    label=format_var_label(label, units, label_len=label_length),\n                    position=colorbar_position,\n                    alignment=colorbar_alignment,\n                    width=colorbar_width,\n                    spacing=colorbar_spacing,\n                    length_ratio=colorbar_length_ratio,\n                    label_outside=colorbar_label_outside,\n                    ticks_outside=colorbar_ticks_outside,\n                    ticks_both=colorbar_ticks_both,\n                )\n                if cmap.categorical:\n                    self.colorbar = add_colorbar(\n                        fig=self.fig,\n                        ax=self.ax,\n                        data=mesh,\n                        cmap=cmap,\n                        **cb_kwargs,  # type: ignore\n                    )\n                else:\n                    self.colorbar = add_colorbar(\n                        fig=self.fig,\n                        ax=self.ax,\n                        data=mesh,\n                        ticks=colorbar_ticks,\n                        tick_labels=colorbar_tick_labels,\n                        **cb_kwargs,  # type: ignore\n                    )\n\n        if selection_time_range is not None:\n            self.selection_time_range = validate_time_range(selection_time_range)\n\n            if selection_highlight:\n                if selection_highlight_inverted:\n                    self.ax.axvspan(  # type: ignore\n                        tmin,  # type: ignore\n                        self.selection_time_range[0],  # type: ignore\n                        color=selection_highlight_color,  # type: ignore\n                        alpha=selection_highlight_alpha,  # type: ignore\n                    )  # type: ignore\n                    self.ax.axvspan(  # type: ignore\n                        self.selection_time_range[1],  # type: ignore\n                        tmax,  # type: ignore\n                        color=selection_highlight_color,  # type: ignore\n                        alpha=selection_highlight_alpha,  # type: ignore\n                    )  # type: ignore\n                else:\n                    self.ax.axvspan(  # type: ignore\n                        self.selection_time_range[0],  # type: ignore\n                        self.selection_time_range[1],  # type: ignore\n                        color=selection_highlight_color,  # type: ignore\n                        alpha=selection_highlight_alpha,  # type: ignore\n                    )  # type: ignore\n\n            for t in self.selection_time_range:\n                self.ax.axvline(  # type: ignore\n                    x=t,  # type: ignore\n                    color=selection_color,  # type: ignore\n                    linestyle=selection_linestyle,  # type: ignore\n                    linewidth=selection_linewidth,  # type: ignore\n                )  # type: ignore\n\n        if show_nadir:\n            nadir_color = Color.from_optional(nadir_color)\n            nadir_color_shade = \"white\"\n            if isinstance(nadir_color, Color):\n                nadir_color_shade = nadir_color.get_best_bw_contrast_color()\n            nadir_line_shade = self.ax.axhline(\n                y=ynadir,\n                color=nadir_color_shade,\n                linestyle=\"solid\",\n                linewidth=nadir_linewidth * 2,\n                alpha=0.3,\n                zorder=10,\n            )\n            nadir_line = self.ax.axhline(\n                y=ynadir,\n                color=Color.from_optional(nadir_color),\n                linestyle=\"dashed\",\n                linewidth=nadir_linewidth,\n                zorder=10,\n            )\n\n        self.ax.set_xlim((tmin, tmax))  # type: ignore\n        # self.ax.set_ylim((hmin, hmax))\n\n        self.ax_right = self.ax.twinx()\n        self.ax_right.set_ylim(self.ax.get_ylim())\n\n        self.ax_top = self.ax.twiny()\n        self.ax_top.set_xlim(self.ax.get_xlim())\n\n        if self.ax_style_y == \"pixel\":\n            format_height_ticks(self.ax, label=ylabel, show_units=False)\n        else:\n            format_height_ticks(self.ax, label=ylabel)\n        format_height_ticks(\n            self.ax_right, show_tick_labels=False, show_units=False, label=\"\"\n        )\n\n        if ax_style_top is not None:\n            self.ax_style_top = AlongTrackAxisStyle.from_input(self.ax_style_top)\n        if ax_style_bottom is not None:\n            self.ax_style_bottom = AlongTrackAxisStyle.from_input(self.ax_style_bottom)\n\n        format_along_track_axis(\n            self.ax,\n            self.ax_style_bottom,\n            time,\n            tmin,\n            tmax,\n            tmin_original,\n            tmax_original,\n            longitude[:, nadir_index],\n            latitude[:, nadir_index],\n            num_ticks=self.num_ticks,\n        )\n        format_along_track_axis(\n            self.ax_top,\n            self.ax_style_top,\n            time,\n            tmin,\n            tmax,\n            tmin_original,\n            tmax_original,\n            longitude[:, nadir_index],\n            latitude[:, nadir_index],\n            num_ticks=self.num_ticks,\n        )\n\n        return self\n\n    def plot_contour(\n        self,\n        values: NDArray,\n        time: NDArray,\n        latitude: NDArray,\n        longitude: NDArray,\n        nadir_index: int,\n        label_levels: list | NDArray | None = None,\n        label_format: str | None = None,\n        levels: list | NDArray | None = None,\n        linewidths: int | float | list | NDArray | None = 1.5,\n        linestyles: str | list | NDArray | None = \"solid\",\n        colors: Color | str | list | NDArray | None = \"black\",\n        zorder: int | float | None = 2,\n        show_labels: bool = True,\n    ) -&gt; \"SwathFigure\":\n        \"\"\"Adds contour lines to the plot.\"\"\"\n        values = np.asarray(values)\n        time = np.asarray(time)\n        latitude = np.asarray(latitude)\n        longitude = np.asarray(longitude)\n\n        swath_data = SwathData(\n            values=values,\n            time=time,\n            latitude=latitude,\n            longitude=longitude,\n            nadir_index=nadir_index,\n        )\n\n        if isinstance(colors, str):\n            colors = Color.from_optional(colors)\n        elif isinstance(colors, (Iterable, np.ndarray)):\n            colors = [Color.from_optional(c) for c in colors]\n        else:\n            colors = Color.from_optional(colors)\n\n        values = swath_data.values\n        time = swath_data.time\n        latitude = swath_data.latitude\n        longitude = swath_data.longitude\n        across_track_distance = swath_data.across_track_distance\n        from_track_distance = swath_data.from_track_distance\n        # label = swath_data.label\n        # units = swath_data.units\n        nadir_index = swath_data.nadir_index\n\n        if self.ax_style_y == \"from_track_distance\":\n            ydata = from_track_distance\n        elif self.ax_style_y == \"across_track_distance\":\n            ydata = across_track_distance\n        elif self.ax_style_y == \"pixel\":\n            ydata = np.arange(len(from_track_distance))\n\n        x = time\n        y = ydata\n        z = values.T\n\n        if len(y.shape) == 2:\n            y = y[len(y) // 2]\n\n        cn = self.ax.contour(\n            x,\n            y,\n            z,\n            levels=levels,\n            linewidths=linewidths,\n            colors=colors,\n            linestyles=linestyles,\n            zorder=zorder,\n        )\n\n        if show_labels:\n            labels: Iterable[float]\n            if label_levels:\n                labels = [l for l in label_levels if l in cn.levels]\n            else:\n                labels = cn.levels\n\n            cl = self.ax.clabel(\n                cn,\n                labels,  # type: ignore\n                inline=True,\n                fmt=label_format,\n                fontsize=\"small\",\n                zorder=zorder,\n            )\n\n            bold_font = font_manager.FontProperties(weight=\"bold\")\n            for text in cl:\n                text.set_fontproperties(bold_font)\n\n            for l in cn.labelTexts:\n                l.set_rotation(0)\n\n        return self\n\n    def ecplot_coastline(\n        self,\n        ds: xr.Dataset,\n        var: str = \"land_flag\",\n        *,\n        time_var: str = TIME_VAR,\n        lat_var: str = SWATH_LAT_VAR,\n        lon_var: str = SWATH_LON_VAR,\n        color: ColorLike = \"#F3E490\",\n        linewidth: float | int = 0.5,\n    ):\n        return self.plot_contour(\n            values=ds[var].values,\n            time=ds[time_var].values,\n            latitude=ds[lat_var].values,\n            longitude=ds[lon_var].values,\n            nadir_index=int(ds.nadir_index.values),\n            levels=[0, 1],\n            colors=Color.from_optional(color),\n            show_labels=False,\n            linewidths=linewidth,\n        )\n\n    def ecplot(\n        self,\n        ds: xr.Dataset,\n        var: str,\n        *,\n        time_var: str = TIME_VAR,\n        lat_var: str = SWATH_LAT_VAR,\n        lon_var: str = SWATH_LON_VAR,\n        values: NDArray | None = None,\n        time: NDArray | None = None,\n        nadir_index: int | None = None,\n        latitude: NDArray | None = None,\n        longitude: NDArray | None = None,\n        show_info: bool = True,\n        info_text_loc: str | None = None,\n        # Common args for wrappers\n        value_range: ValueRangeLike | Literal[\"default\"] | None = \"default\",\n        log_scale: bool | None = None,\n        norm: Normalize | None = None,\n        time_range: TimeRangeLike | None = None,\n        from_track_range: DistanceRangeLike | None = None,\n        label: str | None = None,\n        units: str | None = None,\n        cmap: str | Colormap | None = None,\n        colorbar: bool = True,\n        colorbar_ticks: ArrayLike | None = None,\n        colorbar_tick_labels: ArrayLike | None = None,\n        colorbar_position: str | Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"right\",\n        colorbar_alignment: str | Literal[\"left\", \"center\", \"right\"] = \"center\",\n        colorbar_width: float = DEFAULT_COLORBAR_WIDTH,\n        colorbar_spacing: float = 0.2,\n        colorbar_length_ratio: float | str = \"100%\",\n        colorbar_label_outside: bool = True,\n        colorbar_ticks_outside: bool = True,\n        colorbar_ticks_both: bool = False,\n        selection_time_range: TimeRangeLike | None = None,\n        selection_color: str | None = Color(\"ec:earthcare\"),\n        selection_linestyle: str | None = \"dashed\",\n        selection_linewidth: float | int | None = 2.5,\n        selection_highlight: bool = False,\n        selection_highlight_inverted: bool = True,\n        selection_highlight_color: str = Color(\"white\"),\n        selection_highlight_alpha: float = 0.5,\n        ax_style_top: AlongTrackAxisStyle | str | None = None,\n        ax_style_bottom: AlongTrackAxisStyle | str | None = None,\n        ax_style_y: Literal[\n            \"from_track_distance\", \"across_track_distance\", \"pixel\"\n        ] = \"from_track_distance\",\n        show_nadir: bool = True,\n        nadir_color: ColorLike | None = \"black\",\n        nadir_linewidth: int | float = 1.5,\n        label_length: int = 25,\n        **kwargs,\n    ) -&gt; \"SwathFigure\":\n        # Collect all common args for wrapped plot function call\n        local_args = locals()\n        # Delete all args specific to this wrapper function\n        del local_args[\"self\"]\n        del local_args[\"ds\"]\n        del local_args[\"var\"]\n        del local_args[\"time_var\"]\n        del local_args[\"lat_var\"]\n        del local_args[\"lon_var\"]\n        del local_args[\"show_info\"]\n        del local_args[\"info_text_loc\"]\n        # Delete kwargs to then merge it with the residual common args\n        del local_args[\"kwargs\"]\n        all_args = {**local_args, **kwargs}\n\n        if all_args[\"values\"] is None:\n            all_args[\"values\"] = ds[var].values\n        if all_args[\"time\"] is None:\n            all_args[\"time\"] = ds[time_var].values\n        if all_args[\"nadir_index\"] is None:\n            all_args[\"nadir_index\"] = get_nadir_index(ds)\n        if all_args[\"latitude\"] is None:\n            all_args[\"latitude\"] = ds[lat_var].values\n        if all_args[\"longitude\"] is None:\n            all_args[\"longitude\"] = ds[lon_var].values\n\n        # Set default values depending on variable name\n        if label is None:\n            all_args[\"label\"] = (\n                \"Values\" if not hasattr(ds[var], \"long_name\") else ds[var].long_name\n            )\n        if units is None:\n            all_args[\"units\"] = \"-\" if not hasattr(ds[var], \"units\") else ds[var].units\n        if isinstance(value_range, str) and value_range == \"default\":\n            value_range = None\n            all_args[\"value_range\"] = None\n            if log_scale is None and norm is None:\n                all_args[\"norm\"] = get_default_norm(var, file_type=ds)\n        if cmap is None:\n            all_args[\"cmap\"] = get_default_cmap(var, file_type=ds)\n\n        ds = ensure_updated_msi_rgb_if_required(ds, var, time_range, time_var=time_var)\n\n        self.plot(**all_args)\n\n        self._set_info_text_loc(info_text_loc)\n        if show_info:\n            self.info_text = add_text_product_info(\n                self.ax, ds, append_to=self.info_text, loc=self.info_text_loc\n            )\n\n        return self\n\n    def to_texture(self) -&gt; \"SwathFigure\":\n        \"\"\"Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.\"\"\"\n        # Remove anchored text and other artist text objects\n        for artist in reversed(self.ax.artists):\n            if isinstance(artist, (Text, AnchoredOffsetbox)):\n                artist.remove()\n\n        # Completely remove axis ticks and labels\n        self.ax.axis(\"off\")\n\n        if self.ax_top:\n            self.ax_top.axis(\"off\")\n\n        if self.ax_right:\n            self.ax_right.axis(\"off\")\n\n        # Remove white frame around figure\n        self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n        # Remove colorbar\n        if self.colorbar:\n            self.colorbar.remove()\n\n        return self\n\n    def invert_xaxis(self) -&gt; \"SwathFigure\":\n        \"\"\"Invert the x-axis.\"\"\"\n        self.ax.invert_xaxis()\n        if self.ax_top:\n            self.ax_top.invert_xaxis()\n        return self\n\n    def invert_yaxis(self) -&gt; \"SwathFigure\":\n        \"\"\"Invert the y-axis.\"\"\"\n        self.ax.invert_yaxis()\n        if self.ax_right:\n            self.ax_right.invert_yaxis()\n        return self\n\n    def set_colorbar_tick_scale(\n        self,\n        multiplier: float | None = None,\n        fontsize: float | str | None = None,\n    ) -&gt; \"SwathFigure\":\n        _cb = self.colorbar\n        cb: Colorbar\n        if isinstance(_cb, Colorbar):\n            cb = _cb\n        else:\n            return self\n\n        if fontsize is not None:\n            cb.ax.tick_params(labelsize=fontsize)\n            return self\n\n        if multiplier is not None:\n            _fontsize = cb.ax.yaxis.get_ticklabels()[0].get_fontsize()\n            if isinstance(_fontsize, str):\n                fp = font_manager.FontProperties(size=_fontsize)\n                _fontsize = fp.get_size_in_points()\n            cb.ax.tick_params(labelsize=_fontsize * multiplier)\n        return self\n\n    def show(self) -&gt; None:\n        import IPython\n        import matplotlib.pyplot as plt\n        from IPython.display import display\n\n        if IPython.get_ipython() is not None:\n            display(self.fig)\n        else:\n            plt.show()\n\n    def save(\n        self,\n        filename: str = \"\",\n        filepath: str | None = None,\n        ds: xr.Dataset | None = None,\n        ds_filepath: str | None = None,\n        dpi: float | Literal[\"figure\"] = \"figure\",\n        orbit_and_frame: str | None = None,\n        utc_timestamp: TimestampLike | None = None,\n        use_utc_creation_timestamp: bool = False,\n        site_name: str | None = None,\n        hmax: int | float | None = None,\n        radius: int | float | None = None,\n        extra: str | None = None,\n        transparent_outside: bool = False,\n        verbose: bool = True,\n        print_prefix: str = \"\",\n        create_dirs: bool = False,\n        transparent_background: bool = False,\n        resolution: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n        Args:\n            figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n            filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n            filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n            ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n            ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n            pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n            dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n            orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n            site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n            extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n            transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n            verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n            print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n            create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n            transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n            **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n        \"\"\"\n        save_plot(\n            fig=self.fig,\n            filename=filename,\n            filepath=filepath,\n            ds=ds,\n            ds_filepath=ds_filepath,\n            dpi=dpi,\n            orbit_and_frame=orbit_and_frame,\n            utc_timestamp=utc_timestamp,\n            use_utc_creation_timestamp=use_utc_creation_timestamp,\n            site_name=site_name,\n            hmax=hmax,\n            radius=radius,\n            extra=extra,\n            transparent_outside=transparent_outside,\n            verbose=verbose,\n            print_prefix=print_prefix,\n            create_dirs=create_dirs,\n            transparent_background=transparent_background,\n            resolution=resolution,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api_ref/#earthcarekit.SwathFigure.invert_xaxis","title":"invert_xaxis","text":"<pre><code>invert_xaxis()\n</code></pre> <p>Invert the x-axis.</p> Source code in <code>earthcarekit/plot/figure/swath.py</code> <pre><code>def invert_xaxis(self) -&gt; \"SwathFigure\":\n    \"\"\"Invert the x-axis.\"\"\"\n    self.ax.invert_xaxis()\n    if self.ax_top:\n        self.ax_top.invert_xaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.SwathFigure.invert_yaxis","title":"invert_yaxis","text":"<pre><code>invert_yaxis()\n</code></pre> <p>Invert the y-axis.</p> Source code in <code>earthcarekit/plot/figure/swath.py</code> <pre><code>def invert_yaxis(self) -&gt; \"SwathFigure\":\n    \"\"\"Invert the y-axis.\"\"\"\n    self.ax.invert_yaxis()\n    if self.ax_right:\n        self.ax_right.invert_yaxis()\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.SwathFigure.plot_contour","title":"plot_contour","text":"<pre><code>plot_contour(\n    values,\n    time,\n    latitude,\n    longitude,\n    nadir_index,\n    label_levels=None,\n    label_format=None,\n    levels=None,\n    linewidths=1.5,\n    linestyles=\"solid\",\n    colors=\"black\",\n    zorder=2,\n    show_labels=True,\n)\n</code></pre> <p>Adds contour lines to the plot.</p> Source code in <code>earthcarekit/plot/figure/swath.py</code> <pre><code>def plot_contour(\n    self,\n    values: NDArray,\n    time: NDArray,\n    latitude: NDArray,\n    longitude: NDArray,\n    nadir_index: int,\n    label_levels: list | NDArray | None = None,\n    label_format: str | None = None,\n    levels: list | NDArray | None = None,\n    linewidths: int | float | list | NDArray | None = 1.5,\n    linestyles: str | list | NDArray | None = \"solid\",\n    colors: Color | str | list | NDArray | None = \"black\",\n    zorder: int | float | None = 2,\n    show_labels: bool = True,\n) -&gt; \"SwathFigure\":\n    \"\"\"Adds contour lines to the plot.\"\"\"\n    values = np.asarray(values)\n    time = np.asarray(time)\n    latitude = np.asarray(latitude)\n    longitude = np.asarray(longitude)\n\n    swath_data = SwathData(\n        values=values,\n        time=time,\n        latitude=latitude,\n        longitude=longitude,\n        nadir_index=nadir_index,\n    )\n\n    if isinstance(colors, str):\n        colors = Color.from_optional(colors)\n    elif isinstance(colors, (Iterable, np.ndarray)):\n        colors = [Color.from_optional(c) for c in colors]\n    else:\n        colors = Color.from_optional(colors)\n\n    values = swath_data.values\n    time = swath_data.time\n    latitude = swath_data.latitude\n    longitude = swath_data.longitude\n    across_track_distance = swath_data.across_track_distance\n    from_track_distance = swath_data.from_track_distance\n    # label = swath_data.label\n    # units = swath_data.units\n    nadir_index = swath_data.nadir_index\n\n    if self.ax_style_y == \"from_track_distance\":\n        ydata = from_track_distance\n    elif self.ax_style_y == \"across_track_distance\":\n        ydata = across_track_distance\n    elif self.ax_style_y == \"pixel\":\n        ydata = np.arange(len(from_track_distance))\n\n    x = time\n    y = ydata\n    z = values.T\n\n    if len(y.shape) == 2:\n        y = y[len(y) // 2]\n\n    cn = self.ax.contour(\n        x,\n        y,\n        z,\n        levels=levels,\n        linewidths=linewidths,\n        colors=colors,\n        linestyles=linestyles,\n        zorder=zorder,\n    )\n\n    if show_labels:\n        labels: Iterable[float]\n        if label_levels:\n            labels = [l for l in label_levels if l in cn.levels]\n        else:\n            labels = cn.levels\n\n        cl = self.ax.clabel(\n            cn,\n            labels,  # type: ignore\n            inline=True,\n            fmt=label_format,\n            fontsize=\"small\",\n            zorder=zorder,\n        )\n\n        bold_font = font_manager.FontProperties(weight=\"bold\")\n        for text in cl:\n            text.set_fontproperties(bold_font)\n\n        for l in cn.labelTexts:\n            l.set_rotation(0)\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.SwathFigure.save","title":"save","text":"<pre><code>save(\n    filename=\"\",\n    filepath=None,\n    ds=None,\n    ds_filepath=None,\n    dpi=\"figure\",\n    orbit_and_frame=None,\n    utc_timestamp=None,\n    use_utc_creation_timestamp=False,\n    site_name=None,\n    hmax=None,\n    radius=None,\n    extra=None,\n    transparent_outside=False,\n    verbose=True,\n    print_prefix=\"\",\n    create_dirs=False,\n    transparent_background=False,\n    resolution=None,\n    **kwargs\n)\n</code></pre> <p>Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure | HasFigure</code> <p>A figure object (<code>matplotlib.figure.Figure</code>) or objects exposing a <code>.fig</code> attribute containing a figure (e.g., <code>CurtainFigure</code>).</p> required <code>filename</code> <code>str</code> <p>The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.</p> <code>''</code> <code>filepath</code> <code>str | None</code> <p>The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.</p> <code>None</code> <code>ds</code> <code>Dataset | None</code> <p>A EarthCARE dataset from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>ds_filepath</code> <code>str | None</code> <p>A path to a EarthCARE product from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>pad</code> <code>float</code> <p>Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.</p> required <code>dpi</code> <code>float | figure</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.</p> <code>'figure'</code> <code>orbit_and_frame</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>utc_timestamp</code> <code>TimestampLike | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>use_utc_creation_timestamp</code> <code>bool</code> <p>Whether the time of image creation should be included in the file name. Defaults to False.</p> <code>False</code> <code>site_name</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>hmax</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>radius</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>extra</code> <code>str | None</code> <p>A custom string to be included in the file name. Defaults to None.</p> <code>None</code> <code>transparent_outside</code> <code>bool</code> <p>Whether the area outside figures should be transparent. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether the progress of image creation should be printed to the console. Defaults to True.</p> <code>True</code> <code>print_prefix</code> <code>str</code> <p>A prefix string to all console messages. Defaults to \"\".</p> <code>''</code> <code>create_dirs</code> <code>bool</code> <p>Whether images should be saved in a folder structure based on provided metadata. Defaults to False.</p> <code>False</code> <code>transparent_background</code> <code>bool</code> <p>Whether the background inside and outside of figures should be transparent. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments passed to wrapped function call of <code>matplotlib.pyplot.savefig</code>.</p> <code>{}</code> Source code in <code>earthcarekit/plot/figure/swath.py</code> <pre><code>def save(\n    self,\n    filename: str = \"\",\n    filepath: str | None = None,\n    ds: xr.Dataset | None = None,\n    ds_filepath: str | None = None,\n    dpi: float | Literal[\"figure\"] = \"figure\",\n    orbit_and_frame: str | None = None,\n    utc_timestamp: TimestampLike | None = None,\n    use_utc_creation_timestamp: bool = False,\n    site_name: str | None = None,\n    hmax: int | float | None = None,\n    radius: int | float | None = None,\n    extra: str | None = None,\n    transparent_outside: bool = False,\n    verbose: bool = True,\n    print_prefix: str = \"\",\n    create_dirs: bool = False,\n    transparent_background: bool = False,\n    resolution: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n    Args:\n        figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n        filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n        filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n        ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n        ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n        pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n        dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n        orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n        site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n        transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n        verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n        print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n        create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n        transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n        **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n    \"\"\"\n    save_plot(\n        fig=self.fig,\n        filename=filename,\n        filepath=filepath,\n        ds=ds,\n        ds_filepath=ds_filepath,\n        dpi=dpi,\n        orbit_and_frame=orbit_and_frame,\n        utc_timestamp=utc_timestamp,\n        use_utc_creation_timestamp=use_utc_creation_timestamp,\n        site_name=site_name,\n        hmax=hmax,\n        radius=radius,\n        extra=extra,\n        transparent_outside=transparent_outside,\n        verbose=verbose,\n        print_prefix=print_prefix,\n        create_dirs=create_dirs,\n        transparent_background=transparent_background,\n        resolution=resolution,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.SwathFigure.to_texture","title":"to_texture","text":"<pre><code>to_texture()\n</code></pre> <p>Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.</p> Source code in <code>earthcarekit/plot/figure/swath.py</code> <pre><code>def to_texture(self) -&gt; \"SwathFigure\":\n    \"\"\"Convert the figure to a texture by removing all axis ticks, labels, annotations, and text.\"\"\"\n    # Remove anchored text and other artist text objects\n    for artist in reversed(self.ax.artists):\n        if isinstance(artist, (Text, AnchoredOffsetbox)):\n            artist.remove()\n\n    # Completely remove axis ticks and labels\n    self.ax.axis(\"off\")\n\n    if self.ax_top:\n        self.ax_top.axis(\"off\")\n\n    if self.ax_right:\n        self.ax_right.axis(\"off\")\n\n    # Remove white frame around figure\n    self.fig.subplots_adjust(left=0, right=1, bottom=0, top=1)\n\n    # Remove colorbar\n    if self.colorbar:\n        self.colorbar.remove()\n\n    return self\n</code></pre>"},{"location":"api_ref/#earthcarekit.add_depol_ratio","title":"add_depol_ratio","text":"<pre><code>add_depol_ratio(\n    ds_anom,\n    rolling_w=20,\n    near_zero_tolerance=2e-07,\n    smooth=True,\n    skip_height_above_elevation=300,\n    depol_ratio_var=\"depol_ratio\",\n    cpol_cleaned_var=\"cpol_cleaned_for_depol_calculation\",\n    xpol_cleaned_var=\"xpol_cleaned_for_depol_calculation\",\n    depol_ratio_from_means_var=\"depol_ratio_from_means\",\n    cpol_var=\"mie_attenuated_backscatter\",\n    xpol_var=\"crosspolar_attenuated_backscatter\",\n    elevation_var=ELEVATION_VAR,\n    height_var=HEIGHT_VAR,\n    height_dim=VERTICAL_DIM,\n)\n</code></pre> <p>Compute depolarization ratio (<code>DPOL</code> = <code>XPOL</code>/<code>CPOL</code>) from attenuated backscatter signals.</p> <p>This function derives the depolarization ratio from cross-polarized (<code>XPOL</code>) and co-polarized (<code>CPOL</code>) attenuated backscatter signals. Signals below the surface are masked, by default with a vertical margin on 300 meters above elevation to remove potencial surface retrun. Also, signals are smoothed (or \"cleaned\") with a rolling mean, and near-zero divisions are suppressed. Cleaned <code>CPOL</code> and <code>XPOL</code> signals are stored alongside <code>DPOL</code>, and a secondary single depol. profile calculated from mean profiles is added (i.e., mean(<code>XPOL</code>)/mean(<code>CPOL</code>)).</p> <p>Parameters:</p> Name Type Description Default <code>ds_anom</code> <code>Dataset</code> <p>ATL_NOM_1B dataset containing cross- and co-polar attenuated backscatter.</p> required <code>rolling_w</code> <code>int</code> <p>Window size for rolling mean smoothing. Defaults to 20.</p> <code>20</code> <code>near_zero_tolerance</code> <code>float</code> <p>Tolerance for masking near-zero <code>CPOL</code> (i.e., denominators). Defaults to 2e-7.</p> <code>2e-07</code> <code>smooth</code> <code>bool</code> <p>Whether to apply rolling mean smoothing. Defaults to True.</p> <code>True</code> <code>skip_height_above_elevation</code> <code>int</code> <p>Vertical margin above surface elevation to mask in meters. Defaults to 300.</p> <code>300</code> <code>depol_ratio_var</code> <code>str</code> <p>Name for depol. ratio variable. Defaults to \"depol_ratio\".</p> <code>'depol_ratio'</code> <code>cpol_cleaned_var</code> <code>str</code> <p>Name for cleaned co-polar variable. Defaults to \"cpol_cleaned_for_depol_calculation\".</p> <code>'cpol_cleaned_for_depol_calculation'</code> <code>xpol_cleaned_var</code> <code>str</code> <p>Name for cleaned cross-polar variable. Defaults to \"xpol_cleaned_for_depol_calculation\".</p> <code>'xpol_cleaned_for_depol_calculation'</code> <code>depol_ratio_from_means_var</code> <code>str</code> <p>Name for ratio from mean profiles. Defaults to \"depol_ratio_from_means\".</p> <code>'depol_ratio_from_means'</code> <code>cpol_var</code> <code>str</code> <p>Input co-polar variable name. Defaults to \"mie_attenuated_backscatter\".</p> <code>'mie_attenuated_backscatter'</code> <code>xpol_var</code> <code>str</code> <p>Input cross-polar variable name. Defaults to \"crosspolar_attenuated_backscatter\".</p> <code>'crosspolar_attenuated_backscatter'</code> <code>elevation_var</code> <code>str</code> <p>Elevation variable name. Defaults to ELEVATION_VAR.</p> <code>ELEVATION_VAR</code> <code>height_var</code> <code>str</code> <p>Height variable name. Defaults to HEIGHT_VAR.</p> <code>HEIGHT_VAR</code> <code>height_dim</code> <code>str</code> <p>Height dimension name. Defaults to VERTICAL_DIM.</p> <code>VERTICAL_DIM</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset with added depol. ratio, cleaned <code>CPOL</code>/<code>XPOL</code> signals, and depol. ratio from mean profiles.</p> Source code in <code>earthcarekit/utils/read/product/level1/atl_nom_1b.py</code> <pre><code>def add_depol_ratio(\n    ds_anom: xr.Dataset,\n    rolling_w: int = 20,\n    near_zero_tolerance: float = 2e-7,\n    smooth: bool = True,\n    skip_height_above_elevation: int = 300,\n    depol_ratio_var: str = \"depol_ratio\",\n    cpol_cleaned_var: str = \"cpol_cleaned_for_depol_calculation\",\n    xpol_cleaned_var: str = \"xpol_cleaned_for_depol_calculation\",\n    depol_ratio_from_means_var: str = \"depol_ratio_from_means\",\n    cpol_var: str = \"mie_attenuated_backscatter\",\n    xpol_var: str = \"crosspolar_attenuated_backscatter\",\n    elevation_var: str = ELEVATION_VAR,\n    height_var: str = HEIGHT_VAR,\n    height_dim: str = VERTICAL_DIM,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Compute depolarization ratio (`DPOL` = `XPOL`/`CPOL`) from attenuated backscatter signals.\n\n    This function derives the depolarization ratio from cross-polarized (`XPOL`) and\n    co-polarized (`CPOL`) attenuated backscatter signals. Signals below the surface\n    are masked, by default with a vertical margin on 300 meters above elevation to remove\n    potencial surface retrun. Also, signals are smoothed (or \"cleaned\") with a rolling mean,\n    and near-zero divisions are suppressed. Cleaned `CPOL` and `XPOL` signals are stored alongside `DPOL`,\n    and a secondary single depol. profile calculated from mean profiles is added (i.e., mean(`XPOL`)/mean(`CPOL`)).\n\n    Args:\n        ds_anom (xr.Dataset): ATL_NOM_1B dataset containing cross- and co-polar attenuated backscatter.\n        rolling_w (int, optional): Window size for rolling mean smoothing. Defaults to 20.\n        near_zero_tolerance (float, optional): Tolerance for masking near-zero `CPOL` (i.e., denominators). Defaults to 2e-7.\n        smooth (bool, optional): Whether to apply rolling mean smoothing. Defaults to True.\n        skip_height_above_elevation (int, optional): Vertical margin above surface elevation to mask in meters. Defaults to 300.\n        depol_ratio_var (str, optional): Name for depol. ratio variable. Defaults to \"depol_ratio\".\n        cpol_cleaned_var (str, optional): Name for cleaned co-polar variable. Defaults to \"cpol_cleaned_for_depol_calculation\".\n        xpol_cleaned_var (str, optional): Name for cleaned cross-polar variable. Defaults to \"xpol_cleaned_for_depol_calculation\".\n        depol_ratio_from_means_var (str, optional): Name for ratio from mean profiles. Defaults to \"depol_ratio_from_means\".\n        cpol_var (str, optional): Input co-polar variable name. Defaults to \"mie_attenuated_backscatter\".\n        xpol_var (str, optional): Input cross-polar variable name. Defaults to \"crosspolar_attenuated_backscatter\".\n        elevation_var (str, optional): Elevation variable name. Defaults to ELEVATION_VAR.\n        height_var (str, optional): Height variable name. Defaults to HEIGHT_VAR.\n        height_dim (str, optional): Height dimension name. Defaults to VERTICAL_DIM.\n\n    Returns:\n        xr.Dataset: Dataset with added depol. ratio, cleaned `CPOL`/`XPOL` signals,\n            and depol. ratio from mean profiles.\n    \"\"\"\n    cpol_da = ds_anom[cpol_var].copy()\n    xpol_da = ds_anom[xpol_var].copy()\n    ds_anom[depol_ratio_var] = xpol_da / cpol_da\n    rename_var_info(\n        ds_anom,\n        depol_ratio_var,\n        name=depol_ratio_var,\n        long_name=\"Depol. ratio from cross- and co-polar atten. part. bsc.\",\n        units=\"\",\n    )\n\n    elevation = (\n        ds_anom[elevation_var].values.copy()[:, np.newaxis]\n        + skip_height_above_elevation\n    )\n    mask_surface = ds_anom[height_var].values[0].copy() &lt; elevation\n\n    xpol = ds_anom[xpol_var].values\n    cpol = ds_anom[cpol_var].values\n    xpol[mask_surface] = np.nan\n    cpol[mask_surface] = np.nan\n    if smooth:\n        xpol = rolling_mean_2d(xpol, rolling_w, axis=0)\n        cpol = rolling_mean_2d(cpol, rolling_w, axis=0)\n        near_zero_mask = np.isclose(cpol, 0, atol=near_zero_tolerance)\n        ds_anom[depol_ratio_var].values = xpol / cpol\n        ds_anom[depol_ratio_var].values[near_zero_mask] = np.nan\n    else:\n        ds_anom[depol_ratio_var].values = xpol / cpol\n\n    xpol[near_zero_mask] = np.nan\n    cpol[near_zero_mask] = np.nan\n\n    ds_anom[cpol_cleaned_var] = ds_anom[cpol_var].copy()\n    ds_anom[cpol_cleaned_var].values = cpol\n\n    ds_anom[xpol_cleaned_var] = ds_anom[xpol_var].copy()\n    ds_anom[xpol_cleaned_var].values = xpol\n\n    dpol_mean = nan_mean(xpol, axis=0) / nan_mean(cpol, axis=0)\n    ds_anom[depol_ratio_from_means_var] = xr.DataArray(\n        data=dpol_mean,\n        dims=[height_dim],\n        attrs=dict(\n            long_name=\"Depol. ratio from cross- and co-polar atten. part. bsc.\",\n            units=\"\",\n        ),\n    )\n\n    return ds_anom\n</code></pre>"},{"location":"api_ref/#earthcarekit.compare_bsc_ext_lr_depol","title":"compare_bsc_ext_lr_depol","text":"<pre><code>compare_bsc_ext_lr_depol(\n    input_ec,\n    input_ground=None,\n    time_var_ground=\"time\",\n    height_var_ground=\"height\",\n    bsc_var_ground=[],\n    ext_var_ground=[],\n    lr_var_ground=[],\n    depol_var_ground=[],\n    input_ec2=None,\n    input_ec3=None,\n    input_ec4=None,\n    input_ground2=None,\n    input_ground3=None,\n    input_ground4=None,\n    time_var_ground2=None,\n    height_var_ground2=None,\n    time_var_ground3=None,\n    height_var_ground3=None,\n    time_var_ground4=None,\n    height_var_ground4=None,\n    bsc_var_ground2=None,\n    ext_var_ground2=None,\n    lr_var_ground2=None,\n    depol_var_ground2=None,\n    bsc_var_ground3=None,\n    ext_var_ground3=None,\n    lr_var_ground3=None,\n    depol_var_ground3=None,\n    bsc_var_ground4=None,\n    ext_var_ground4=None,\n    lr_var_ground4=None,\n    depol_var_ground4=None,\n    site=None,\n    radius_km=100.0,\n    resolution=\"_low_resolution\",\n    resolution2=None,\n    resolution3=None,\n    resolution4=None,\n    height_range=(0, 30000.0),\n    selection_height_range=None,\n    selection_height_range_bsc=None,\n    selection_height_range_ext=None,\n    selection_height_range_lr=None,\n    selection_height_range_depol=None,\n    value_range_bsc=(0, 8e-06),\n    value_range_ext=(0, 0.0003),\n    value_range_lr=(0, 100),\n    value_range_depol=(0, 0.6),\n    colors_ec=[\"ec:red\", \"ec:orange\", \"ec:yellow\", \"ec:purple\"],\n    colors_ground=[\n        \"ec:blue\",\n        \"ec:darkblue\",\n        \"ec:lightgreen\",\n        \"ec:darkgreen\",\n        \"ec:purple\",\n    ],\n    linewidth_ec=1.5,\n    linewidth_ground=1.5,\n    linestyle_ec=\"solid\",\n    linestyle_ground=\"solid\",\n    label_ec=[],\n    label_ground=[],\n    alpha=1.0,\n    show_steps=DEFAULT_PROFILE_SHOW_STEPS,\n    show_error_ec=False,\n    to_mega=False,\n    single_figsize=(5 * CM_AS_INCH, 12 * CM_AS_INCH),\n    label_bsc=\"Bsc. coeff.\",\n    label_ext=\"Ext. coeff.\",\n    label_lr=\"Lidar ratio\",\n    label_depol=\"Depol. ratio\",\n    units_bsc=\"m$^{-1}$ sr$^{-1}$\",\n    units_ext=\"m$^{-1}$\",\n    units_lr=\"sr\",\n    units_depol=\"\",\n    verbose=True,\n)\n</code></pre> <p>Compares Lidar profiles from up to 3 EarthCARE source dataset an one ground-based dataset by creating plots and statistics dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>input_ec</code> <code>str | Dataset</code> <p>A opened EarthCARE or file path.</p> required <code>input_ground</code> <code>str | Dataset</code> <p>A opened ground-based NetCDF dataset or file path (e.g., PollyNET data).</p> <code>None</code> <code>time_var_ground</code> <code>str</code> <p>The name of the time variable in the ground-based dataset (e.g., for single profile PollyNET data use <code>\"start_time\"</code>). Defaults to <code>\"height\"</code>.</p> <code>'time'</code> <code>height_var_ground</code> <code>str</code> <p>The name of the height variable in the ground-based dataset. Defaults to <code>\"height\"</code>.</p> <code>'height'</code> <code>bsc_var_ground</code> <code>str | tuple | list[str | tuple]</code> <p>Backscatter variable name in the ground-based dataset. Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., <code>[(\"bsc\", \"bsc_err\"), (\"bsc2\", \"bsc2_err\"), ...]</code>). Defaults to empty list.</p> <code>[]</code> <code>ext_var_ground</code> <code>str | tuple | list[str | tuple]</code> <p>Extinction variable name in the ground-based dataset. Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., <code>[(\"ext\", \"ext_err\"), (\"ext2\", \"ext2_err\"), ...]</code>). Defaults to empty list.</p> <code>[]</code> <code>lr_var_ground</code> <code>str | tuple | list[str | tuple]</code> <p>Lidar ratio variable name in the ground-based dataset. Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., <code>[(\"lr\", \"lr_err\"), (\"lr2\", \"lr2_err\"), ...]</code>). Defaults to empty list.</p> <code>[]</code> <code>depol_var_ground</code> <code>str | tuple | list[str | tuple]</code> <p>Depol. ratio variable name in the ground-based dataset. Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., <code>[(\"depol\", \"depol_err\"), (\"depol2\", \"depol2_err\"), ...]</code>). Defaults to empty list.</p> <code>[]</code> <code>input_ec2</code> <code>str | Dataset</code> <p>An optional seconds EarthCARE dataset to compare. Defaults to None.</p> <code>None</code> <code>input_ec3</code> <code>str | Dataset</code> <p>An optional third EarthCARE dataset to compare. Defaults to None.</p> <code>None</code> <code>site</code> <code>GroundSite | str | None</code> <p>Ground site or location of the ground-based data as a <code>GroundSite</code> object or by name string (e.g., <code>\"mindelo\"</code>). Defaults to None.</p> <code>None</code> <code>radius_km</code> <code>float</code> <p>Radius around the ground site. Defaults to 100.0.</p> <code>100.0</code> <code>resolution</code> <code>str</code> <p>Sets the used resolution of the EarthCARE data if applicable (e.g., for A-EBD). Defaults to \"_low_resolution\".</p> <code>'_low_resolution'</code> <code>height_range</code> <code>tuple[float, float] | None</code> <p>Height range in meters to restrict the data for plotting. Defaults to (0, 30e3).</p> <code>(0, 30000.0)</code> <code>selection_height_range</code> <code>tuple[float, float] | None</code> <p>Height range in meters to select data for statistsics. Defaults to None.</p> <code>None</code> <code>selection_height_range_bsc</code> <code>tuple[float, float] | None</code> <p>Height range in meters to select bsc. data for statistsics. Defaults to None (i.e., <code>selection_height_range</code>).</p> <code>None</code> <code>selection_height_range_ext</code> <code>tuple[float, float] | None</code> <p>Height range in meters to select ext. data for statistsics. Defaults to None (i.e., <code>selection_height_range</code>).</p> <code>None</code> <code>selection_height_range_lr</code> <code>tuple[float, float] | None</code> <p>Height range in meters to select LR data for statistsics. Defaults to None (i.e., <code>selection_height_range</code>).</p> <code>None</code> <code>selection_height_range_depol</code> <code>tuple[float, float] | None</code> <p>Height range in meters to select depol. data for statistsics. Defaults to None (i.e., <code>selection_height_range</code>).</p> <code>None</code> <code>value_range_bsc</code> <code>ValueRangeLike | None</code> <p>Tuple setting minimum and maximum value on x-axis. Defaults to (0, 8e-6).</p> <code>(0, 8e-06)</code> <code>value_range_ext</code> <code>ValueRangeLike | None</code> <p>Tuple setting minimum and maximum value on x-axis. Defaults to (0, 3e-4).</p> <code>(0, 0.0003)</code> <code>value_range_lr</code> <code>ValueRangeLike | None</code> <p>Tuple setting minimum and maximum value on x-axis. Defaults to (0, 100).</p> <code>(0, 100)</code> <code>value_range_depol</code> <code>ValueRangeLike | None</code> <p>Tuple setting minimum and maximum value on x-axis. Defaults to (0, 0.6).</p> <code>(0, 0.6)</code> <code>colors_ec</code> <code>list[str]</code> <p>List of colors for the EarthCARE profiles.</p> <code>['ec:red', 'ec:orange', 'ec:yellow', 'ec:purple']</code> <code>colors_ground</code> <code>list[str]</code> <p>List of colors for the ground-based profiles.</p> <code>['ec:blue', 'ec:darkblue', 'ec:lightgreen', 'ec:darkgreen', 'ec:purple']</code> <code>linewidth_ec</code> <code>Number | list[Number]</code> <p>Value or list of line width for the EarthCARE profiles. Defaults to 1.5.</p> <code>1.5</code> <code>linewidth_ground</code> <code>Number | list[Number]</code> <p>Value or list of line width for the ground-based profiles. Defaults to 1.5.</p> <code>1.5</code> <code>linestyle_ec</code> <code>Number | list[Number]</code> <p>Value or list of line style for the EarthCARE profiles. Defaults to \"solid\".</p> <code>'solid'</code> <code>linestyle_ground</code> <code>Number | list[Number]</code> <p>Value or list of line style for the ground-based profiles. Defaults to \"solid\".</p> <code>'solid'</code> <code>label_ec</code> <code>list[str]</code> <p>List of legend labels for the EarthCARE profiles.</p> <code>[]</code> <code>label_ground</code> <code>list[str]</code> <p>List of legend labels for the ground-based profiles.</p> <code>[]</code> <code>alpha</code> <code>float</code> <p>Transparency value for the profile lines (value between 0 and 1). Defaults to 1.0.</p> <code>1.0</code> <code>show_steps</code> <code>bool</code> <p>If True, profiles will be plotted as step functions instead of bin centers.</p> <code>DEFAULT_PROFILE_SHOW_STEPS</code> <code>show_error_ec</code> <code>bool</code> <p>If True, plot error ribbons for EarthCARE profiles.</p> <code>False</code> <code>to_mega</code> <code>bool</code> <p>If Ture, converts bsc. and ext. data results (i.e., plot and statistics) to [Mm-1 sr-1] and [Mm-1]. Defaults to False.</p> <code>False</code> <code>single_figsize</code> <code>tuple[float, float]</code> <p>2-element tuple setting width and height of the subfigures (i.e., for each profile plot).</p> <code>(5 * CM_AS_INCH, 12 * CM_AS_INCH)</code> <code>label_bsc</code> <code>str</code> <p>Label displayed on the backscatter sub-figure. Defaults to \"Bsc. coeff.\".</p> <code>'Bsc. coeff.'</code> <code>label_ext</code> <code>str</code> <p>Label displayed on the extinction sub-figure. Defaults to \"Ext. coeff.\".</p> <code>'Ext. coeff.'</code> <code>label_lr</code> <code>str</code> <p>Label displayed on the lidar ratio sub-figure. Defaults to \"Lidar ratio\".</p> <code>'Lidar ratio'</code> <code>label_depol</code> <code>str</code> <p>Label displayed on the depol sub-figure. Defaults to \"Depol. ratio\".</p> <code>'Depol. ratio'</code> <code>units_bsc</code> <code>str</code> <p>Units displayed on the backscatter sub-figure. Defaults to \"m$^{-1}$ sr$^{-1}$\".</p> <code>'m$^{-1}$ sr$^{-1}$'</code> <code>units_ext</code> <code>str</code> <p>Units displayed on the extinction sub-figure. Defaults to \"m$^{-1}$\".</p> <code>'m$^{-1}$'</code> <code>units_lr</code> <code>str</code> <p>Units displayed on the lidar ratio sub-figure. Defaults to \"sr\".</p> <code>'sr'</code> <code>units_depol</code> <code>str</code> <p>Units displayed on the depol sub-figure. Defaults to \"\".</p> <code>''</code> <code>verbose</code> <code>bool</code> <p>Whether logs about processing steps appear in the console. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>results</code> <code>_CompareBscExtLRDepolResults</code> <p>An object containing the plot and statistical results. - <code>results.fig</code>: The <code>matplotlib</code> figure - <code>results.fig_bsc</code>: Backscatter subfigure as <code>ProfileFigure</code> - <code>results.fig_ext</code>: Extinction subfigure as <code>ProfileFigure</code> - <code>results.fig_lr</code>: Lidar ratio subfigure as <code>ProfileFigure</code> - <code>results.fig_depol</code>: Depol. ratio subfigure as <code>ProfileFigure</code> - <code>results.stats</code>: Statistical results as a <code>pandas.DataFrame</code></p> Source code in <code>earthcarekit/calval/_compare_bsc_ext_lr_depol.py</code> <pre><code>def compare_bsc_ext_lr_depol(\n    input_ec: str | xr.Dataset,\n    input_ground: str | xr.Dataset | None = None,\n    time_var_ground: str = \"time\",\n    height_var_ground: str = \"height\",\n    bsc_var_ground: str | tuple[str, str] | list[str | tuple[str, str]] = [],\n    ext_var_ground: str | tuple[str, str] | list[str | tuple[str, str]] = [],\n    lr_var_ground: str | tuple[str, str] | list[str | tuple[str, str]] = [],\n    depol_var_ground: str | tuple[str, str] | list[str | tuple[str, str]] = [],\n    input_ec2: str | xr.Dataset | None = None,\n    input_ec3: str | xr.Dataset | None = None,\n    input_ec4: str | xr.Dataset | None = None,\n    input_ground2: str | xr.Dataset | None = None,\n    input_ground3: str | xr.Dataset | None = None,\n    input_ground4: str | xr.Dataset | None = None,\n    time_var_ground2: str | None = None,\n    height_var_ground2: str | None = None,\n    time_var_ground3: str | None = None,\n    height_var_ground3: str | None = None,\n    time_var_ground4: str | None = None,\n    height_var_ground4: str | None = None,\n    bsc_var_ground2: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    ext_var_ground2: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    lr_var_ground2: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    depol_var_ground2: (\n        str | tuple[str, str] | list[str | tuple[str, str]] | None\n    ) = None,\n    bsc_var_ground3: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    ext_var_ground3: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    lr_var_ground3: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    depol_var_ground3: (\n        str | tuple[str, str] | list[str | tuple[str, str]] | None\n    ) = None,\n    bsc_var_ground4: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    ext_var_ground4: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    lr_var_ground4: str | tuple[str, str] | list[str | tuple[str, str]] | None = None,\n    depol_var_ground4: (\n        str | tuple[str, str] | list[str | tuple[str, str]] | None\n    ) = None,\n    site: GroundSite | str | None = None,\n    radius_km: float = 100.0,\n    resolution: str = \"_low_resolution\",\n    resolution2: str | None = None,\n    resolution3: str | None = None,\n    resolution4: str | None = None,\n    height_range: tuple[float, float] | None = (0, 30e3),\n    selection_height_range: tuple[float, float] | None = None,\n    selection_height_range_bsc: tuple[float, float] | None = None,\n    selection_height_range_ext: tuple[float, float] | None = None,\n    selection_height_range_lr: tuple[float, float] | None = None,\n    selection_height_range_depol: tuple[float, float] | None = None,\n    value_range_bsc: ValueRangeLike | None = (0, 8e-6),\n    value_range_ext: ValueRangeLike | None = (0, 3e-4),\n    value_range_lr: ValueRangeLike | None = (0, 100),\n    value_range_depol: ValueRangeLike | None = (0, 0.6),\n    colors_ec: list[str] = [\n        \"ec:red\",\n        \"ec:orange\",\n        \"ec:yellow\",\n        \"ec:purple\",\n    ],\n    colors_ground: list[str] = [\n        \"ec:blue\",\n        \"ec:darkblue\",\n        \"ec:lightgreen\",\n        \"ec:darkgreen\",\n        \"ec:purple\",\n    ],\n    linewidth_ec: list[float | int] | float | int = 1.5,\n    linewidth_ground: list[float | int] | float | int = 1.5,\n    linestyle_ec: list[str] | str = \"solid\",\n    linestyle_ground: list[str] | str = \"solid\",\n    label_ec: list[str | None] = [],\n    label_ground: list[str | None] = [],\n    alpha: float = 1.0,\n    show_steps: bool = DEFAULT_PROFILE_SHOW_STEPS,\n    show_error_ec: bool = False,\n    to_mega: bool = False,\n    single_figsize: tuple[float | int, float | int] = (5 * CM_AS_INCH, 12 * CM_AS_INCH),\n    label_bsc: str = \"Bsc. coeff.\",\n    label_ext: str = \"Ext. coeff.\",\n    label_lr: str = \"Lidar ratio\",\n    label_depol: str = \"Depol. ratio\",\n    units_bsc: str = \"m$^{-1}$ sr$^{-1}$\",\n    units_ext: str = \"m$^{-1}$\",\n    units_lr: str = \"sr\",\n    units_depol: str = \"\",\n    verbose: bool = True,\n) -&gt; _CompareBscExtLRDepolResults:\n    \"\"\"Compares Lidar profiles from up to 3 EarthCARE source dataset an one ground-based dataset by creating plots and statistics dataframe.\n\n    Args:\n        input_ec (str | xr.Dataset): A opened EarthCARE or file path.\n        input_ground (str | xr.Dataset, optional): A opened ground-based NetCDF dataset or file path (e.g., PollyNET data).\n        time_var_ground (str, optional): The name of the time variable in the ground-based dataset (e.g., for single profile PollyNET data use `\"start_time\"`). Defaults to `\"height\"`.\n        height_var_ground (str, optional): The name of the height variable in the ground-based dataset. Defaults to `\"height\"`.\n        bsc_var_ground (str | tuple | list[str | tuple], optional): Backscatter variable name in the ground-based dataset.\n            Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., `[(\"bsc\", \"bsc_err\"), (\"bsc2\", \"bsc2_err\"), ...]`). Defaults to empty list.\n        ext_var_ground (str | tuple | list[str | tuple], optional): Extinction variable name in the ground-based dataset.\n            Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., `[(\"ext\", \"ext_err\"), (\"ext2\", \"ext2_err\"), ...]`). Defaults to empty list.\n        lr_var_ground (str | tuple | list[str | tuple], optional): Lidar ratio variable name in the ground-based dataset.\n            Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., `[(\"lr\", \"lr_err\"), (\"lr2\", \"lr2_err\"), ...]`). Defaults to empty list.\n        depol_var_ground (str | tuple | list[str | tuple], optional): Depol. ratio variable name in the ground-based dataset.\n            Multiple variables can be provided as list. Variable errors can be provided as tuples (e.g., `[(\"depol\", \"depol_err\"), (\"depol2\", \"depol2_err\"), ...]`). Defaults to empty list.\n        input_ec2 (str | xr.Dataset, optional): An optional seconds EarthCARE dataset to compare. Defaults to None.\n        input_ec3 (str | xr.Dataset, optional): An optional third EarthCARE dataset to compare. Defaults to None.\n        site (GroundSite | str | None, optional): Ground site or location of the ground-based data as a `GroundSite` object or by name string (e.g., `\"mindelo\"`). Defaults to None.\n        radius_km (float, optional): Radius around the ground site. Defaults to 100.0.\n        resolution (str, optional): Sets the used resolution of the EarthCARE data if applicable (e.g., for A-EBD). Defaults to \"_low_resolution\".\n        height_range (tuple[float, float] | None, optional): Height range in meters to restrict the data for plotting. Defaults to (0, 30e3).\n        selection_height_range (tuple[float, float] | None, optional): Height range in meters to select data for statistsics. Defaults to None.\n        selection_height_range_bsc (tuple[float, float] | None, optional): Height range in meters to select bsc. data for statistsics. Defaults to None (i.e., `selection_height_range`).\n        selection_height_range_ext (tuple[float, float] | None, optional): Height range in meters to select ext. data for statistsics. Defaults to None (i.e., `selection_height_range`).\n        selection_height_range_lr (tuple[float, float] | None, optional): Height range in meters to select LR data for statistsics. Defaults to None (i.e., `selection_height_range`).\n        selection_height_range_depol (tuple[float, float] | None, optional): Height range in meters to select depol. data for statistsics. Defaults to None (i.e., `selection_height_range`).\n        value_range_bsc (ValueRangeLike | None, optional): Tuple setting minimum and maximum value on x-axis. Defaults to (0, 8e-6).\n        value_range_ext (ValueRangeLike | None, optional): Tuple setting minimum and maximum value on x-axis. Defaults to (0, 3e-4).\n        value_range_lr (ValueRangeLike | None, optional): Tuple setting minimum and maximum value on x-axis. Defaults to (0, 100).\n        value_range_depol (ValueRangeLike | None, optional): Tuple setting minimum and maximum value on x-axis. Defaults to (0, 0.6).\n        colors_ec (list[str], optional): List of colors for the EarthCARE profiles.\n        colors_ground (list[str], optional): List of colors for the ground-based profiles.\n        linewidth_ec (Number | list[Number], optional): Value or list of line width for the EarthCARE profiles. Defaults to 1.5.\n        linewidth_ground (Number | list[Number], optional): Value or list of line width for the ground-based profiles. Defaults to 1.5.\n        linestyle_ec (Number | list[Number], optional): Value or list of line style for the EarthCARE profiles. Defaults to \"solid\".\n        linestyle_ground (Number | list[Number], optional): Value or list of line style for the ground-based profiles. Defaults to \"solid\".\n        label_ec (list[str], optional): List of legend labels for the EarthCARE profiles.\n        label_ground (list[str], optional): List of legend labels for the ground-based profiles.\n        alpha (float, optional): Transparency value for the profile lines (value between 0 and 1). Defaults to 1.0.\n        show_steps (bool, optional): If True, profiles will be plotted as step functions instead of bin centers.\n        show_error_ec (bool, optional): If True, plot error ribbons for EarthCARE profiles.\n        to_mega (bool, optional): If Ture, converts bsc. and ext. data results (i.e., plot and statistics) to [Mm-1 sr-1] and [Mm-1]. Defaults to False.\n        single_figsize (tuple[float, float], optional): 2-element tuple setting width and height of the subfigures (i.e., for each profile plot).\n        label_bsc (str, optional): Label displayed on the backscatter sub-figure. Defaults to \"Bsc. coeff.\".\n        label_ext (str, optional): Label displayed on the extinction sub-figure. Defaults to \"Ext. coeff.\".\n        label_lr (str, optional): Label displayed on the lidar ratio sub-figure. Defaults to \"Lidar ratio\".\n        label_depol (str, optional): Label displayed on the depol sub-figure. Defaults to \"Depol. ratio\".\n        units_bsc (str, optional): Units displayed on the backscatter sub-figure. Defaults to \"m$^{-1}$ sr$^{-1}$\".\n        units_ext (str, optional): Units displayed on the extinction sub-figure. Defaults to \"m$^{-1}$\".\n        units_lr (str, optional): Units displayed on the lidar ratio sub-figure. Defaults to \"sr\".\n        units_depol (str, optional): Units displayed on the depol sub-figure. Defaults to \"\".\n        verbose (bool, optional): Whether logs about processing steps appear in the console. Defaults to True.\n\n    Returns:\n        results (_CompareBscExtLRDepolResults): An object containing the plot and statistical results.\n            - `results.fig`: The `matplotlib` figure\n            - `results.fig_bsc`: Backscatter subfigure as `ProfileFigure`\n            - `results.fig_ext`: Extinction subfigure as `ProfileFigure`\n            - `results.fig_lr`: Lidar ratio subfigure as `ProfileFigure`\n            - `results.fig_depol`: Depol. ratio subfigure as `ProfileFigure`\n            - `results.stats`: Statistical results as a `pandas.DataFrame`\n    \"\"\"\n    _logger = logging.getLogger()\n    ctx = nullcontext() if verbose else silence_logger(_logger)\n    with ctx:\n        _vars_main: list[str | tuple[str, str]] = _get_ec_vars(\n            input_ec,\n            resolution,\n            show_error=show_error_ec,\n        )\n        _closest: bool = _get_ec_is_closest(input_ec)\n\n        label = [\n            label_bsc,\n            label_ext,\n            label_lr,\n            label_depol,\n        ]\n\n        units = [\n            units_bsc,\n            units_ext,\n            units_lr,\n            units_depol,\n        ]\n\n        if not isinstance(resolution2, str):\n            resolution2 = resolution\n        if not isinstance(resolution3, str):\n            resolution3 = resolution\n        if not isinstance(resolution4, str):\n            resolution4 = resolution\n\n        if not isinstance(time_var_ground2, str):\n            time_var_ground2 = time_var_ground\n        if not isinstance(time_var_ground3, str):\n            time_var_ground3 = time_var_ground\n        if not isinstance(time_var_ground4, str):\n            time_var_ground4 = time_var_ground\n\n        if not isinstance(height_var_ground2, str):\n            height_var_ground2 = height_var_ground\n        if not isinstance(height_var_ground3, str):\n            height_var_ground3 = height_var_ground\n        if not isinstance(height_var_ground4, str):\n            height_var_ground4 = height_var_ground\n\n        if bsc_var_ground2 is None:\n            bsc_var_ground2 = bsc_var_ground\n        if bsc_var_ground3 is None:\n            bsc_var_ground3 = bsc_var_ground\n        if bsc_var_ground4 is None:\n            bsc_var_ground4 = bsc_var_ground\n\n        if ext_var_ground2 is None:\n            ext_var_ground2 = ext_var_ground\n        if ext_var_ground3 is None:\n            ext_var_ground3 = ext_var_ground\n        if ext_var_ground4 is None:\n            ext_var_ground4 = ext_var_ground\n\n        if lr_var_ground2 is None:\n            lr_var_ground2 = lr_var_ground\n        if lr_var_ground3 is None:\n            lr_var_ground3 = lr_var_ground\n        if lr_var_ground4 is None:\n            lr_var_ground4 = lr_var_ground\n\n        if depol_var_ground2 is None:\n            depol_var_ground2 = depol_var_ground\n        if depol_var_ground3 is None:\n            depol_var_ground3 = depol_var_ground\n        if depol_var_ground4 is None:\n            depol_var_ground4 = depol_var_ground\n\n        _vars_main2: list[str | tuple[str, str]] | None = None\n        _closest2: bool | None = None\n        if input_ec2 is not None:\n            _vars_main2 = _get_ec_vars(\n                input_ec2,\n                resolution2,\n                show_error=show_error_ec,\n            )\n            _closest2 = _get_ec_is_closest(input_ec2)\n\n        _vars_main3: list[str | tuple[str, str]] | None = None\n        _closest3: bool | None = None\n        if input_ec3 is not None:\n            _vars_main3 = _get_ec_vars(\n                input_ec3,\n                resolution3,\n                show_error=show_error_ec,\n            )\n            _closest3 = _get_ec_is_closest(input_ec3)\n\n        _vars_main4: list[str | tuple[str, str]] | None = None\n        _closest4: bool | None = None\n        if input_ec4 is not None:\n            _vars_main4 = _get_ec_vars(\n                input_ec4,\n                resolution4,\n                show_error=show_error_ec,\n            )\n            _closest4 = _get_ec_is_closest(input_ec4)\n\n        with (\n            read_product(input_ec) as ds_ec,\n            nullcontext(\n                None if input_ec2 is None else read_product(input_ec2)\n            ) as ds_ec2,\n            nullcontext(\n                None if input_ec3 is None else read_product(input_ec3)\n            ) as ds_ec3,\n            nullcontext(\n                None if input_ec4 is None else read_product(input_ec4)\n            ) as ds_ec4,\n            nullcontext(\n                None if input_ground is None else read_any(input_ground)\n            ) as ds_target,\n            nullcontext(\n                None if input_ground2 is None else read_any(input_ground2)\n            ) as ds_target2,\n            nullcontext(\n                None if input_ground3 is None else read_any(input_ground3)\n            ) as ds_target3,\n            nullcontext(\n                None if input_ground4 is None else read_any(input_ground4)\n            ) as ds_target4,\n        ):\n            _output = create_column_figure_layout(\n                ncols=4,\n                single_figsize=single_figsize,\n                margin=0.6,\n            )\n            fig = _output.fig\n            axs = _output.axs\n\n            vars_target: list[str | tuple[str, str] | list[str | tuple[str, str]]] = [\n                bsc_var_ground,\n                ext_var_ground,\n                lr_var_ground,\n                depol_var_ground,\n            ]\n\n            vars_target2: list[str | tuple[str, str] | list[str | tuple[str, str]]] = [\n                bsc_var_ground2,\n                ext_var_ground2,\n                lr_var_ground2,\n                depol_var_ground2,\n            ]\n\n            vars_target3: list[str | tuple[str, str] | list[str | tuple[str, str]]] = [\n                bsc_var_ground3,\n                ext_var_ground3,\n                lr_var_ground3,\n                depol_var_ground3,\n            ]\n\n            vars_target4: list[str | tuple[str, str] | list[str | tuple[str, str]]] = [\n                bsc_var_ground4,\n                ext_var_ground4,\n                lr_var_ground4,\n                depol_var_ground4,\n            ]\n\n            value_range: list = [\n                value_range_bsc,\n                value_range_ext,\n                value_range_lr,\n                value_range_depol,\n            ]\n\n            if selection_height_range_bsc is None:\n                selection_height_range_bsc = selection_height_range\n            if selection_height_range_ext is None:\n                selection_height_range_ext = selection_height_range\n            if selection_height_range_lr is None:\n                selection_height_range_lr = selection_height_range\n            if selection_height_range_depol is None:\n                selection_height_range_depol = selection_height_range\n\n            _selection_height_range = [\n                selection_height_range_bsc,\n                selection_height_range_ext,\n                selection_height_range_lr,\n                selection_height_range_depol,\n            ]\n\n            pfs: list[ProfileFigure] = []\n            dfs: list[pd.DataFrame] = []\n            for i in range(len(_vars_main)):\n                _flip_height_axis: bool = False\n                _show_height_ticks: bool = True\n                _show_height_label: bool = False\n\n                if i == 0:\n                    _show_height_label = True\n                    _show_height_ticks = True\n                _pf, _df = compare_ec_profiles_with_target(\n                    ds_ec=ds_ec,\n                    ds_ec2=ds_ec2,\n                    ds_ec3=ds_ec3,\n                    ds_ec4=ds_ec4,\n                    ds_target=ds_target,\n                    ds_target2=ds_target2,\n                    ds_target3=ds_target3,\n                    ds_target4=ds_target4,\n                    var_ec=_vars_main[i],\n                    var_ec2=None if _vars_main2 is None else _vars_main2[i],\n                    var_ec3=None if _vars_main3 is None else _vars_main3[i],\n                    var_ec4=None if _vars_main4 is None else _vars_main4[i],\n                    var_target=vars_target[i],\n                    var_target2=vars_target2[i],\n                    var_target3=vars_target3[i],\n                    var_target4=vars_target4[i],\n                    selection_height_range=_selection_height_range[i],\n                    height_range=height_range,\n                    site=site,\n                    radius_km=radius_km,\n                    closest=_closest,\n                    closest2=False if _closest2 is None else _closest2,\n                    closest3=False if _closest3 is None else _closest3,\n                    closest4=False if _closest4 is None else _closest4,\n                    time_var_target=time_var_ground,\n                    height_var_target=height_var_ground,\n                    time_var_target2=time_var_ground2,\n                    height_var_target2=height_var_ground2,\n                    time_var_target3=time_var_ground3,\n                    height_var_target3=height_var_ground3,\n                    time_var_target4=time_var_ground4,\n                    height_var_target4=height_var_ground4,\n                    ax=axs[i],\n                    label=label[i],\n                    units=units[i],\n                    value_range=value_range[i],\n                    flip_height_axis=_flip_height_axis,\n                    show_height_ticks=_show_height_ticks,\n                    show_height_label=_show_height_label,\n                    colors_ec=colors_ec,\n                    colors_ground=colors_ground,\n                    linewidth_ec=linewidth_ec,\n                    linewidth_ground=linewidth_ground,\n                    linestyle_ec=linestyle_ec,\n                    linestyle_ground=linestyle_ground,\n                    label_ec=label_ec,\n                    label_ground=label_ground,\n                    alpha=alpha,\n                    show_steps=show_steps,\n                    to_mega=False if i &gt; 1 else to_mega,\n                    single_figsize=single_figsize,\n                )\n                pfs.append(_pf)\n                dfs.append(_df)\n            df = pd.concat(dfs, ignore_index=True)\n\n    return _CompareBscExtLRDepolResults(\n        fig=fig,\n        fig_bsc=pfs[0],\n        fig_ext=pfs[1],\n        fig_lr=pfs[2],\n        fig_depol=pfs[3],\n        stats=df,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.create_column_figure_layout","title":"create_column_figure_layout","text":"<pre><code>create_column_figure_layout(ncols, single_figsize=(3, 8), margin=0.0)\n</code></pre> <p>Creates a figure with multiple subfigures arranged as columns in a single row, each containing one Axes.</p> <p>Parameters:</p> Name Type Description Default <code>ncols</code> <code>int</code> <p>Number of subfigures (columns) to create.</p> required <code>single_figsize</code> <code>tuple[float, float]</code> <p>Size (width, height) of each individual subfigure. Defaults to (3, 8).</p> <code>(3, 8)</code> <p>Returns:</p> Type Description <code>FigureLayoutColumns</code> <p>tuple[Figure, list[Axes]]: The parent figure and a list of Axes objects, one for each subfigure.</p> Source code in <code>earthcarekit/plot/figure/multi_panel/simple_columns.py</code> <pre><code>def create_column_figure_layout(\n    ncols: int,\n    single_figsize: tuple[float, float] = (3, 8),\n    margin: float = 0.0,\n) -&gt; FigureLayoutColumns:\n    \"\"\"\n    Creates a figure with multiple subfigures arranged as columns in a single row, each containing one Axes.\n\n    Args:\n        ncols (int): Number of subfigures (columns) to create.\n        single_figsize (tuple[float, float], optional): Size (width, height) of each individual subfigure.\n            Defaults to (3, 8).\n\n    Returns:\n        tuple[Figure, list[Axes]]: The parent figure and a list of Axes objects, one for each subfigure.\n    \"\"\"\n    fig: Figure = plt.figure(\n        figsize=(single_figsize[0] * ncols + (ncols - 1) * margin, single_figsize[1])\n    )\n    figs: np.ndarray\n    if ncols == 1:\n        figs = np.array([fig])\n    else:\n        width_ratios = [single_figsize[0]]\n        for c in range(ncols - 1):\n            width_ratios.extend([margin, single_figsize[0]])\n\n        figs = fig.subfigures(\n            1,\n            ncols + (ncols - 1),\n            wspace=0.0,\n            hspace=0.0,\n            width_ratios=width_ratios,\n        )\n    axs: list[Axes] = [\n        f.add_subplot([0, 0, 1, 1]) for i, f in enumerate(figs) if i % 2 == 0\n    ]\n\n    return FigureLayoutColumns(fig=fig, axs=axs)\n</code></pre>"},{"location":"api_ref/#earthcarekit.create_multi_figure_layout","title":"create_multi_figure_layout","text":"<pre><code>create_multi_figure_layout(\n    rows,\n    zoom_rows=None,\n    profile_rows=None,\n    map_rows=None,\n    wspace=1.2,\n    hspace=1.2,\n    wmain=FIGURE_WIDTH_CURTAIN,\n    hrow=FIGURE_HEIGHT_CURTAIN,\n    hswath=FIGURE_HEIGHT_SWATH,\n    hline=FIGURE_HEIGHT_LINE,\n    wprofile=FIGURE_WIDTH_PROFILE,\n    wmap=FIGURE_MAP_WIDTH,\n    wzoom=FIGURE_WIDTH_CURTAIN / 3.0,\n)\n</code></pre> <p>Creates a complex figure layout with columns for map, main, zoom, and profile panels (in that order from left to right).</p> <p>Each panel column can have a custom sequence of figure types (e.g., row heights), and the layout supports both uniform and per-gap horizontal/vertical spacing.</p> <p>Parameters:</p> Name Type Description Default <code>main_rows</code> <code>Sequence[FigureType | int]</code> <p>List of figure types for the rows of the main column.</p> required <code>zoom_rows</code> <code>Sequence[FigureType | int]</code> <p>List of figure types for the rows in the optional zoom column.</p> <code>None</code> <code>profile_rows</code> <code>Sequence[FigureType | int]</code> <p>List of figure types for the rows in the optional profile column.</p> <code>None</code> <code>map_rows</code> <code>Sequence[FigureType | int]</code> <p>List of figure types for the rows in the optional map column.</p> <code>None</code> <code>wspace</code> <code>float | Sequence[float]</code> <p>Horizontal spacing between columns. Can be a single value or list defining spacing before, between, and after columns.</p> <code>1.2</code> <code>hspace</code> <code>float | Sequence[float]</code> <p>Vertical spacing between rows. Similar behavior as <code>wspace</code>.</p> <code>1.2</code> <code>wmain</code> <code>float</code> <p>Width of the main column. Default is <code>FIGURE_WIDTH_CURTAIN</code>.</p> <code>FIGURE_WIDTH_CURTAIN</code> <code>hrow</code> <code>float</code> <p>Height of a standard row. Default is <code>FIGURE_HEIGHT_CURTAIN</code>.</p> <code>FIGURE_HEIGHT_CURTAIN</code> <code>hswath</code> <code>float</code> <p>Height of a <code>SwathFigure</code>-type row. Default is <code>FIGURE_HEIGHT_SWATH</code>.</p> <code>FIGURE_HEIGHT_SWATH</code> <code>wprofile</code> <code>float</code> <p>Width of the profile column.</p> <code>FIGURE_WIDTH_PROFILE</code> <code>wmap</code> <code>float</code> <p>Width of the map column.</p> <code>FIGURE_MAP_WIDTH</code> <code>wzoom</code> <code>float</code> <p>Width of the zoom column.</p> <code>FIGURE_WIDTH_CURTAIN / 3.0</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>FigureLayoutMapMainZoomProfile</code> <p>A tuple containing: - Figure: The matplotlib figure object. - Sequence[Axes]: Axes for map panels (may be empty). - Sequence[Axes]: Axes for main panels. - Sequence[Axes]: Axes for zoom panels (may be empty). - Sequence[Axes]: Axes for profile panels (may be empty).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided spacing sequences are of invalid length.</p> <code>TypeError</code> <p>If spacing arguments are of unsupported types.</p> Source code in <code>earthcarekit/plot/figure/multi_panel/map_main_zoom_profile_figure.py</code> <pre><code>def create_multi_figure_layout(\n    rows: Sequence[FigureType | int],\n    zoom_rows: Sequence[FigureType | int] | None = None,\n    profile_rows: Sequence[FigureType | int] | None = None,\n    map_rows: Sequence[FigureType | int] | None = None,\n    wspace: float | Sequence[float] = 1.2,\n    hspace: float | Sequence[float] = 1.2,\n    wmain: float = FIGURE_WIDTH_CURTAIN,\n    hrow: float = FIGURE_HEIGHT_CURTAIN,\n    hswath: float = FIGURE_HEIGHT_SWATH,\n    hline: float = FIGURE_HEIGHT_LINE,\n    wprofile: float = FIGURE_WIDTH_PROFILE,\n    wmap: float = FIGURE_MAP_WIDTH,\n    wzoom: float = FIGURE_WIDTH_CURTAIN / 3.0,\n) -&gt; FigureLayoutMapMainZoomProfile:\n    \"\"\"\n    Creates a complex figure layout with columns for map, main, zoom, and profile panels (in that order from left to right).\n\n    Each panel column can have a custom sequence of figure types (e.g., row heights), and the layout\n    supports both uniform and per-gap horizontal/vertical spacing.\n\n    Args:\n        main_rows (Sequence[FigureType | int]): List of figure types for the rows of the main column.\n        zoom_rows (Sequence[FigureType | int], optional): List of figure types for the rows in the optional zoom column.\n        profile_rows (Sequence[FigureType | int], optional): List of figure types for the rows in the optional profile column.\n        map_rows (Sequence[FigureType | int], optional): List of figure types for the rows in the optional map column.\n        wspace (float | Sequence[float], optional): Horizontal spacing between columns. Can be a single value\n            or list defining spacing before, between, and after columns.\n        hspace (float | Sequence[float], optional): Vertical spacing between rows. Similar behavior as `wspace`.\n        wmain (float, optional): Width of the main column. Default is `FIGURE_WIDTH_CURTAIN`.\n        hrow (float, optional): Height of a standard row. Default is `FIGURE_HEIGHT_CURTAIN`.\n        hswath (float, optional): Height of a `SwathFigure`-type row. Default is `FIGURE_HEIGHT_SWATH`.\n        wprofile (float, optional): Width of the profile column.\n        wmap (float, optional): Width of the map column.\n        wzoom (float, optional): Width of the zoom column.\n\n    Returns:\n        tuple: A tuple containing:\n            - Figure: The matplotlib figure object.\n            - Sequence[Axes]: Axes for map panels (may be empty).\n            - Sequence[Axes]: Axes for main panels.\n            - Sequence[Axes]: Axes for zoom panels (may be empty).\n            - Sequence[Axes]: Axes for profile panels (may be empty).\n\n    Raises:\n        ValueError: If the provided spacing sequences are of invalid length.\n        TypeError: If spacing arguments are of unsupported types.\n    \"\"\"\n    # Calculate number of columns\n    is_map_col: bool = isinstance(map_rows, list) and len(map_rows) &gt; 0\n    is_main_col: bool = isinstance(rows, list) and len(rows) &gt; 0\n    is_zoom_col: bool = isinstance(zoom_rows, list) and len(zoom_rows) &gt; 0\n    is_profile_col: bool = isinstance(profile_rows, list) and len(profile_rows) &gt; 0\n    col_present: list[bool] = [is_map_col, is_main_col, is_zoom_col, is_profile_col]\n\n    ncols: int = sum(col_present)\n\n    # Calculate number of rows\n    nrows_min: int = 0\n    if isinstance(map_rows, list):\n        for ft in map_rows:\n            nrows_min += 1\n            if ft == FigureType.MAP_2_ROW:\n                nrows_min += 1\n\n    nrows: int = max(nrows_min, len(rows))\n\n    # Calulate spaces between figures\n    def _calulate_spaces(\n        space: float | Sequence[float],\n        n: int,\n        name: str,\n        name_col_row: str,\n    ) -&gt; list[float]:\n        if isinstance(space, Sequence):\n            space = list(space)\n            if len(space) &lt; n - 1 or len(space) &gt; n + 1:\n                raise ValueError(\n                    f\"{name} was given as a list (size={len(space)}) and thus needs to have a size between number of {name_col_row} ({n}) -1 (i.e. only spaces between {name_col_row}) and +1 (i.e. spaces before, between and after {name_col_row}).\"\n                )\n            elif len(space) == n - 1:\n                space = [0.0] + space + [0.0]\n            elif len(space) == n:\n                space = space + [0.0]\n        elif isinstance(space, float):\n            space = [0.0] + [space] * (n - 1) + [0.0]\n        else:\n            raise TypeError(\n                f\"{name} has wrong type '{type(space).__name__}'. expected types: '{float.__name__}' or ''{list.__name__}'[{float.__name__}]'\"\n            )\n        return space\n\n    wspace = _calulate_spaces(wspace, ncols, \"wspace\", \"columns\")\n    hspace = _calulate_spaces(hspace, nrows, \"hspace\", \"rows\")\n\n    # Calculate size ratios of figures\n    def _get_ratios(\n        ratios_figs: list[float],\n        space: list[float],\n    ) -&gt; list[float]:\n        assert len(space) == len(ratios_figs) + 1\n\n        ratios: list[float] = []\n        for i, r in enumerate(ratios_figs):\n            ratios.append(space[i])\n            ratios.append(r)\n        ratios.append(space[-1])\n\n        return ratios\n\n    wratios_figs: list[float] = np.array([wmap, wmain, wzoom, wprofile])[\n        col_present\n    ].tolist()\n    hratios_figs: list[float] = []\n    for fig_type in rows:\n        if isinstance(fig_type, float):\n            hratios_figs.append(fig_type)\n        elif fig_type == FigureType.SWATH:\n            hratios_figs.append(hswath)\n        elif fig_type == FigureType.LINE:\n            hratios_figs.append(hline)\n        elif fig_type == FigureType.CURTAIN_75:\n            hratios_figs.append(hrow * 0.75)\n        elif fig_type == FigureType.CURTAIN_67:\n            hratios_figs.append(hrow * 0.666666667)\n        elif fig_type == FigureType.CURTAIN_50:\n            hratios_figs.append(hrow * 0.50)\n        elif fig_type == FigureType.CURTAIN_33:\n            hratios_figs.append(hrow * 0.333333333)\n        elif fig_type == FigureType.CURTAIN_25:\n            hratios_figs.append(hrow * 0.25)\n        else:\n            hratios_figs.append(hrow)\n    if len(rows) &lt; nrows_min:\n        for i in range(nrows_min - len(rows)):\n            hratios_figs.append(hrow)\n\n    wratios = _get_ratios(wratios_figs, wspace)\n    hratios = _get_ratios(hratios_figs, hspace)\n\n    # Create the figure\n    wfig = sum(wratios)\n    hfig = sum(hratios)\n    figsize = (wfig, hfig)\n\n    fig = plt.figure(figsize=figsize)\n\n    # Create the grid layout\n    gs = gridspec.GridSpec(\n        nrows=len(hratios),\n        ncols=len(wratios),\n        width_ratios=wratios,\n        height_ratios=hratios,\n        figure=fig,\n        wspace=0,\n        hspace=0,\n        bottom=0.0,\n        top=1.0,\n        right=1.0,\n        left=0.0,\n    )\n\n    # Create the plots\n    # Create maps\n    current_col: int = 1\n    current_row: int = 1\n    axs_map: list[Axes] = []\n    axs_main: list[Axes] = []\n    axs_zoom: list[Axes] = []\n    axs_profile: list[Axes] = []\n    ax: Axes | None\n    if isinstance(map_rows, list):\n        for fig_type in map_rows:\n            if fig_type == FigureType.MAP_2_ROW:\n                ax = fig.add_subplot(gs[current_row : current_row + 3, current_col])\n                current_row += 2\n            elif fig_type == FigureType.NONE:\n                ax = None\n            else:\n                ax = fig.add_subplot(gs[current_row, current_col])\n            if isinstance(ax, Axes):\n                axs_map.append(ax)\n            current_row += 2\n        current_col += 2\n        current_row = 1\n\n    if isinstance(rows, list):\n        for fig_type in rows:\n            if fig_type == FigureType.NONE:\n                ax = None\n            else:\n                ax = fig.add_subplot(gs[current_row, current_col])\n            if isinstance(ax, Axes):\n                axs_main.append(ax)\n            current_row += 2\n        current_col += 2\n        current_row = 1\n\n    if isinstance(zoom_rows, list):\n        for fig_type in zoom_rows:\n            if fig_type == FigureType.NONE:\n                ax = None\n            else:\n                ax = fig.add_subplot(gs[current_row, current_col])\n            if isinstance(ax, Axes):\n                axs_zoom.append(ax)\n            current_row += 2\n        current_col += 2\n        current_row = 1\n\n    if isinstance(profile_rows, list):\n        for fig_type in profile_rows:\n            if fig_type == FigureType.NONE:\n                ax = None\n            else:\n                ax = fig.add_subplot(gs[current_row, current_col])\n            if isinstance(ax, Axes):\n                axs_profile.append(ax)\n            current_row += 2\n        current_col += 2\n        current_row = 1\n\n    return FigureLayoutMapMainZoomProfile(\n        fig=fig,\n        axs_map=axs_map,\n        axs=axs_main,\n        axs_zoom=axs_zoom,\n        axs_profile=axs_profile,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.ecquicklook","title":"ecquicklook","text":"<pre><code>ecquicklook(\n    ds,\n    vars=None,\n    show_maps=True,\n    show_zoom=False,\n    show_profile=True,\n    site=None,\n    radius_km=100.0,\n    time_range=None,\n    height_range=None,\n    ds_tropopause=None,\n    ds_elevation=None,\n    ds_temperature=None,\n    resolution=\"medium\",\n    ds2=None,\n    ds_xmet=None,\n    logger=None,\n    log_msg_prefix=\"\",\n    selection_max_time_margin=None,\n    show_steps=DEFAULT_PROFILE_SHOW_STEPS,\n    mode=\"fast\",\n)\n</code></pre> <p>Generate a preview visualization of an EarthCARE dataset with optional maps, zoomed views, and profiles.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset | str</code> <p>EarthCARE dataset or path.</p> required <code>vars</code> <code>(str | list[str] | None, otional)</code> <p>List of variable to plot. Automatically sets product-specific default list of variables if None.</p> <code>None</code> <code>show_maps</code> <code>bool</code> <p>Whether to include map view. Dafaults to True.</p> <code>True</code> <code>show_zoom</code> <code>bool</code> <p>Whether to show an additional column of zoomed plots. Defaults to False.</p> <code>False</code> <code>show_profile</code> <code>bool</code> <p>Whether to include vertical profile plots. Dfaults to True.</p> <code>True</code> <code>site</code> <code>GroundSite | str | None</code> <p>Ground site object or name identifier.</p> <code>None</code> <code>radius_km</code> <code>float</code> <p>Search radius around site in kilometers. Defaults to 100.</p> <code>100.0</code> <code>time_range</code> <code>TimeRangeLike | None</code> <p>Time range filter.</p> <code>None</code> <code>height_range</code> <code>DistanceRangeNoneLike | None</code> <p>Height range in meters. Defaults to None.</p> <code>None</code> <code>ds_tropopause</code> <code>Dataset | str | None</code> <p>Optional dataset or path containing tropopause data to add it to the plot.</p> <code>None</code> <code>ds_elevation</code> <code>Dataset | str | None</code> <p>Optional dataset or path containing elevation data to add it to the plot.</p> <code>None</code> <code>ds_temperature</code> <code>Dataset | str | None</code> <p>Optional dataset or path containing temperature data to add it to the plot.</p> <code>None</code> <code>resolution</code> <code>Literal['low', 'medium', 'high', 'l', 'm', 'h']</code> <p>Resolution of A-PRO data. Defaults to \"low\".</p> <code>'medium'</code> <code>ds2</code> <code>Dataset | str | None</code> <p>Secondary dataset required for certain product quicklook (e.g., A-LAY products need A-NOM or A-EBD to serve as background curtain plots).</p> <code>None</code> <code>ds_xmet</code> <code>Dataset | str | None</code> <p>Optional auxiliary meteorological dataset used to plot tropopause, elevation and temperature from.</p> <code>None</code> <code>logger</code> <code>Logger</code> <p>Logger instance for output messages.</p> <code>None</code> <code>log_msg_prefix</code> <code>str</code> <p>Prefix for log messages.</p> <code>''</code> <code>selection_max_time_margin</code> <code>TimedeltaLike | Sequence[TimedeltaLike] | None</code> <p>Allowed time difference for selection.</p> <code>None</code> <code>show_steps</code> <code>bool</code> <p>Whether to plot profiles as height bin step functions or instead plot only the line through bin centers. Defaults to True.</p> <code>DEFAULT_PROFILE_SHOW_STEPS</code> <code>mode</code> <code>Literal['fast', 'exact']</code> <p>Processing mode.</p> <code>'fast'</code> <p>Returns:</p> Name Type Description <code>_QuicklookResults</code> <code>QuicklookFigure</code> <p>Object containing figures and metadata.</p> Source code in <code>earthcarekit/plot/quicklook/_quicklook.py</code> <pre><code>def ecquicklook(\n    ds: xr.Dataset | str,\n    vars: str | list[str] | None = None,\n    show_maps: bool = True,\n    show_zoom: bool = False,\n    show_profile: bool = True,\n    site: GroundSite | str | None = None,\n    radius_km: float = 100.0,\n    time_range: TimeRangeLike | None = None,\n    height_range: DistanceRangeNoneLike | None = None,\n    ds_tropopause: xr.Dataset | str | None = None,\n    ds_elevation: xr.Dataset | str | None = None,\n    ds_temperature: xr.Dataset | str | None = None,\n    resolution: Literal[\"low\", \"medium\", \"high\", \"l\", \"m\", \"h\"] = \"medium\",\n    ds2: xr.Dataset | str | None = None,\n    ds_xmet: xr.Dataset | str | None = None,\n    logger: Logger | None = None,\n    log_msg_prefix: str = \"\",\n    selection_max_time_margin: TimedeltaLike | Sequence[TimedeltaLike] | None = None,\n    show_steps: bool = DEFAULT_PROFILE_SHOW_STEPS,\n    mode: Literal[\"fast\", \"exact\"] = \"fast\",\n) -&gt; QuicklookFigure:\n    \"\"\"\n    Generate a preview visualization of an EarthCARE dataset with optional maps, zoomed views, and profiles.\n\n    Args:\n        ds (xr.Dataset | str): EarthCARE dataset or path.\n        vars (str | list[str] | None, otional): List of variable to plot. Automatically sets product-specific default list of variables if None.\n        show_maps (bool, optional): Whether to include map view. Dafaults to True.\n        show_zoom (bool, optional): Whether to show an additional column of zoomed plots. Defaults to False.\n        show_profile (bool, optional): Whether to include vertical profile plots. Dfaults to True.\n        site (GroundSite | str | None, optional): Ground site object or name identifier.\n        radius_km (float, optional): Search radius around site in kilometers. Defaults to 100.\n        time_range (TimeRangeLike | None, optional): Time range filter.\n        height_range (DistanceRangeNoneLike | None, optional): Height range in meters. Defaults to None.\n        ds_tropopause (xr.Dataset | str | None, optional): Optional dataset or path containing tropopause data to add it to the plot.\n        ds_elevation (xr.Dataset | str | None, optional): Optional dataset or path containing elevation data to add it to the plot.\n        ds_temperature (xr.Dataset | str | None, optional): Optional dataset or path containing temperature data to add it to the plot.\n        resolution (Literal[\"low\", \"medium\", \"high\", \"l\", \"m\", \"h\"], optional): Resolution of A-PRO data. Defaults to \"low\".\n        ds2 (xr.Dataset | str | None, optional): Secondary dataset required for certain product quicklook (e.g., A-LAY products need A-NOM or A-EBD to serve as background curtain plots).\n        ds_xmet (xr.Dataset | str | None, optional): Optional auxiliary meteorological dataset used to plot tropopause, elevation and temperature from.\n        logger (Logger, optional): Logger instance for output messages.\n        log_msg_prefix (str, optional): Prefix for log messages.\n        selection_max_time_margin (TimedeltaLike | Sequence[TimedeltaLike] | None, optional): Allowed time difference for selection.\n        show_steps (bool, optional): Whether to plot profiles as height bin step functions or instead plot only the line through bin centers. Defaults to True.\n        mode (Literal[\"fast\", \"exact\"], optional): Processing mode.\n\n    Returns:\n        _QuicklookResults: Object containing figures and metadata.\n    \"\"\"\n    if isinstance(vars, str):\n        vars = [vars]\n\n    filepath: str | None = None\n    if isinstance(ds, str):\n        filepath = ds\n\n    ds = read_product(ds, in_memory=True)\n    file_type = FileType.from_input(ds)\n\n    if isinstance(ds_xmet, (xr.Dataset, str)):\n        ds_xmet = read_product(ds_xmet, in_memory=True)\n        if file_type in [\n            FileType.ATL_NOM_1B,\n            FileType.ATL_FM__2A,\n            FileType.ATL_AER_2A,\n            FileType.ATL_EBD_2A,\n            FileType.ATL_ICE_2A,\n            FileType.ATL_TC__2A,\n            FileType.ATL_CLA_2A,\n            FileType.CPR_NOM_1B,\n        ]:\n            ds_xmet = rebin_xmet_to_vertical_track(ds_xmet, ds)\n\n    ds_tropopause, ds_elevation, ds_temperature = _get_addon_ds(\n        ds,\n        filepath,\n        ds_tropopause or ds_xmet,\n        ds_elevation or ds_xmet,\n        ds_temperature or ds_xmet,\n    )\n\n    kwargs = dict(\n        ds=ds,\n        vars=vars,\n        show_maps=show_maps,\n        show_zoom=show_zoom,\n        show_profile=show_profile,\n        site=site,\n        radius_km=radius_km,\n        time_range=time_range,\n        height_range=height_range,\n        ds_tropopause=ds_tropopause,\n        ds_elevation=ds_elevation,\n        ds_temperature=ds_temperature,\n        logger=logger,\n        log_msg_prefix=log_msg_prefix,\n        selection_max_time_margin=selection_max_time_margin,\n        mode=mode,\n    )\n\n    if file_type == FileType.ATL_NOM_1B:\n        kwargs[\"show_steps\"] = show_steps\n        return ecquicklook_anom(**kwargs)  # type: ignore\n    elif file_type == FileType.ATL_EBD_2A:\n        kwargs[\"show_steps\"] = show_steps\n        kwargs[\"resolution\"] = resolution\n        return ecquicklook_aebd(**kwargs)  # type: ignore\n    elif file_type == FileType.ATL_AER_2A:\n        kwargs[\"show_steps\"] = show_steps\n        kwargs[\"resolution\"] = resolution\n        return ecquicklook_aaer(**kwargs)  # type: ignore\n    elif file_type == FileType.ATL_TC__2A:\n        return ecquicklook_atc(**kwargs)  # type: ignore\n    elif file_type == FileType.ATL_CTH_2A:\n\n        if ds2 is not None:\n            ds2 = read_product(ds2, in_memory=True)\n            file_type2 = FileType.from_input(ds2)\n            if file_type2 in [\n                FileType.ATL_NOM_1B,\n                FileType.ATL_EBD_2A,\n                FileType.ATL_AER_2A,\n                FileType.ATL_TC__2A,\n            ]:\n                kwargs[\"ds_bg\"] = ds2\n                kwargs[\"resolution\"] = resolution\n                return ecquicklook_acth(**kwargs)  # type: ignore\n            raise ValueError(\n                f\"There is no CTH background curtain plotting for {str(file_type2)} products. Use instead: {str(FileType.ATL_NOM_1B)}, {str(FileType.ATL_EBD_2A)}, {str(FileType.ATL_AER_2A)}, {str(FileType.ATL_TC__2A)}\"\n            )\n        raise TypeError(f\"\"\"Missing dataset \"ds2\" to plot a background for the CTH\"\"\")\n    elif file_type == FileType.CPR_FMR_2A:\n        return ecquicklook_cfmr(**kwargs)  # type: ignore\n    elif file_type == FileType.CPR_CD__2A:\n        return ecquicklook_ccd(**kwargs)  # type: ignore\n    elif file_type == FileType.CPR_CLD_2A:\n        return ecquicklook_ccld(**kwargs)  # type: ignore\n    elif file_type == FileType.CPR_TC__2A:\n        return ecquicklook_ctc(**kwargs)  # type: ignore\n    elif file_type == FileType.AC__TC__2B:\n        return ecquicklook_actc(**kwargs)  # type: ignore\n    elif file_type == FileType.ACM_CAP_2B:\n        return ecquicklook_acmcap(**kwargs)  # type: ignore\n    raise NotImplementedError()\n</code></pre>"},{"location":"api_ref/#earthcarekit.geodesic","title":"geodesic","text":"<pre><code>geodesic(a, b, units='km', tolerance=1e-12, max_iterations=10)\n</code></pre> <p>Calculates the geodesic distances between points on Earth (i.e. WSG 84 ellipsoid) using Vincenty's inverse method.</p> <p>Supports single or sequences of coordiates.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ArrayLike</code> <p>Coordinates [lat, lon] or array of shape (N, 2), in decimal degrees.</p> required <code>b</code> <code>ArrayLike</code> <p>Second coordinates, same format/shape as <code>a</code>.</p> required <code>units</code> <code>str</code> <p>Output units, \"km\" (default) or \"m\".</p> <code>'km'</code> <code>tolerance</code> <code>float</code> <p>Convergence threshold in radians. Default is 1e-12.</p> <code>1e-12</code> <code>max_iterations</code> <code>int</code> <p>Maximum iterations before failure. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>float64 | NDArray[float64]</code> <p>float or np.ndarray: The geodesic distance or distances between the point in <code>a</code> and <code>b</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input shapes are incompatible or units are invalid.</p> Note <p>Uses WGS84 (a=6378137.0 m, f=1/298.257223563). May fail for nearly antipodal points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geodesic([51.352757, 12.43392], [38.559, 68.856])\n4548.675334434374\n&gt;&gt;&gt; geodesic([0,0], [[0,0], [10,0], [20,0]])\narray([   0.        , 1105.85483324, 2212.36625417])\n&gt;&gt;&gt; geodesic([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\narray([0., 0., 0.])\n</code></pre> References <p>Vincenty, T. (1975). \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations.\" Survey Review, 23(176), 88-93. https://doi.org/10.1179/sre.1975.23.176.88</p> Source code in <code>earthcarekit/utils/geo/distance/_vincenty.py</code> <pre><code>def vincenty(\n    a: ArrayLike,\n    b: ArrayLike,\n    units: str = \"km\",\n    tolerance: float = 1e-12,\n    max_iterations: int = 10,\n) -&gt; np.float64 | NDArray[np.float64]:\n    \"\"\"\n    Calculates the geodesic distances between points on Earth (i.e. WSG 84 ellipsoid) using Vincenty's inverse method.\n\n    Supports single or sequences of coordiates.\n\n    Args:\n        a (ArrayLike): Coordinates [lat, lon] or array of shape (N, 2), in decimal degrees.\n        b (ArrayLike): Second coordinates, same format/shape as `a`.\n        units (str, optional): Output units, \"km\" (default) or \"m\".\n        tolerance (float, optional): Convergence threshold in radians. Default is 1e-12.\n        max_iterations (int, optional): Maximum iterations before failure. Default is 10.\n\n    Returns:\n        float or np.ndarray: The geodesic distance or distances between the point in `a` and `b`.\n\n    Raises:\n        ValueError: If input shapes are incompatible or units are invalid.\n\n    Note:\n        Uses WGS84 (a=6378137.0 m, f=1/298.257223563). May fail for nearly antipodal points.\n\n    Examples:\n        &gt;&gt;&gt; geodesic([51.352757, 12.43392], [38.559, 68.856])\n        4548.675334434374\n        &gt;&gt;&gt; geodesic([0,0], [[0,0], [10,0], [20,0]])\n        array([   0.        , 1105.85483324, 2212.36625417])\n        &gt;&gt;&gt; geodesic([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\n        array([0., 0., 0.])\n\n    References:\n        Vincenty, T. (1975). \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application\n        of nested equations.\" Survey Review, 23(176), 88-93. https://doi.org/10.1179/sre.1975.23.176.88\n    \"\"\"\n    _a, _b = map(np.asarray, [a, b])\n    coord_a, coord_b = map(np.atleast_2d, [_a, _b])\n    coord_a, coord_b = map(np.radians, [coord_a, coord_b])\n\n    if (coord_a.shape[1] != 2) or (coord_b.shape[1] != 2):\n        raise ValueError(\n            f\"At least one passed array has a wrong shape (a={_a.shape}, b={_b.shape}). 1d arrays should be of length 2 (i.e. [lat, lon]) and 2d array should have the shape (n, 2).\"\n        )\n    if (coord_a.shape[0] &lt; 1) or (coord_b.shape[0] &lt; 1):\n        raise ValueError(\n            f\"At least one passed array contains no values (a={_a.shape}, b={_b.shape}).\"\n        )\n    if coord_a.shape[0] != coord_b.shape[0]:\n        if (coord_a.shape[0] != 1) and (coord_b.shape[0] != 1):\n            raise ValueError(\n                f\"The shapes of passed arrays dont match (a={_a.shape}, b={_b.shape}). Either both should contain the same number of coordinates or at least one of them should contain a single coordinate.\"\n            )\n\n    lat_1, lon_1 = coord_a[:, 0], coord_a[:, 1]\n    lat_2, lon_2 = coord_b[:, 0], coord_b[:, 1]\n\n    # WGS84 ellipsoid constants\n    a = 6378137.0  # semi-major axis (equatorial radius) in meters\n    f = 1 / 298.257223563  # flattening\n    b = (1 - f) * a  # semi-minor axis (polar radius) in meters\n\n    # Reduced latitudes\n    beta_1 = np.arctan((1 - f) * np.tan(lat_1))\n    beta_2 = np.arctan((1 - f) * np.tan(lat_2))\n\n    initial_lon_diff = lon_2 - lon_1\n\n    # Initialize variables for iterative solution\n    lon_diff = initial_lon_diff\n    sin_beta_1, cos_beta_1 = np.sin(beta_1), np.cos(beta_1)\n    sin_beta_2, cos_beta_2 = np.sin(beta_2), np.cos(beta_2)\n    # Track convergence for each point pair\n    converged = np.full_like(lat_1, False, dtype=bool)\n\n    for _ in range(max_iterations):\n        sin_lon_diff, cos_lon_diff = np.sin(lon_diff), np.cos(lon_diff)\n\n        sin_sigma = np.sqrt(\n            (cos_beta_2 * sin_lon_diff) ** 2\n            + (cos_beta_1 * sin_beta_2 - sin_beta_1 * cos_beta_2 * cos_lon_diff) ** 2\n        )\n        cos_sigma = (sin_beta_1 * sin_beta_2) + (cos_beta_1 * cos_beta_2 * cos_lon_diff)\n        sigma = np.arctan2(sin_sigma, cos_sigma)\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            sin_alpha = cos_beta_1 * cos_beta_2 * sin_lon_diff / sin_sigma\n        sin_alpha = np.nan_to_num(sin_alpha, nan=0.0)\n        cos2_alpha = 1 - sin_alpha**2\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            cos2_sigma_m = np.where(\n                cos2_alpha != 0.0,\n                cos_sigma - ((2 * sin_beta_1 * sin_beta_2) / cos2_alpha),\n                0.0,\n            )\n        cos2_sigma_m = np.nan_to_num(cos2_sigma_m, nan=0.0)\n\n        C = f / 16 * cos2_alpha * (4 + f * (4 - 3 * cos2_alpha))\n\n        previous_lon_diff = lon_diff\n        lon_diff = initial_lon_diff + (1 - C) * f * sin_alpha * (\n            sigma\n            + C\n            * sin_sigma\n            * (cos2_sigma_m + C * cos_sigma * (-1 + 2 * cos2_sigma_m**2))\n        )\n        converged = converged | (np.abs(lon_diff - previous_lon_diff) &lt; tolerance)\n        if np.all(converged):\n            break\n\n    u2 = cos2_alpha * (a**2 - b**2) / b**2\n    A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)))\n    B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)))\n\n    delta_sigma = (\n        B\n        * sin_sigma\n        * (\n            cos2_sigma_m\n            + B\n            / 4\n            * (\n                cos_sigma * (-1 + 2 * cos2_sigma_m**2)\n                - B\n                / 6\n                * cos2_sigma_m\n                * (-3 + 4 * sin_sigma**2)\n                * (-3 + 4 * cos2_sigma_m**2)\n            )\n        )\n    )\n\n    distance = b * A * (sigma - delta_sigma)\n\n    if units == \"km\":\n        distance = distance / 1000.0\n    elif units != \"m\":\n        raise ValueError(\n            f\"{vincenty.__name__}() Invalid units : {units}. Use 'm' or 'km' instead.\"\n        )\n\n    if len(_a.shape) == 1 and len(_b.shape) == 1:\n        return distance[0]\n\n    return distance\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_cmap","title":"get_cmap","text":"<pre><code>get_cmap(cmap)\n</code></pre> <p>Return a color map given by <code>cmap</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str | Colormap | list | None</code> <ul> <li>If a <code>Colormap</code>, return it.</li> <li>If a <code>str</code>, return matching custom color map or   if not matching look it up in <code>cmcrameri.cm.cmaps</code>   and <code>matplotlib.colormaps</code>.</li> <li>If a <code>list</code> of colors, create a corresponding descrete color map.</li> <li>If None, return the Colormap defined in <code>image.cmap</code>.</li> </ul> required <p>Returns:     cmap (Cmap):         A color map matching the given <code>cmap</code>.</p> Source code in <code>earthcarekit/plot/color/colormap/colormap.py</code> <pre><code>def get_cmap(cmap: str | Colormap | list | None) -&gt; Cmap:\n    \"\"\"\n    Return a color map given by `cmap`.\n\n    Parameters:\n        cmap (str | matplotlib.colors.Colormap | list | None):\n            - If a `Colormap`, return it.\n            - If a `str`, return matching custom color map or\n              if not matching look it up in `cmcrameri.cm.cmaps`\n              and `matplotlib.colormaps`.\n            - If a `list` of colors, create a corresponding descrete color map.\n            - If None, return the Colormap defined in `image.cmap`.\n    Returns:\n        cmap (Cmap):\n            A color map matching the given `cmap`.\n    \"\"\"\n    if isinstance(cmap, list):\n        cmap = ListedColormap(cmap)\n    return Cmap.from_colormap(_get_cmap(cmap))\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_config","title":"get_config","text":"<pre><code>get_config(c=None)\n</code></pre> <p>Returns the default or a given earthcarekit config object.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>str | ECKConfig | None</code> <p>A path to a config file (.toml) or None. If None, returns the default config. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ECKConfig</code> <code>ECKConfig</code> <p>A config object.</p> Source code in <code>earthcarekit/utils/config.py</code> <pre><code>def get_config(c: str | ECKConfig | None = None) -&gt; ECKConfig:\n    \"\"\"\n    Returns the default or a given earthcarekit config object.\n\n    Args:\n        c (str | ECKConfig | None, optional): A path to a config file (.toml) or None. If None, returns the default config. Defaults to None.\n\n    Returns:\n        ECKConfig: A config object.\n    \"\"\"\n    _config: ECKConfig\n    if c is None:\n        _config = read_config()\n    elif isinstance(c, str):\n        _config = read_config(c)\n    elif isinstance(c, ECKConfig):\n        _config = c\n    else:\n        raise TypeError(\n            f\"Invalid config! Either give a path to a eckit config TOML file or pass a instance of the class '{ECKConfig.__name__}'\"\n        )\n    return _config\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_coord_between","title":"get_coord_between","text":"<pre><code>get_coord_between(coord1, coord2, f=0.5)\n</code></pre> <p>Interpolates between two coordinates by fraction f (0 to 1).</p> <p>Parameters:</p> Name Type Description Default <code>coord1</code> <code>ArrayLike</code> <p>The first lat/lon point.</p> required <code>coord2</code> <code>ArrayLike</code> <p>The second lat/lon point.</p> required <code>f</code> <code>float</code> <p>A fractional value between 0 and 1. Defaults to 0.5, i.e., the mid point between coord1 and coord2.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>A 2-element <code>numpy.ndarray</code> representing the interpolated lat/lon point.</p> Source code in <code>earthcarekit/utils/geo/interpolate.py</code> <pre><code>def get_coord_between(\n    coord1: ArrayLike,\n    coord2: ArrayLike,\n    f: float = 0.5,\n) -&gt; NDArray:\n    \"\"\"\n    Interpolates between two coordinates by fraction f (0 to 1).\n\n    Args:\n        coord1 (ArrayLike): The first lat/lon point.\n        coord2 (ArrayLike): The second lat/lon point.\n        f (float): A fractional value between 0 and 1. Defaults to 0.5, i.e., the mid point between coord1 and coord2.\n\n    Returns:\n        NDArray: A 2-element `numpy.ndarray` representing the interpolated lat/lon point.\n    \"\"\"\n\n    coord1 = np.array(coord1)\n    coord2 = np.array(coord2)\n\n    if coord1.shape != (2,):\n        raise ValueError(f\"coord1 must be a 2-element sequence (lat, lon)\")\n\n    if coord2.shape != (2,):\n        raise ValueError(f\"coord2 must be a 2-element sequence (lat, lon)\")\n\n    lon, lat = interpgeo(\n        lat1=float(coord1[0]),\n        lon1=float(coord1[1]),\n        lat2=float(coord2[0]),\n        lon2=float(coord2[1]),\n        f=f,\n    )\n    return np.array([lat, lon])\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_coords","title":"get_coords","text":"<pre><code>get_coords(ds, *, lat_var=TRACK_LAT_VAR, lon_var=TRACK_LON_VAR, flatten=False)\n</code></pre> <p>Takes a <code>xarray.Dataset</code> and returns the lat/lon coordinates as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>lat_var</code> <code>str</code> <p>Name of the latitude variable. Defaults to TRACK_LAT_VAR.</p> <code>TRACK_LAT_VAR</code> <code>lon_var</code> <code>str</code> <p>Name of the longitude variable. Defaults to TRACK_LON_VAR.</p> <code>TRACK_LON_VAR</code> <code>flatten</code> <code>bool</code> <p>If True, the coordinates will be flattened to a 2D array</p> <ul> <li>1st dimension: time</li> <li>2nd dimension: lat/lon</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>numpy.array: The extracted lat/lon coordinates.</p> Source code in <code>earthcarekit/utils/geo/coordinates.py</code> <pre><code>def get_coords(\n    ds: xr.Dataset,\n    *,\n    lat_var: str = TRACK_LAT_VAR,\n    lon_var: str = TRACK_LON_VAR,\n    flatten: bool = False,\n) -&gt; NDArray:\n    \"\"\"Takes a `xarray.Dataset` and returns the lat/lon coordinates as a numpy array.\n\n    Args:\n        lat_var (str, optional): Name of the latitude variable. Defaults to TRACK_LAT_VAR.\n        lon_var (str, optional): Name of the longitude variable. Defaults to TRACK_LON_VAR.\n        flatten (bool, optional):\n            If True, the coordinates will be flattened to a 2D array\n\n            - 1st dimension: time\n            - 2nd dimension: lat/lon\n\n    Returns:\n        numpy.array: The extracted lat/lon coordinates.\n    \"\"\"\n    lat = ds[lat_var].values\n    lon = ds[lon_var].values\n    coords = np.stack((lat, lon)).transpose()\n\n    if len(coords.shape) &gt; 2 and flatten:\n        coords = coords.reshape(-1, 2)\n    return coords\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_ground_site","title":"get_ground_site","text":"<pre><code>get_ground_site(site)\n</code></pre> <p>Retruns ground site data based on name and raises <code>ValueError</code> if no matching ground site is found and <code>TypeError</code>.</p> Source code in <code>earthcarekit/utils/ground_sites.py</code> <pre><code>def get_ground_site(site: str | GroundSite) -&gt; GroundSite:\n    \"\"\"Retruns ground site data based on name and raises `ValueError` if no matching ground site is found and `TypeError`.\"\"\"\n    if isinstance(site, GroundSite):\n        return site\n    if not isinstance(site, str):\n        raise TypeError(\n            f\"{get_ground_site.__name__}() Expected type `{str.__name__}` but got `{type(site).__name__}` (name={site})\"\n        )\n    site = site.lower()\n    for gs in GROUND_SITES:\n        if site in gs.aliases:\n            return gs\n    raise ValueError(f\"No matching ground site found: '{site}'\")\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_product_info","title":"get_product_info","text":"<pre><code>get_product_info(filepath, warn=False, must_exist=True)\n</code></pre> <p>Gather all info contained in the EarthCARE product's file path.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>def get_product_info(\n    filepath: str,\n    warn: bool = False,\n    must_exist: bool = True,\n) -&gt; ProductInfo:\n    \"\"\"Gather all info contained in the EarthCARE product's file path.\"\"\"\n    if _is_url(filepath):\n        filepath = _get_path_from_url(filepath)\n        must_exist = False\n\n    filepath = os.path.abspath(filepath)\n\n    if must_exist and not os.path.exists(filepath):\n        raise FileNotFoundError(f\"File does not exist: {filepath}\")\n\n    if must_exist:\n        pattern = re.compile(\n            r\".*ECA_[EJ][XNO][A-Z]{2}_..._..._.._\\d{8}T\\d{6}Z_\\d{8}T\\d{6}Z_\\d{5}[ABCDEFGH]\\.h5\"\n        )\n    else:\n        pattern = re.compile(\n            r\".*ECA_[EJ][XNO][A-Z]{2}_..._..._.._\\d{8}T\\d{6}Z_\\d{8}T\\d{6}Z_\\d{5}[ABCDEFGH].*\"\n        )\n    is_match = bool(pattern.fullmatch(filepath))\n\n    if not is_match:\n        pattern_orbit_file = re.compile(\n            r\".*ECA_[EJ][XNO][A-Z]{2}_..._......_\\d{8}T\\d{6}Z_\\d{8}T\\d{6}Z_\\d{4}.*\"\n        )\n        is_match = bool(pattern_orbit_file.fullmatch(filepath))\n\n        if not is_match:\n            raise ValueError(f\"EarthCARE product has invalid file name: {filepath}\")\n\n        filename = os.path.basename(filepath).removesuffix(\".h5\")\n        mission_id = FileMissionID.from_input(filename[0:3])\n        agency = FileAgency.from_input(filename[4])\n        latency = FileLatency.from_input(filename[5])\n        baseline = filename[6:8]\n        file_type = FileType.from_input(filename[9:19])\n        start_sensing_time: pd.Timestamp\n        try:\n            start_sensing_time = pd.Timestamp(filename[20:35])\n        except ValueError as e:\n            start_sensing_time = pd.NaT  # type: ignore\n        start_processing_time: pd.Timestamp\n        try:\n            start_processing_time = pd.Timestamp(filename[37:52])\n        except ValueError as e:\n            start_processing_time = pd.NaT  # type: ignore\n\n        info = ProductInfo(\n            mission_id=mission_id,\n            agency=agency,\n            latency=latency,\n            baseline=baseline,\n            file_type=file_type,\n            start_sensing_time=start_sensing_time,\n            start_processing_time=start_processing_time,\n            orbit_number=0,\n            frame_id=\"\",\n            orbit_and_frame=\"\",\n            name=filename,\n            filepath=filepath,\n            hdr_filepath=\"\",\n        )\n\n        return info\n\n    product_filepath = filepath.removesuffix(\".h5\").removesuffix(\".HDR\") + \".h5\"\n    if not os.path.exists(product_filepath):\n        if warn:\n            msg = f\"Missing product file: {product_filepath}\"\n            warnings.warn(msg)\n        product_filepath = \"\"\n\n    hdr_filepath = filepath.removesuffix(\".h5\").removesuffix(\".HDR\") + \".HDR\"\n    if not os.path.exists(hdr_filepath):\n        if warn:\n            msg = f\"Missing product header file: {hdr_filepath}\"\n            warnings.warn(msg)\n        hdr_filepath = \"\"\n\n    filename = os.path.basename(filepath).removesuffix(\".h5\").removesuffix(\".HDR\")\n    mission_id = FileMissionID.from_input(filename[0:3])\n    agency = FileAgency.from_input(filename[4])\n    latency = FileLatency.from_input(filename[5])\n    baseline = filename[6:8]\n    file_type = FileType.from_input(filename[9:19])\n    start_sensing_time = pd.Timestamp(filename[20:35])\n    start_processing_time = pd.Timestamp(filename[37:52])\n    orbit_number = int(filename[54:59])\n    frame_id = filename[59]\n    orbit_and_frame = filename[54:60]\n\n    info = ProductInfo(\n        mission_id=mission_id,\n        agency=agency,\n        latency=latency,\n        baseline=baseline,\n        file_type=file_type,\n        start_sensing_time=start_sensing_time,\n        start_processing_time=start_processing_time,\n        orbit_number=orbit_number,\n        frame_id=frame_id,\n        orbit_and_frame=orbit_and_frame,\n        name=filename,\n        filepath=product_filepath,\n        hdr_filepath=hdr_filepath,\n    )\n\n    return info\n</code></pre>"},{"location":"api_ref/#earthcarekit.get_product_infos","title":"get_product_infos","text":"<pre><code>get_product_infos(filepaths, **kwargs)\n</code></pre> <p>Extracts product metadata from EarthCARE product file paths (e.g. file_type, orbit_number, frame_id, baseline, ...).</p> <p>Parameters:</p> Name Type Description Default <code>filepaths</code> <code>str | list[str] | NDArray | DataFrame | Dataset</code> <p>Input sources for EarthCARE product files. Can be one of - <code>str</code> -&gt; A single file path. - <code>list[str]</code> or <code>numpy.ndarray</code> -&gt; A list or array of file paths. - <code>pandas.DataFrame</code> -&gt; Must contain a 'filepath' column. - <code>xarray.Dataset</code> -&gt; Must have encoding with attribute 'source' (<code>str</code>) or 'sources' (<code>list[str]</code>).</p> required <code>**kwargs</code> <p>Additional arguments passed to <code>get_product_info()</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ProductDataFrame</code> <code>ProductDataFrame</code> <p>A dataframe containing extracted product information.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>def get_product_infos(\n    filepaths: str | list[str] | NDArray | pd.DataFrame | xr.Dataset,\n    **kwargs,\n) -&gt; \"ProductDataFrame\":\n    \"\"\"\n    Extracts product metadata from EarthCARE product file paths (e.g. file_type, orbit_number, frame_id, baseline, ...).\n\n    Args:\n        filepaths:\n            Input sources for EarthCARE product files. Can be one of\n            - `str` -&gt; A single file path.\n            - `list[str]` or `numpy.ndarray` -&gt; A list or array of file paths.\n            - `pandas.DataFrame` -&gt; Must contain a 'filepath' column.\n            - `xarray.Dataset` -&gt; Must have encoding with attribute 'source' (`str`) or 'sources' (`list[str]`).\n        **kwargs: Additional arguments passed to `get_product_info()`.\n\n    Returns:\n        ProductDataFrame: A dataframe containing extracted product information.\n    \"\"\"\n    _filepaths: list[str] | NDArray\n    if isinstance(filepaths, (str, np.str_)):\n        _filepaths = [str(filepaths)]\n    elif isinstance(filepaths, xr.Dataset):\n        ds: xr.Dataset = filepaths\n        if not hasattr(ds, \"encoding\"):\n            raise ValueError(f\"Dataset missing encoding attribute.\")\n        elif \"source\" in ds.encoding:\n            _filepaths = [ds.encoding[\"source\"]]\n        elif \"sources\" in ds.encoding:\n            _filepaths = ds.encoding[\"sources\"]\n        else:\n            raise ValueError(f\"Dataset encoding does not contain source or sources.\")\n    elif isinstance(filepaths, pd.DataFrame):\n        df: pd.DataFrame = filepaths\n        if \"filepath\" in df:\n            _filepaths = df[\"filepath\"].to_numpy()\n        else:\n            raise ValueError(\n                f\"\"\"Given dataframe does not contain a column of file paths. A valid file path column name is \"filepath\".\"\"\"\n            )\n    else:\n        _filepaths = filepaths\n\n    infos = []\n    for filepath in _filepaths:\n        try:\n            infos.append(get_product_info(filepath, **kwargs).to_dict())\n        except ValueError as e:\n            continue\n    pdf = ProductDataFrame(infos)\n    pdf.validate_columns()\n    return pdf\n</code></pre>"},{"location":"api_ref/#earthcarekit.haversine","title":"haversine","text":"<pre><code>haversine(a, b, units='km', radius_m=MEAN_EARTH_RADIUS_METERS)\n</code></pre> <p>Calculates the great-circle (spherical) distance between pairs of latitude/longitude coordinates using the haversine formula.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ArrayLike</code> <p>An array-like object of shape (..., 2) containing latitude and longitude coordinates in degrees. The last dimension must be 2: (lat, lon).</p> required <code>b</code> <code>ArrayLike</code> <p>An array-like object of the same shape as <code>a</code>, containing corresponding latitude and longitude coordinates.</p> required <code>units</code> <code>Literal['m', 'km']</code> <p>Unit of the output distance. Must be either \"km\" for kilometers or \"m\" for meters. Defaults to \"km\".</p> <code>'km'</code> <code>radius</code> <code>float</code> <p>Radius of the sphere to use for distance calculation. Defaults to MEAN_EARTH_RADIUS_METERS (based on WSG 84 ellipsoid: ~6371008.77 meters). Note: If <code>units=\"km\"</code>, this value is automatically converted to kilometers.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Array of great-circle distances between <code>a</code> and <code>b</code>, in the specified units. The shape matches the input shape excluding the last dimension.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shapes of <code>a</code> and <code>b</code> are incompatible or <code>units</code> is not one of \"m\" or \"km\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; haversine([51.352757, 12.43392], [38.559, 68.856])\n4537.564747442274\n&gt;&gt;&gt; haversine([0,0], [[0,0], [10,0], [20,0]])\narray([   0.        , 1111.95079735, 2223.90159469])\n&gt;&gt;&gt; haversine([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\narray([0., 0., 0.])\n</code></pre> Source code in <code>earthcarekit/utils/geo/distance/_haversine.py</code> <pre><code>def haversine(\n    a: ArrayLike,\n    b: ArrayLike,\n    units: Literal[\"m\", \"km\"] = \"km\",\n    radius_m: float = MEAN_EARTH_RADIUS_METERS,\n):\n    \"\"\"\n    Calculates the great-circle (spherical) distance between pairs of latitude/longitude coordinates\n    using the haversine formula.\n\n    Args:\n        a (ArrayLike): An array-like object of shape (..., 2) containing latitude and longitude\n            coordinates in degrees. The last dimension must be 2: (lat, lon).\n        b (ArrayLike): An array-like object of the same shape as `a`, containing corresponding\n            latitude and longitude coordinates.\n        units (Literal[\"m\", \"km\"], optional): Unit of the output distance. Must be either\n            \"km\" for kilometers or \"m\" for meters. Defaults to \"km\".\n        radius (float, optional): Radius of the sphere to use for distance calculation.\n            Defaults to MEAN_EARTH_RADIUS_METERS (based on WSG 84 ellipsoid: ~6371008.77 meters).\n            Note: If `units=\"km\"`, this value is automatically converted to kilometers.\n\n    Returns:\n        np.ndarray: Array of great-circle distances between `a` and `b`, in the specified units.\n            The shape matches the input shape excluding the last dimension.\n\n    Raises:\n        ValueError: If the shapes of `a` and `b` are incompatible or `units` is not one of \"m\" or \"km\".\n\n    Examples:\n        &gt;&gt;&gt; haversine([51.352757, 12.43392], [38.559, 68.856])\n        4537.564747442274\n        &gt;&gt;&gt; haversine([0,0], [[0,0], [10,0], [20,0]])\n        array([   0.        , 1111.95079735, 2223.90159469])\n        &gt;&gt;&gt; haversine([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\n        array([0., 0., 0.])\n    \"\"\"\n\n    if units not in [\"m\", \"km\"]:\n        raise ValueError(\n            f\"{haversine.__name__}() Invalid units : {units}. Use 'm' or 'km' instead.\"\n        )\n\n    radius: float = radius_m\n    if units == \"km\":\n        radius = radius / 1000.0\n\n    a = np.array(a)\n    b = np.array(b)\n\n    coord_a = np.atleast_2d(a)\n    coord_b = np.atleast_2d(b)\n\n    if (coord_a.shape[1] != 2) or (coord_b.shape[1] != 2):\n        raise ValueError(\n            f\"At least one passed array has a wrong shape (a={a.shape}, b={b.shape}). 1d arrays should be of length 2 (i.e. [lat, lon]) and 2d array should have the shape (n, 2).\"\n        )\n    if (coord_a.shape[0] &lt; 1) or (coord_b.shape[0] &lt; 1):\n        raise ValueError(\n            f\"At least one passed array contains no values (a={a.shape}, b={b.shape}).\"\n        )\n    if coord_a.shape[0] != coord_b.shape[0]:\n        if (coord_a.shape[0] != 1) and (coord_b.shape[0] != 1):\n            raise ValueError(\n                f\"The shapes of passed arrays dont match (a={a.shape}, b={b.shape}). Either both should contain the same number of coordinates or at least one of them should contain a single coordinate.\"\n            )\n\n    coord_a = np.radians(coord_a)\n    coord_b = np.radians(coord_b)\n\n    phi_1, lambda_1 = coord_a[:, 0], coord_a[:, 1]\n    phi_2, lambda_2 = coord_b[:, 0], coord_b[:, 1]\n\n    hav = lambda theta: (1 - np.cos(theta)) / 2\n\n    h = hav(phi_2 - phi_1) + np.cos(phi_1) * np.cos(phi_2) * hav(lambda_2 - lambda_1)\n\n    d = 2 * radius * np.arcsin(np.sqrt(h))\n\n    if len(a.shape) == 1 and len(b.shape) == 1:\n        return d[0]\n\n    return d\n</code></pre>"},{"location":"api_ref/#earthcarekit.perform_anom_depol_statistics","title":"perform_anom_depol_statistics","text":"<pre><code>perform_anom_depol_statistics(ds_anom, selection_height_range, **kwargs)\n</code></pre> <p>Calculate depolarization statistics and uncertainties within a height range.</p> <p>This function adds the depol. ratio (<code>DPOL</code>) calculated from co- (<code>CPOL</code>) and cross-polarized (<code>XPOL</code>) attenuated backscatter to the dataset (ATL_NOM_1B) and computes related statistics. Mean values and standard deviations are calculated for <code>CPOL</code>, <code>XPOL</code>, and <code>DPOL</code> within the selected height range. Variability is separated into vertical and temporal components. Errors of <code>DPOL</code> are derived using error propagation for the <code>XPOL</code>/<code>CPOL</code> ratio.</p> <p>Parameters:</p> Name Type Description Default <code>ds_anom</code> <code>Dataset</code> <p>ATL_NOM_1B dataset with cross- and co-polar signals.</p> required <code>selection_height_range</code> <code>DistanceRangeLike</code> <p>Height range for statistics.</p> required <p>Returns:</p> Name Type Description <code>_ANOMDepolCalculationResults</code> <code>_ANOMDepolCalculationResults</code> <p>Results container with</p> <ul> <li>Mean and standard deviation of depolarization ratio.</li> <li>Mean, vertical, temporal, and combined spreads for co- and cross-polar signals.</li> <li>Propagated uncertainty of \u03b4 (total, vertical, temporal).</li> <li>Input dataset with depolarization ratio added.</li> </ul> Example <pre><code>import earthcarekit as eck\n\nft = \"ANOM\"\noaf = \"01508B\"\nsite = \"dushanbe\"\nradius_km = 100\nsel_hrange = (1e3, 4e3)\n\n# # Optionally, download required data\n# eck.ecdownload(file_type=ft, orbit_and_frame=oaf)\n\ndf = eck.search_product(file_type=ft, orbit_and_frame=oaf)\nfp = df.filepath[-1]\n\nwith eck.read_any(fp) as ds:\n    ds = eck.filter_radius(ds, radius_km=radius_km, site=site)\n    results = eck.perform_anom_depol_statistics(ds, sel_hrange)\n    results.print()  # prints statistics\n\n    # # Optionally, save statistics as CSV file\n    # results.stats.to_csv(\"./stats.csv\")\n\n    # # Optionally, save profile figure as PNG file\n    # fig = results.plot(height_range=(0, 10e3))\n    # eck.save_plot(fig, filepath=\"./depol_profile.png\")\n</code></pre> Source code in <code>earthcarekit/calval/_perform_anom_depol_statistics.py</code> <pre><code>def perform_anom_depol_statistics(\n    ds_anom: xr.Dataset,\n    selection_height_range: DistanceRangeLike,\n    **kwargs,\n) -&gt; _ANOMDepolCalculationResults:\n    \"\"\"\n    Calculate depolarization statistics and uncertainties within a height range.\n\n    This function adds the depol. ratio (`DPOL`) calculated from co- (`CPOL`) and cross-polarized (`XPOL`)\n    attenuated backscatter to the dataset (ATL_NOM_1B) and computes related statistics.\n    Mean values and standard deviations are calculated for `CPOL`, `XPOL`, and `DPOL` within the selected\n    height range. Variability is separated into vertical and temporal components. Errors of `DPOL` are derived\n    using error propagation for the `XPOL`/`CPOL` ratio.\n\n    Args:\n        ds_anom (xr.Dataset): ATL_NOM_1B dataset with cross- and co-polar signals.\n        selection_height_range (DistanceRangeLike): Height range for statistics.\n\n    Returns:\n        _ANOMDepolCalculationResults: Results container with\n\n            - Mean and standard deviation of depolarization ratio.\n            - Mean, vertical, temporal, and combined spreads for co- and cross-polar signals.\n            - Propagated uncertainty of \u03b4 (total, vertical, temporal).\n            - Input dataset with depolarization ratio added.\n\n    Example:\n        ```python\n        import earthcarekit as eck\n\n        ft = \"ANOM\"\n        oaf = \"01508B\"\n        site = \"dushanbe\"\n        radius_km = 100\n        sel_hrange = (1e3, 4e3)\n\n        # # Optionally, download required data\n        # eck.ecdownload(file_type=ft, orbit_and_frame=oaf)\n\n        df = eck.search_product(file_type=ft, orbit_and_frame=oaf)\n        fp = df.filepath[-1]\n\n        with eck.read_any(fp) as ds:\n            ds = eck.filter_radius(ds, radius_km=radius_km, site=site)\n            results = eck.perform_anom_depol_statistics(ds, sel_hrange)\n            results.print()  # prints statistics\n\n            # # Optionally, save statistics as CSV file\n            # results.stats.to_csv(\"./stats.csv\")\n\n            # # Optionally, save profile figure as PNG file\n            # fig = results.plot(height_range=(0, 10e3))\n            # eck.save_plot(fig, filepath=\"./depol_profile.png\")\n        ```\n    \"\"\"\n\n    selection_height_range = validate_numeric_range(selection_height_range)\n\n    ds_anom = add_depol_ratio(ds_anom, **kwargs)\n\n    cpol_p: ProfileData = ProfileData.from_dataset(\n        ds_anom, var=\"cpol_cleaned_for_depol_calculation\"\n    )\n    xpol_p: ProfileData = ProfileData.from_dataset(\n        ds_anom, var=\"xpol_cleaned_for_depol_calculation\"\n    )\n    cpol_mean_p: ProfileData = cpol_p.mean()\n    xpol_mean_p: ProfileData = xpol_p.mean()\n    dpol_mean_p: ProfileData = xpol_mean_p / cpol_mean_p\n    cpol_std_p: ProfileData = cpol_p.std()\n    xpol_std_p: ProfileData = xpol_p.std()\n\n    cpol_stats = cpol_p.stats(selection_height_range)\n    xpol_stats = xpol_p.stats(selection_height_range)\n    dpol_stats = dpol_mean_p.stats(selection_height_range)\n\n    dpol_mean: float = dpol_stats.mean\n    dpol_std: float = dpol_stats.std\n    cpol_mean: float = cpol_stats.mean\n    xpol_mean: float = xpol_stats.mean\n    cpol_std_t: float = cpol_std_p.stats(selection_height_range).std\n    xpol_std_t: float = xpol_std_p.stats(selection_height_range).std\n    cpol_std_z: float = cpol_stats.std\n    xpol_std_z: float = xpol_stats.std\n    cpol_std: float = cpol_std_t + cpol_std_z\n    xpol_std: float = xpol_std_t + xpol_std_z\n\n    calc_error = lambda xsd, csd: np.sqrt(\n        (xsd / cpol_mean) ** 2 + (((xpol_mean / (cpol_mean**2)) * csd) ** 2)\n    )\n    error = calc_error(xpol_std, cpol_std)\n    error_z = calc_error(xpol_std_z, cpol_std_z)\n    error_t = calc_error(xpol_std_t, cpol_std_t)\n\n    return _ANOMDepolCalculationResults(\n        ds=ds_anom.copy(),\n        selection_height_range=selection_height_range,\n        dpol_mean=dpol_mean,\n        dpol_std=dpol_std,\n        cpol_mean=cpol_mean,\n        cpol_std_t=cpol_std_t,\n        cpol_std_z=cpol_std_z,\n        cpol_std=cpol_std,\n        xpol_mean=xpol_mean,\n        xpol_std_t=xpol_std_t,\n        xpol_std_z=xpol_std_z,\n        xpol_std=xpol_std,\n        error=error,\n        error_t=error_t,\n        error_z=error_z,\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.plot_line_between_figures","title":"plot_line_between_figures","text":"<pre><code>plot_line_between_figures(\n    ax1,\n    ax2,\n    point1,\n    point2=None,\n    color=\"ec:red\",\n    linestyle=\"dashed\",\n    linewidth=2,\n    alpha=0.3,\n    capstyle=\"butt\",\n    zorder=-20,\n    **kwargs\n)\n</code></pre> <p>Draws a line connecting a point in one subfigure (ax1) to a point in another (ax2).</p> Source code in <code>earthcarekit/plot/figure/_plot_line_between_figures.py</code> <pre><code>def plot_line_between_figures(\n    ax1: Axes,\n    ax2: Axes,\n    point1: _NumberTimeOrTuple,\n    point2: _NumberTimeOrTuple | None = None,\n    color: ColorLike | None = \"ec:red\",\n    linestyle: str = \"dashed\",\n    linewidth: int | float = 2,\n    alpha: int | float = 0.3,\n    capstyle: str = \"butt\",\n    zorder: int | float = -20,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Draws a line connecting a point in one subfigure (ax1) to a point in another (ax2).\"\"\"\n    p1: tuple[float, float] = _get_point(ax1, 1, point1)\n    if point2 is None:\n        point2 = point1\n    p2: tuple[float, float] = _get_point(ax2, 2, point2)\n\n    con = ConnectionPatch(\n        xyA=p1,\n        coordsA=ax1.transData,\n        xyB=p2,\n        coordsB=ax2.transData,\n        axesA=ax1,\n        axesB=ax2,\n        color=Color.from_optional(color),\n        linestyle=linestyle,\n        linewidth=linewidth,\n        alpha=alpha,\n        capstyle=capstyle,\n        zorder=zorder,\n        **kwargs,\n    )\n    ax1.figure.add_artist(con)\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_any","title":"read_any","text":"<pre><code>read_any(input, **kwargs)\n</code></pre> <p>Reads various input types and returns an <code>xarray.Dataset</code>.</p> This function can read <ul> <li>EarthCARE product files (<code>.h5</code>)</li> <li>NetCDF files (<code>.nc</code>)</li> <li>Manually processed PollyXT output files (<code>.txt</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | Dataset</code> <p>File path or existing Dataset.</p> required <code>**kwargs</code> <p>Additional keyword arguments for specific readers.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Opened dataset.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file type is not supported.</p> <code>TypeError</code> <p>If the input type is invalid.</p> Source code in <code>earthcarekit/utils/read/_read_any.py</code> <pre><code>def read_any(input: str | xr.Dataset, **kwargs) -&gt; xr.Dataset:\n    \"\"\"Reads various input types and returns an `xarray.Dataset`.\n\n    This function can read:\n        - EarthCARE product files (`.h5`)\n        - NetCDF files (`.nc`)\n        - Manually processed PollyXT output files (`.txt`)\n\n    Args:\n        input (str | xr.Dataset): File path or existing Dataset.\n        **kwargs: Additional keyword arguments for specific readers.\n\n    Returns:\n        xr.Dataset: Opened dataset.\n\n    Raises:\n        ValueError: If the file type is not supported.\n        TypeError: If the input type is invalid.\n    \"\"\"\n    if isinstance(input, xr.Dataset):\n        return input\n    elif isinstance(input, str):\n        filepath = input\n\n        if is_earthcare_product(filepath=filepath):\n            return read_product(filepath, **kwargs)\n\n        filename = os.path.basename(filepath)\n        _, ext = os.path.splitext(filename)\n        if ext.lower() == \".txt\":\n            return read_polly(filepath)\n        elif ext.lower() == \".nc\":\n            return read_nc(filepath, **kwargs)\n\n        raise ValueError(f\"Reading of file not supported: &lt;{input}&gt;\")\n    raise TypeError(f\"Invalid type '{type(input).__name__}' for input.\")\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_header_data","title":"read_header_data","text":"<pre><code>read_header_data(source: str) -&gt; xr.Dataset\n</code></pre><pre><code>read_header_data(source: Dataset) -&gt; xr.Dataset\n</code></pre> <pre><code>read_header_data(source)\n</code></pre> <p>Opens the product header groups of a EarthCARE file as a <code>xarray.Dataset</code>.</p> Source code in <code>earthcarekit/utils/read/product/header_group.py</code> <pre><code>def read_header_data(source: str | xr.Dataset) -&gt; xr.Dataset:\n    \"\"\"Opens the product header groups of a EarthCARE file as a `xarray.Dataset`.\"\"\"\n    if isinstance(source, str):\n        filepath = source\n    elif isinstance(source, xr.Dataset):\n        filepath = source.encoding.get(\"source\", None)\n        if filepath is None:\n            raise ValueError(f\"Dataset missing source attribute\")\n    else:\n        raise TypeError(\"Expected 'str' or 'xarray.Dataset'\")\n\n    groups = xr.open_groups(filepath)\n    header_groups = {n: g for n, g in groups.items() if \"HeaderData\" in n}\n\n    # Rename duplicate vars\n\n    all_vars = {}\n    header_datasets = []\n    for i, (group_name, ds) in enumerate(header_groups.items()):\n        ds_new = ds.copy()\n        for var in ds.data_vars:\n            if var in all_vars:\n                new_name = f\"{group_name.split('/')[-1]}_{var}\"\n                ds_new = ds_new.rename({var: new_name})\n            else:\n                all_vars[var] = True\n        header_datasets.append(ds_new)\n\n    ds = xr.merge(header_datasets)\n\n    ds = _convert_all_fill_values_to_nan(ds)\n\n    # Convert timestamps to numpy datetime\n    for var in [\n        \"Creation_Date\",\n        \"Validity_Start\",\n        \"Validity_Stop\",\n        \"ANXTime\",\n        \"frameStartTime\",\n        \"frameStopTime\",\n        \"processingStartTime\",\n        \"processingStopTime\",\n        \"sensingStartTime\",\n        \"sensingStopTime\",\n        \"stateVectorTime\",\n    ]:\n        if var in ds:\n            raw = ds[var].values\n            formatted = np.char.replace(raw, \"UTC=\", \"\")\n            ds[var].values = formatted.astype(\"datetime64[ns]\")\n\n    # Ensure that strings are correctly decoded\n    for var in [\"frameID\"]:\n        if var in ds:\n            ds = convert_scalar_var_to_str(ds, var)\n\n    # Remove dimensions of size == 1\n    ds = ds.squeeze()\n\n    return ds\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_nc","title":"read_nc","text":"<pre><code>read_nc(input, modify=True, in_memory=False, **kwargs)\n</code></pre> <p>Returns an <code>xarray.Dataset</code> from a Dataset or NetCDF file path, optionally loaded into memory.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Dataset or str</code> <p>Path to a NetCDF file. If a already opened <code>xarray.Dataset</code> object is passed, it is returned as is.</p> required <code>modify</code> <code>bool</code> <p>If True, default modifications to the opened dataset will be applied (e.g., converting heights in Polly data from height a.g.l. to height above mean sea level).</p> <code>True</code> <code>in_memory</code> <code>bool</code> <p>If True, ensures the dataset is fully loaded into memory. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Key-word arguments passed to <code>xarray.open_dataset()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xarray.Dataset: The resulting dataset.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not a Dataset or string.</p> Source code in <code>earthcarekit/utils/read/_read_nc.py</code> <pre><code>def read_nc(\n    input: str | xr.Dataset,\n    modify: bool = True,\n    in_memory: bool = False,\n    **kwargs,\n) -&gt; xr.Dataset:\n    \"\"\"Returns an `xarray.Dataset` from a Dataset or NetCDF file path, optionally loaded into memory.\n\n    Args:\n        input (xarray.Dataset or str): Path to a NetCDF file. If a already opened `xarray.Dataset` object is passed, it is returned as is.\n        modify (bool): If True, default modifications to the opened dataset will be applied\n            (e.g., converting heights in Polly data from height a.g.l. to height above mean sea level).\n        in_memory (bool, optional): If True, ensures the dataset is fully loaded into memory. Defaults to False.\n        **kwargs: Key-word arguments passed to `xarray.open_dataset()`.\n\n    Returns:\n        xarray.Dataset: The resulting dataset.\n\n    Raises:\n        TypeError: If input is not a Dataset or string.\n    \"\"\"\n    ds: xr.Dataset\n    if isinstance(input, xr.Dataset):\n        ds = input\n    elif isinstance(input, str):\n        if in_memory:\n            with _read_nc(input, modify=modify, **kwargs) as ds:\n                ds = ds.load()\n        else:\n            ds = _read_nc(input, modify=modify, **kwargs)\n    else:\n        raise TypeError(\n            f\"Invalid input type! Expecting a opened NetCDF dataset (xarray.Dataset) or a path to a NetCDF file.\"\n        )\n    return ds\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_polly","title":"read_polly","text":"<pre><code>read_polly(input)\n</code></pre> <p>Reads manually processed PollyXT output text files as <code>xarray.Dataset</code> or returns an already open one.</p> Source code in <code>earthcarekit/utils/read/_read_polly.py</code> <pre><code>def read_polly(input: str | xr.Dataset) -&gt; xr.Dataset:\n    \"\"\"Reads manually processed PollyXT output text files as `xarray.Dataset` or returns an already open one.\"\"\"\n\n    if isinstance(input, xr.Dataset):\n        return input\n\n    with open(input, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n        df = pd.read_csv(f, sep=\"\\t\")\n\n    new_columns = [_parse_column_name(c) for c in df.columns]\n    new_column_names = [c.name for c in new_columns]\n    new_column_names = _make_column_names_unique(new_column_names)\n    df.columns = pd.Index(new_column_names)\n\n    ds = xr.Dataset.from_dataframe(df)\n    ds = ds.assign_coords(index=ds.height.values)\n    ds = ds.rename({\"index\": \"vertical\"})\n    if \"time\" not in ds:\n        ds = ds.assign({\"time\": np.datetime64(\"1970-01-01T00:00:00.000\", \"ms\")})\n\n    vars_order = [\"time\"] + [v for v in ds.data_vars if v != \"time\"]\n    ds = ds[vars_order]\n\n    for c in new_columns:\n        if c.units == \"km\":\n            ds[c.name].values = ds[c.name].values * 1e3\n            c.units = c.units.replace(\"k\", \"\")\n        elif c.units in [\"Mm-1 sr-1\", \"Mm-1\", \"Msr-1\"]:\n            ds[c.name].values = ds[c.name].values / 1e6\n            c.units = c.units.replace(\"M\", \"\")\n\n        ds[c.name] = ds[c.name].assign_attrs(\n            dict(\n                long_name=c.long_name,\n                units=c.units,\n            )\n        )\n    return ds\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_product","title":"read_product","text":"<pre><code>read_product(\n    input,\n    trim_to_frame=True,\n    modify=DEFAULT_READ_EC_PRODUCT_MODIFY,\n    header=DEFAULT_READ_EC_PRODUCT_HEADER,\n    meta=DEFAULT_READ_EC_PRODUCT_META,\n    in_memory=False,\n    **kwargs\n)\n</code></pre> <p>Returns an <code>xarray.Dataset</code> from a Dataset or EarthCARE file path, optionally loaded into memory.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str or Dataset</code> <p>Path to a EarthCARE file. If a <code>xarray.Dataset</code> is given it will be returned as is.</p> required <code>trim_to_frame</code> <code>bool</code> <p>Whether to trim the dataset to latitude frame bounds. Defaults to True.</p> <code>True</code> <code>modify</code> <code>bool</code> <p>If True, default modifications to the opened dataset will be applied (e.g., renaming dimension corresponding to height to \"vertical\"). Defaults to True.</p> <code>DEFAULT_READ_EC_PRODUCT_MODIFY</code> <code>header</code> <code>bool</code> <p>If True, all header data will be included in the dataframe. Defaults to False.</p> <code>DEFAULT_READ_EC_PRODUCT_HEADER</code> <code>meta</code> <code>bool</code> <p>If True, select meta data from header (like orbit number and frame ID) will be included in the dataframe. Defaults to True.</p> <code>DEFAULT_READ_EC_PRODUCT_META</code> <code>in_memory</code> <code>bool</code> <p>If True, ensures the dataset is fully loaded into memory. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xarray.Dataset: The resulting dataset.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not a Dataset or string.</p> Source code in <code>earthcarekit/utils/read/product/_generic.py</code> <pre><code>def read_product(\n    input: str | Dataset,\n    trim_to_frame: bool = True,\n    modify: bool = DEFAULT_READ_EC_PRODUCT_MODIFY,\n    header: bool = DEFAULT_READ_EC_PRODUCT_HEADER,\n    meta: bool = DEFAULT_READ_EC_PRODUCT_META,\n    in_memory: bool = False,\n    **kwargs,\n) -&gt; Dataset:\n    \"\"\"Returns an `xarray.Dataset` from a Dataset or EarthCARE file path, optionally loaded into memory.\n\n    Args:\n        input (str or xarray.Dataset): Path to a EarthCARE file. If a `xarray.Dataset` is given it will be returned as is.\n        trim_to_frame (bool, optional): Whether to trim the dataset to latitude frame bounds. Defaults to True.\n        modify (bool): If True, default modifications to the opened dataset will be applied\n            (e.g., renaming dimension corresponding to height to \"vertical\"). Defaults to True.\n        header (bool): If True, all header data will be included in the dataframe. Defaults to False.\n        meta (bool): If True, select meta data from header (like orbit number and frame ID) will be included in the dataframe. Defaults to True.\n        in_memory (bool, optional): If True, ensures the dataset is fully loaded into memory. Defaults to False.\n\n    Returns:\n        xarray.Dataset: The resulting dataset.\n\n    Raises:\n        TypeError: If input is not a Dataset or string.\n    \"\"\"\n    ds: Dataset\n    if isinstance(input, Dataset):\n        ds = input\n    elif isinstance(input, str):\n        if in_memory:\n            with _read_product(\n                filepath=input,\n                trim_to_frame=trim_to_frame,\n                modify=modify,\n                header=header,\n                meta=meta,\n                **kwargs,\n            ) as ds:\n                ds = ds.load()\n        else:\n            ds = _read_product(\n                filepath=input,\n                trim_to_frame=trim_to_frame,\n                modify=modify,\n                header=header,\n                meta=meta,\n                **kwargs,\n            )\n    else:\n        raise TypeError(\n            f\"Invalid input type! Expecting a opened EarthCARE dataset (xarray.Dataset) or a path to a EarthCARE product.\"\n        )\n    return ds\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_products","title":"read_products","text":"<pre><code>read_products(\n    filepaths,\n    zoom_at=None,\n    along_track_dim=ALONG_TRACK_DIM,\n    func=None,\n    func_inputs=None,\n    max_num_files=8,\n    coarsen=True,\n)\n</code></pre> <p>Read and concatenate a sequence of EarthCARE frames into a single xarray Dataset.</p> <p>By default, the dataset is coarsened according to the number of input frames (e.g., combining 3 products averages every 3 profiles, so the along-track dimension remains comparable to a single product). Optionally applies a processing function to each frame and zooms in on a specific region (defined by <code>zoom_at</code>) without coarsening. Coarsening can also be turned of but might case memory issues.</p> <p>Parameters:</p> Name Type Description Default <code>filepaths</code> <code>Sequence[str] or DataFrame</code> <p>EarthCARE product file paths as a list or a DataFrame with metadata including <code>filepath</code>, <code>orbit_number</code>, and <code>frame_id</code>.</p> required <code>zoom_at</code> <code>float</code> <p>If set, selects only a zoomed-in portion of the frames around this fractional index. Defaults to None.</p> <code>None</code> <code>along_track_dim</code> <code>str</code> <p>Name of the dimension to concatenate along. Defaults to ALONG_TRACK_DIM.</p> <code>ALONG_TRACK_DIM</code> <code>func</code> <code>Callable</code> <p>Function to apply to each frame after loading. Defaults to None.</p> <code>None</code> <code>func_inputs</code> <code>Sequence[dict]</code> <p>Optional per-frame arguments to pass to <code>func</code>. Defaults to None.</p> <code>None</code> <code>max_num_files</code> <code>int</code> <p>Max. number of files that are allowed to be loaded at once. A <code>ValueError</code> is raised if above. Defaults to 8 (e.g., full orbit).</p> <code>8</code> <code>coarsen</code> <code>bool</code> <p>If Ture, read data sets are coarened depending on the number given of files. Only aplicable when not zooming. Defaults to Ture.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>Concatenated dataset with all frames along <code>along_track_dim</code>.</p> Source code in <code>earthcarekit/utils/read/product/_concat.py</code> <pre><code>def read_products(\n    filepaths: Sequence[str] | pd.DataFrame,\n    zoom_at: float | None = None,\n    along_track_dim: str = ALONG_TRACK_DIM,\n    func: Callable | None = None,\n    func_inputs: Sequence[dict] | None = None,\n    max_num_files: int = 8,\n    coarsen: bool = True,\n) -&gt; Dataset:\n    \"\"\"Read and concatenate a sequence of EarthCARE frames into a single xarray Dataset.\n\n    By default, the dataset is coarsened according to the number of input frames (e.g.,\n    combining 3 products averages every 3 profiles, so the along-track dimension remains\n    comparable to a single product). Optionally applies a processing function to each\n    frame and zooms in on a specific region (defined by `zoom_at`) without coarsening.\n    Coarsening can also be turned of but might case memory issues.\n\n    Args:\n        filepaths (Sequence[str] or pandas.DataFrame):\n            EarthCARE product file paths as a list or a DataFrame with metadata\n            including `filepath`, `orbit_number`, and `frame_id`.\n        zoom_at (float, optional):\n            If set, selects only a zoomed-in portion of the frames around this\n            fractional index. Defaults to None.\n        along_track_dim (str, optional):\n            Name of the dimension to concatenate along. Defaults to ALONG_TRACK_DIM.\n        func (Callable, optional):\n            Function to apply to each frame after loading. Defaults to None.\n        func_inputs (Sequence[dict], optional):\n            Optional per-frame arguments to pass to `func`. Defaults to None.\n        max_num_files (int, optional):\n            Max. number of files that are allowed to be loaded at once.\n            A `ValueError` is raised if above. Defaults to 8 (e.g., full orbit).\n        coarsen (bool, optional):\n            If Ture, read data sets are coarened depending on the number given of files.\n            Only aplicable when not zooming. Defaults to Ture.\n\n    Returns:\n        Dataset: Concatenated dataset with all frames along `along_track_dim`.\n    \"\"\"\n    if isinstance(filepaths, str):\n        filepaths = [filepaths]\n    elif isinstance(filepaths, pd.DataFrame):\n        df = filepaths.sort_values(by=\"filepath\")\n        filepaths = df[\"filepath\"].tolist()\n    else:\n        df = ProductDataFrame.from_files(list(filepaths)).sort_values(by=\"filepath\")\n        df.validate_columns()\n        filepaths = df[\"filepath\"].tolist()\n\n    if len(filepaths) == 0:\n        raise ValueError(f\"Given sequence of product files paths is empty\")\n    elif len(filepaths) == 1:\n        warnings.warn(f\"Can not concatenate frames since only one file path was given\")\n        return read_product(filepaths[0])\n    elif len(filepaths) &gt; max_num_files:\n        raise ValueError(\n            f\"Too many files provided: {len(filepaths)} (currently maximum allowed is {max_num_files}). \"\n            \"Please reduce the number of files or increase the allowed amount by setting the argument max_num_files.\"\n        )\n    elif len(filepaths) &gt; 8:\n        warnings.warn(\n            f\"You provided {len(filepaths)} files, which is more than one full orbit (8 files). \"\n            \"Processing might take longer than usual.\"\n        )\n\n    # # Construct filename suffix from orbit/frame numbers\n    # orbit_start = str(df[\"orbit_number\"].iloc[0]).zfill(5)\n    # orbit_end = str(df[\"orbit_number\"].iloc[-1]).zfill(5)\n    # frame_start = df[\"frame_id\"].iloc[0]\n    # frame_end = df[\"frame_id\"].iloc[-1]\n\n    # if orbit_start == orbit_end:\n    #     oaf_string = (\n    #         f\"{orbit_start}{frame_start}\"\n    #         if frame_start == frame_end\n    #         else f\"{orbit_start}{frame_start}-{frame_end}\"\n    #     )\n    # else:\n    #     oaf_string = f\"{orbit_start}{frame_start}-{orbit_end}{frame_end}\"\n\n    def apply_func(ds: Dataset, i: int) -&gt; Dataset:\n        \"\"\"Apply a processing function to a dataset if specified.\"\"\"\n        if func is None:\n            return ds\n        if func_inputs is None:\n            return func(ds)\n        if i &lt; len(func_inputs):\n            return func(ds, **func_inputs[i])\n        raise IndexError(\"Too few function inputs provided\")\n\n    num_files = len(filepaths)\n    ds: xr.Dataset | None = None\n\n    if zoom_at is not None:\n        # Zoomed read: select portions of two adjacent frames\n        frame_indices = np.unique([int(np.floor(zoom_at)), int(np.ceil(zoom_at))])\n        offset = zoom_at - frame_indices[0]\n        filepaths = [filepaths[i] for i in frame_indices]\n\n        for i, filepath in enumerate(filepaths):\n            with read_product(filepath) as frame_ds:\n                frame_ds = apply_func(frame_ds, frame_indices[i])\n\n                # Preserve original dtypes\n                original_dtypes = {v: frame_ds[v].dtype for v in frame_ds.variables}\n\n                # Select relevant portion of the frame\n                n = len(frame_ds[along_track_dim])\n                sel_slice = (\n                    slice(int(np.floor(n * offset)), n)\n                    if i == 0\n                    else slice(0, int(np.ceil(n * offset)))\n                )\n                frame_ds = frame_ds.sel({along_track_dim: sel_slice})\n\n                # Restore dtypes\n                for v, dtype in original_dtypes.items():\n                    frame_ds[v] = frame_ds[v].astype(dtype)\n\n                ds = (\n                    frame_ds.copy()\n                    if ds is None\n                    else concat_datasets(\n                        ds.copy(), frame_ds.copy(), dim=along_track_dim\n                    )\n                )\n\n    else:\n        # Full read and coarsen each frame\n        for i, filepath in enumerate(filepaths):\n            with read_product(filepath) as frame_ds:\n                frame_ds = apply_func(frame_ds, i)\n\n                if coarsen:\n                    original_dtypes = {v: frame_ds[v].dtype for v in frame_ds.variables}\n\n                    coarsen_dims = {along_track_dim: num_files}\n\n                    # Circular mean for longitude\n                    lon_coarse = (\n                        frame_ds[\"longitude\"]\n                        .coarsen(coarsen_dims, boundary=\"trim\")\n                        .reduce(circular_mean_np)\n                    )\n                    _tmp_attrs = lon_coarse.attrs\n                    lon_coarse.attrs = {}\n\n                    # Regular mean for the rest\n                    rest = (\n                        frame_ds.drop_vars(\"longitude\")\n                        .coarsen(coarsen_dims, boundary=\"trim\")\n                        .mean()  # type: ignore\n                    )\n\n                    # Merge results\n                    frame_ds = xr.merge([lon_coarse, rest])\n                    frame_ds[\"longitude\"].attrs = _tmp_attrs\n\n                    for v, dtype in original_dtypes.items():\n                        frame_ds[v] = frame_ds[v].astype(dtype)\n\n                ds = (\n                    frame_ds\n                    if ds is None\n                    else concat_datasets(ds, frame_ds, dim=along_track_dim)\n                )\n\n    # Set output file sources\n    if isinstance(ds, Dataset):\n        ds.encoding[\"sources\"] = list(filepaths)\n        return ds\n    else:\n        raise RuntimeError(f\"Bad implementation\")\n</code></pre>"},{"location":"api_ref/#earthcarekit.read_science_data","title":"read_science_data","text":"<pre><code>read_science_data(filepath, agency=None, **kwargs)\n</code></pre> <p>Opens the science data of a EarthCARE file as a <code>xarray.Dataset</code>.</p> Source code in <code>earthcarekit/utils/read/product/science_group.py</code> <pre><code>def read_science_data(\n    filepath: str,\n    agency: Union[\"FileAgency\", None] = None,\n    **kwargs,\n) -&gt; xr.Dataset:\n    \"\"\"Opens the science data of a EarthCARE file as a `xarray.Dataset`.\"\"\"\n    from .file_info.agency import (\n        FileAgency,  # Imported inside function to avoid circular import error\n    )\n\n    if agency is None:\n        agency = FileAgency.from_input(filepath)\n\n    if agency == FileAgency.ESA:\n        ds = xr.open_dataset(filepath, group=\"ScienceData\", **kwargs)\n    elif agency == FileAgency.JAXA:\n        df_cpr_geo = xr.open_dataset(\n            filepath, group=\"ScienceData/Geo\", engine=\"h5netcdf\", phony_dims=\"sort\"\n        )\n        df_cpr_data = xr.open_dataset(\n            filepath, group=\"ScienceData/Data\", engine=\"h5netcdf\", phony_dims=\"sort\"\n        )\n        ds = xr.merge([df_cpr_data, df_cpr_geo])\n        ds.encoding[\"source\"] = df_cpr_data.encoding[\"source\"]\n    else:\n        raise NotImplementedError()\n\n    ds = _convert_all_fill_values_to_nan(ds)\n\n    return ds\n</code></pre>"},{"location":"api_ref/#earthcarekit.rebin_xmet_to_vertical_track","title":"rebin_xmet_to_vertical_track","text":"<pre><code>rebin_xmet_to_vertical_track(\n    ds_xmet,\n    ds_vert,\n    vars=None,\n    k=4,\n    eps=1e-12,\n    lat_var=TRACK_LAT_VAR,\n    lon_var=TRACK_LON_VAR,\n    time_var=TIME_VAR,\n    height_var=HEIGHT_VAR,\n    along_track_dim=ALONG_TRACK_DIM,\n    height_dim=VERTICAL_DIM,\n    xmet_lat_var=\"latitude\",\n    xmet_lon_var=\"longitude\",\n    xmet_height_var=\"geometrical_height\",\n    xmet_height_dim=\"height\",\n    xmet_horizontal_grid_dim=\"horizontal_grid\",\n)\n</code></pre> <p>Rebins variables from an AUX_MET_1D (XMET) dataset onto the vertical curtain track of given by another dataset (e.g. ATL_EBD_2A).</p> <p>This function interpolates selected variables from <code>ds_xmet</code> onto a EarthCARE vertical track given in <code>ds_vert</code>, using quick horizontal kd-tree nearest-neighbor search with <code>scipy.spatial.cKDTree</code> followed by averaging the <code>k</code>-nearest vertical XMET profiles using inverse distance weighting. The resulting profiles are then interpolated in the vertical to match the height resolution of <code>ds_vert</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ds_xmet</code> <code>Dataset</code> <p>The source XMET dataset from which vertical curtain along track will be interpolated.</p> required <code>ds_vert</code> <code>Dataset</code> <p>The target dataset containing the vertical curtain track.</p> required <code>vars</code> <code>list[str] | None</code> <p>List of variable names from <code>ds_xmet</code> to rebin. If None, all data variables are considered.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of nearest horizontal neighbors to include in the kd-tree search. Defaults to 4.</p> <code>4</code> <code>eps</code> <code>float</code> <p>Numerical threshold to avoid division by zero in distance calculations during the kd-tree search. Defaults to 1e-12.</p> <code>1e-12</code> <code>lat_var</code> <code>str</code> <p>Name of the latitude variable in <code>ds_vert</code>. Defaults to TRACK_LAT_VAR.</p> <code>TRACK_LAT_VAR</code> <code>lon_var</code> <code>str</code> <p>Name of the longitude variable in <code>ds_vert</code>. Defaults to TRACK_LON_VAR.</p> <code>TRACK_LON_VAR</code> <code>time_var</code> <code>str</code> <p>Name of the time variable in <code>ds_vert</code>. Defaults to TIME_VAR.</p> <code>TIME_VAR</code> <code>height_var</code> <code>str</code> <p>Name of the height variable in <code>ds_vert</code>. Defaults to HEIGHT_VAR.</p> <code>HEIGHT_VAR</code> <code>along_track_dim</code> <code>str</code> <p>Name of the along-track dimension in <code>ds_vert</code>. Defaults to ALONG_TRACK_DIM.</p> <code>ALONG_TRACK_DIM</code> <code>height_dim</code> <code>str</code> <p>Name of the vertical or height dimension in <code>ds_vert</code>. Defaults to VERTICAL_DIM.</p> <code>VERTICAL_DIM</code> <code>xmet_lat_var</code> <code>str</code> <p>Name of the latitude variable in <code>ds_xmet</code>. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>xmet_lon_var</code> <code>str</code> <p>Name of the longitude variable in <code>ds_xmet</code>. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>xmet_height_var</code> <code>str</code> <p>Name of the height variable in <code>ds_xmet</code>. Defaults to \"geometrical_height\".</p> <code>'geometrical_height'</code> <code>xmet_height_dim</code> <code>str</code> <p>Name of the vertical dimension in <code>ds_xmet</code>. Defaults to \"height\".</p> <code>'height'</code> <code>xmet_horizontal_grid_dim</code> <code>str</code> <p>Name of the horizontal grid dimension in <code>ds_xmet</code>. Defaults to \"horizontal_grid\".</p> <code>'horizontal_grid'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: A new dataset containing the selected XMET variables interpolated to the grid of the vertical curtain given in <code>ds_vert</code>. This new dataset has the same along-track and vertical dimensions as <code>ds_vert</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If any specified variable or coordinate name is not found in <code>ds_xmet</code>.</p> Source code in <code>earthcarekit/utils/read/product/auxiliary/aux_met_1d.py</code> <pre><code>def rebin_xmet_to_vertical_track(\n    ds_xmet: xr.Dataset,\n    ds_vert: xr.Dataset,\n    vars: list[str] | None = None,\n    k: int = 4,\n    eps: float = 1e-12,\n    lat_var: str = TRACK_LAT_VAR,\n    lon_var: str = TRACK_LON_VAR,\n    time_var: str = TIME_VAR,\n    height_var: str = HEIGHT_VAR,\n    along_track_dim: str = ALONG_TRACK_DIM,\n    height_dim: str = VERTICAL_DIM,\n    xmet_lat_var: str = \"latitude\",\n    xmet_lon_var: str = \"longitude\",\n    xmet_height_var: str = \"geometrical_height\",\n    xmet_height_dim: str = \"height\",\n    xmet_horizontal_grid_dim: str = \"horizontal_grid\",\n) -&gt; xr.Dataset:\n    \"\"\"\n    Rebins variables from an AUX_MET_1D (XMET) dataset onto the vertical curtain track of given by another dataset (e.g. ATL_EBD_2A).\n\n    This function interpolates selected variables from `ds_xmet` onto a EarthCARE\n    vertical track given in `ds_vert`, using quick horizontal kd-tree nearest-neighbor search with `scipy.spatial.cKDTree` followed\n    by averaging the `k`-nearest vertical XMET profiles using inverse distance weighting. The resulting\n    profiles are then interpolated in the vertical to match the height resolution of `ds_vert`.\n\n    Args:\n        ds_xmet (xr.Dataset): The source XMET dataset from which vertical curtain along track will be interpolated.\n        ds_vert (xr.Dataset): The target dataset containing the vertical curtain track.\n        vars (list[str] | None, optional): List of variable names from `ds_xmet` to rebin.\n            If None, all data variables are considered.\n        k (int, optional): Number of nearest horizontal neighbors to include in the kd-tree search.\n            Defaults to 4.\n        eps (float, optional): Numerical threshold to avoid division by zero in distance calculations during the kd-tree search.\n            Defaults to 1e-12.\n        lat_var (str, optional): Name of the latitude variable in `ds_vert`.\n            Defaults to TRACK_LAT_VAR.\n        lon_var (str, optional): Name of the longitude variable in `ds_vert`.\n            Defaults to TRACK_LON_VAR.\n        time_var (str, optional): Name of the time variable in `ds_vert`.\n            Defaults to TIME_VAR.\n        height_var (str, optional): Name of the height variable in `ds_vert`.\n            Defaults to HEIGHT_VAR.\n        along_track_dim (str, optional): Name of the along-track dimension in `ds_vert`.\n            Defaults to ALONG_TRACK_DIM.\n        height_dim (str, optional): Name of the vertical or height dimension in `ds_vert`.\n            Defaults to VERTICAL_DIM.\n        xmet_lat_var (str, optional): Name of the latitude variable in `ds_xmet`.\n            Defaults to \"latitude\".\n        xmet_lon_var (str, optional): Name of the longitude variable in `ds_xmet`.\n            Defaults to \"longitude\".\n        xmet_height_var (str, optional): Name of the height variable in `ds_xmet`.\n            Defaults to \"geometrical_height\".\n        xmet_height_dim (str, optional): Name of the vertical dimension in `ds_xmet`.\n            Defaults to \"height\".\n        xmet_horizontal_grid_dim (str, optional): Name of the horizontal grid dimension in `ds_xmet`.\n            Defaults to \"horizontal_grid\".\n\n    Returns:\n        xr.Dataset: A new dataset containing the selected XMET variables interpolated to the grid of the\n            vertical curtain given in `ds_vert`. This new dataset has the same along-track and vertical\n            dimensions as `ds_vert`.\n\n    Raises:\n        KeyError: If any specified variable or coordinate name is not found in `ds_xmet`.\n    \"\"\"\n    if vars is None:\n        vars = [str(v) for v in ds_xmet.variables]\n    else:\n        for var in vars:\n            if var not in ds_xmet.variables:\n                present_vars = [str(v) for v in ds_xmet.variables]\n                raise KeyError(\n                    f\"\"\"X-MET dataset does not contain variable \"{var}\". Present variables are: {\", \".join(present_vars)}\"\"\"\n                )\n\n    new_ds_xmet = ds_xmet.copy().swap_dims({xmet_height_dim: \"tmp_xmet_height\"})\n    new_ds_xmet[time_var] = ds_vert[time_var].copy()\n    new_ds_xmet[height_var] = ds_vert[height_var].copy()\n\n    hgrid_lat = ds_xmet[xmet_lat_var].values.flatten()\n    hgrid_lon = ds_xmet[xmet_lon_var].values.flatten()\n    hgrid_alt = ds_xmet[xmet_height_var].values\n    hgrid_coords = sequence_geo_to_ecef(hgrid_lat, hgrid_lon)\n\n    track_lat = ds_vert[lat_var].values\n    track_lon = ds_vert[lon_var].values\n    track_alt = ds_vert[height_var].values\n    track_coords = sequence_geo_to_ecef(track_lat, track_lon)\n\n    tree = cKDTree(hgrid_coords)\n    dists, idxs = tree.query(track_coords, k=k)\n\n    # Inverse distance weighting\n    if k &gt; 1:\n        weights = 1.0 / (dists + eps)\n        weights /= np.sum(weights, axis=1, keepdims=True)\n        height = np.einsum(\"ij,ijh-&gt;ih\", weights, hgrid_alt[idxs])\n    else:\n        weights = np.ones(idxs.shape)\n        height = hgrid_alt[idxs]\n\n    dims: str | tuple[str, str]\n    for var in vars:\n        values = ds_xmet[var].values\n        if len(values.shape) == 0:\n            continue\n\n        if len(values.shape) == 1:\n            dims = along_track_dim\n\n            if k &gt; 1:\n                result = np.sum(values[idxs] * weights, axis=1)\n                new_values = result\n            else:\n                new_values = values[idxs]\n        else:\n            dims = (along_track_dim, height_dim)\n\n            if k &gt; 1:\n                result = np.einsum(\"ij,ijh-&gt;ih\", weights, values[idxs])\n            else:\n                result = values[idxs]\n\n            new_values = np.empty(track_alt.shape)\n            new_values[:] = np.nan\n\n            for i in np.arange(track_alt.shape[0]):\n                _new_values = np.interp(\n                    track_alt[i],\n                    height[i],\n                    result[i],\n                )\n                # _new_values = interp(track_alt[i])\n\n                # Fill nans\n                # _new_values[np.isnan(_new_values) &amp; (track_alt[i] &lt; height[i, 0])] = result[i, 0]\n                # _new_values[np.isnan(_new_values) &amp; (track_alt[i] &gt; height[i, -1])] = result[i, -1]\n\n                new_values[i] = _new_values\n\n        new_var = f\"{var}\"\n        new_ds_xmet[new_var] = (dims, new_values)\n        new_ds_xmet[new_var].attrs = ds_xmet[var].attrs\n\n    new_ds_xmet = remove_dims(new_ds_xmet, [xmet_horizontal_grid_dim, xmet_height_dim])\n\n    return new_ds_xmet\n</code></pre>"},{"location":"api_ref/#earthcarekit.save_plot","title":"save_plot","text":"<pre><code>save_plot(\n    fig,\n    filename=\"\",\n    filepath=None,\n    ds=None,\n    ds_filepath=None,\n    pad=0.1,\n    dpi=\"figure\",\n    orbit_and_frame=None,\n    utc_timestamp=None,\n    use_utc_creation_timestamp=False,\n    site_name=None,\n    hmax=None,\n    radius=None,\n    resolution=None,\n    extra=None,\n    transparent_outside=False,\n    verbose=True,\n    print_prefix=\"\",\n    create_dirs=False,\n    transparent_background=False,\n    **kwargs\n)\n</code></pre> <p>Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure | HasFigure</code> <p>A figure object (<code>matplotlib.figure.Figure</code>) or objects exposing a <code>.fig</code> attribute containing a figure (e.g., <code>CurtainFigure</code>).</p> required <code>filename</code> <code>str</code> <p>The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.</p> <code>''</code> <code>filepath</code> <code>str | None</code> <p>The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.</p> <code>None</code> <code>ds</code> <code>Dataset | None</code> <p>A EarthCARE dataset from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>ds_filepath</code> <code>str | None</code> <p>A path to a EarthCARE product from which metadata will be taken. Defaults to None.</p> <code>None</code> <code>pad</code> <code>float</code> <p>Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.</p> <code>0.1</code> <code>dpi</code> <code>float | figure</code> <p>The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.</p> <code>'figure'</code> <code>orbit_and_frame</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>utc_timestamp</code> <code>TimestampLike | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>use_utc_creation_timestamp</code> <code>bool</code> <p>Whether the time of image creation should be included in the file name. Defaults to False.</p> <code>False</code> <code>site_name</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>hmax</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>radius</code> <code>int | float | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>str | None</code> <p>Metadata used in the formatting of the file name. Defaults to None.</p> <code>None</code> <code>extra</code> <code>str | None</code> <p>A custom string to be included in the file name. Defaults to None.</p> <code>None</code> <code>transparent_outside</code> <code>bool</code> <p>Whether the area outside figures should be transparent. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether the progress of image creation should be printed to the console. Defaults to True.</p> <code>True</code> <code>print_prefix</code> <code>str</code> <p>A prefix string to all console messages. Defaults to \"\".</p> <code>''</code> <code>create_dirs</code> <code>bool</code> <p>Whether images should be saved in a folder structure based on provided metadata. Defaults to False.</p> <code>False</code> <code>transparent_background</code> <code>bool</code> <p>Whether the background inside and outside of figures should be transparent. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments passed to wrapped function call of <code>matplotlib.pyplot.savefig</code>.</p> <code>{}</code> Source code in <code>earthcarekit/plot/save/simple_save.py</code> <pre><code>def save_plot(\n    fig: Figure | HasFigure,\n    filename: str = \"\",\n    filepath: str | None = None,\n    ds: xr.Dataset | None = None,\n    ds_filepath: str | None = None,\n    pad: float = 0.1,\n    dpi: float | Literal[\"figure\"] = \"figure\",\n    orbit_and_frame: str | None = None,\n    utc_timestamp: TimestampLike | None = None,\n    use_utc_creation_timestamp: bool = False,\n    site_name: str | None = None,\n    hmax: int | float | None = None,\n    radius: int | float | None = None,\n    resolution: str | None = None,\n    extra: str | None = None,\n    transparent_outside: bool = False,\n    verbose: bool = True,\n    print_prefix: str = \"\",\n    create_dirs: bool = False,\n    transparent_background: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Save a figure as an image or vector graphic to a file and optionally format the file name in a structured way using EarthCARE metadata.\n\n    Args:\n        figure (Figure | HasFigure): A figure object (`matplotlib.figure.Figure`) or objects exposing a `.fig` attribute containing a figure (e.g., `CurtainFigure`).\n        filename (str, optional): The base name of the file. Can be extended based on other metadata provided. Defaults to empty string.\n        filepath (str | None, optional): The path where the image is saved. Can be extended based on other metadata provided. Defaults to None.\n        ds (xr.Dataset | None, optional): A EarthCARE dataset from which metadata will be taken. Defaults to None.\n        ds_filepath (str | None, optional): A path to a EarthCARE product from which metadata will be taken. Defaults to None.\n        pad (float, optional): Extra padding (i.e., empty space) around the image in inches. Defaults to 0.1.\n        dpi (float | 'figure', optional): The resolution in dots per inch. If 'figure', use the figure's dpi value. Defaults to None.\n        orbit_and_frame (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        utc_timestamp (TimestampLike | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        use_utc_creation_timestamp (bool, optional): Whether the time of image creation should be included in the file name. Defaults to False.\n        site_name (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        hmax (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        radius (int | float | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        resolution (str | None, optional): Metadata used in the formatting of the file name. Defaults to None.\n        extra (str | None, optional): A custom string to be included in the file name. Defaults to None.\n        transparent_outside (bool, optional): Whether the area outside figures should be transparent. Defaults to False.\n        verbose (bool, optional): Whether the progress of image creation should be printed to the console. Defaults to True.\n        print_prefix (str, optional): A prefix string to all console messages. Defaults to \"\".\n        create_dirs (bool, optional): Whether images should be saved in a folder structure based on provided metadata. Defaults to False.\n        transparent_background (bool, optional): Whether the background inside and outside of figures should be transparent. Defaults to False.\n        **kwargs (dict[str, Any]): Keyword arguments passed to wrapped function call of `matplotlib.pyplot.savefig`.\n    \"\"\"\n    if not isinstance(fig, Figure):\n        fig = fig.fig\n\n    _stime: str = pd.Timestamp.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    try:\n        if transparent_background:\n            transparent_outside = True\n\n        new_filepath = create_filepath(\n            filename,\n            filepath,\n            ds,\n            ds_filepath,\n            orbit_and_frame,\n            utc_timestamp,\n            use_utc_creation_timestamp,\n            site_name,\n            hmax,\n            radius,\n            extra,\n            create_dirs,\n            resolution,\n        )\n\n        if transparent_outside:\n            fig.patch.set_alpha(0)\n        if transparent_background:\n            for ax in fig.get_axes():\n                ax.patch.set_alpha(0)\n\n        if verbose:\n            print(f\"{print_prefix}Saving plot ...\", end=\"\\r\")\n        save_figure_with_auto_margins(\n            fig,\n            new_filepath,\n            pad=pad,\n            dpi=dpi,\n            **kwargs,\n        )\n\n        # Restore original settings\n        if transparent_outside:\n            fig.patch.set_alpha(1)\n        if transparent_background:\n            for ax in fig.get_axes():\n                ax.patch.set_alpha(1)\n\n        _etime: str = pd.Timestamp.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        _dtime: str = str(pd.Timestamp(_etime) - pd.Timestamp(_stime)).split()[-1]\n        if verbose:\n            print(f\"{print_prefix}Plot saved (time taken {_dtime}): &lt;{new_filepath}&gt;\")\n\n        # raise ValueError(f\"hi\")\n    except ValueError as e:\n        if verbose:\n            print(f\"{print_prefix}Did not create plot since an error occured: {e}\")\n</code></pre>"},{"location":"api_ref/#earthcarekit.search_files_by_regex","title":"search_files_by_regex","text":"<pre><code>search_files_by_regex(root_dirpath, regex_pattern)\n</code></pre> <p>Recursively searches for files in a directory that match a given regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>root_dirpath</code> <code>str</code> <p>The root directory to start the search from.</p> required <code>regex_pattern</code> <code>str</code> <p>A regular expression pattern to match file names against.</p> required Return <p>list[str]: A list of absolute file paths that point to files with matching names.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the root directory does not exist.</p> <code>error</code> <p>If the given pattern is not a valid regular expression.</p> Source code in <code>earthcarekit/utils/read/search.py</code> <pre><code>def search_files_by_regex(root_dirpath: str, regex_pattern: str) -&gt; list[str]:\n    \"\"\"\n    Recursively searches for files in a directory that match a given regex pattern.\n\n    Args:\n        root_dirpath (str): The root directory to start the search from.\n        regex_pattern (str): A regular expression pattern to match file names against.\n\n    Return:\n        list[str]: A list of absolute file paths that point to files with matching names.\n\n    Raises:\n        FileNotFoundError: If the root directory does not exist.\n        re.error: If the given pattern is not a valid regular expression.\n    \"\"\"\n    if not os.path.exists(root_dirpath):\n        raise FileNotFoundError(\n            f\"{search_files_by_regex.__name__}() Root directory does not exist: {root_dirpath}\"\n        )\n\n    filepaths = []\n    for dirpath, _, filenames in os.walk(root_dirpath):\n        for filename in filenames:\n            filepath = os.path.join(dirpath, filename)\n            if re.search(regex_pattern, filename):\n                filepaths.append(filepath)\n    return filepaths\n</code></pre>"},{"location":"api_ref/#earthcarekit.search_product","title":"search_product","text":"<pre><code>search_product(\n    root_dirpath=None,\n    config=None,\n    file_type=None,\n    agency=None,\n    latency=None,\n    timestamp=None,\n    baseline=None,\n    orbit_and_frame=None,\n    orbit_number=None,\n    frame_id=None,\n    filename=None,\n    start_time=None,\n    end_time=None,\n)\n</code></pre> <p>Searches for EarthCARE product files matching given metadata filters.</p> <p>Parameters:</p> Name Type Description Default <code>root_dirpath</code> <code>str</code> <p>Root directory to search. Defaults to directory given in a configuration file.</p> <code>None</code> <code>config</code> <code>str | ECKConfig | None</code> <p>Path to a <code>config.toml</code> file or a ECKConfig instance. Defaults to the default configuration file path.</p> <code>None</code> <code>file_type</code> <code>str | Sequence[str]</code> <p>Product file type(s) to match.</p> <code>None</code> <code>agency</code> <code>str | Sequence[str]</code> <p>Producing agency or agencies (e.g. \"ESA\" or \"JAXA\").</p> <code>None</code> <code>latency</code> <code>str | Sequence[str]</code> <p>Data latency level(s).</p> <code>None</code> <code>timestamp</code> <code>TimestampLike | Sequence</code> <p>Timestamp(s) included in the product's time coverage.</p> <code>None</code> <code>baseline</code> <code>str | Sequence[str]</code> <p>Baseline version(s).</p> <code>None</code> <code>orbit_and_frame</code> <code>str | Sequence[str]</code> <p>Orbit and frame identifiers.</p> <code>None</code> <code>orbit_number</code> <code>int, str, | Sequence</code> <p>Orbit number(s).</p> <code>None</code> <code>frame_id</code> <code>str | Sequence[str]</code> <p>Frame identifier(s).</p> <code>None</code> <code>filename</code> <code>str | Sequence[str]</code> <p>Specific filename(s) or regular expression patterns to match.</p> <code>None</code> <code>start_time</code> <code>TimestampLike</code> <p>First timestamp included in the product's time coverage.</p> <code>None</code> <code>end_time</code> <code>TimestampLike</code> <p>Last timestamp included in the product's time coverage.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ProductDataFrame</code> <code>ProductDataFrame</code> <p>Filtered list of matching product files as a <code>pandas.DataFrame</code>-based object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If root directory does not exist.</p> Source code in <code>earthcarekit/utils/read/product/_search.py</code> <pre><code>def search_product(\n    root_dirpath: str | None = None,\n    config: str | ECKConfig | None = None,\n    file_type: str | Sequence[str] | None = None,\n    agency: str | Sequence[str] | None = None,\n    latency: str | Sequence[str] | None = None,\n    timestamp: TimestampLike | Sequence[TimestampLike] | None = None,\n    baseline: str | Sequence[str] | None = None,\n    orbit_and_frame: str | Sequence[str] | None = None,\n    orbit_number: int | str | Sequence[int | str] | None = None,\n    frame_id: str | Sequence[str] | None = None,\n    filename: str | Sequence[str] | None = None,\n    start_time: TimestampLike | None = None,\n    end_time: TimestampLike | None = None,\n) -&gt; ProductDataFrame:\n    \"\"\"\n    Searches for EarthCARE product files matching given metadata filters.\n\n    Args:\n        root_dirpath (str, optional): Root directory to search. Defaults to directory given in a configuration file.\n        config (str | ECKConfig | None , optional): Path to a `config.toml` file or a ECKConfig instance. Defaults to the default configuration file path.\n        file_type (str | Sequence[str], optional): Product file type(s) to match.\n        agency (str | Sequence[str], optional): Producing agency or agencies (e.g. \"ESA\" or \"JAXA\").\n        latency (str | Sequence[str], optional): Data latency level(s).\n        timestamp (TimestampLike | Sequence, optional): Timestamp(s) included in the product's time coverage.\n        baseline (str | Sequence[str], optional): Baseline version(s).\n        orbit_and_frame (str | Sequence[str], optional): Orbit and frame identifiers.\n        orbit_number (int, str, | Sequence, optional): Orbit number(s).\n        frame_id (str | Sequence[str], optional): Frame identifier(s).\n        filename (str | Sequence[str], optional): Specific filename(s) or regular expression patterns to match.\n        start_time (TimestampLike, optional): First timestamp included in the product's time coverage.\n        end_time (TimestampLike, optional): Last timestamp included in the product's time coverage.\n\n    Returns:\n        ProductDataFrame: Filtered list of matching product files as a `pandas.DataFrame`-based object.\n\n    Raises:\n        FileNotFoundError: If root directory does not exist.\n    \"\"\"\n    if not isinstance(root_dirpath, str):\n        if isinstance(config, ECKConfig):\n            root_dirpath = config.path_to_data\n        else:\n            root_dirpath = read_config(config).path_to_data\n\n    if not os.path.exists(root_dirpath):\n        raise FileNotFoundError(f\"Given root directory does not exist: {root_dirpath}\")\n\n    mission_id = \"ECA\"\n\n    if isinstance(file_type, str):\n        file_type = [file_type]\n    if isinstance(file_type, Sequence):\n        _baseline: list[str] = []\n        _file_type: list[str] = []\n        for i, ft in enumerate(file_type):\n            if isinstance(ft, str):\n                _parts = ft.split(\":\")\n                if len(_parts) == 2:\n                    _file_type.append(_parts[0])\n                    _baseline.append(_parts[1])\n                    continue\n            _file_type.append(ft)\n            if isinstance(baseline, str):\n                _baseline.append(baseline)\n            elif isinstance(baseline, Sequence):\n                try:\n                    _baseline.append(baseline[i])\n                except IndexError as e:\n                    raise IndexError(e, f\"given baseline list is too small\")\n            else:\n                _baseline.append(\"latest\")\n        file_type = _file_type\n        baseline = _baseline\n    file_type = _to_file_info_list(file_type, FileType)\n    baseline = _format_input(\n        baseline,\n        file_types=file_type,\n        default_input=\"..\",\n        format_func=validate_baseline,\n    )\n    baseline_and_file_type_list = [f\"{bl}_{ft}\" for bl, ft in zip(baseline, file_type)]\n    baseline_and_file_type = _list_to_regex(\n        baseline_and_file_type_list, \".._..._..._..\"\n    )\n\n    agency = _to_file_info_list(agency, FileAgency)\n    agency = _list_to_regex(agency, \".\")\n\n    latency = _to_file_info_list(latency, FileLatency)\n    latency = _list_to_regex(latency, \".\")\n\n    timestamp = _format_input(timestamp, format_func=to_timestamp)\n    _start_time = [] if start_time is None else [to_timestamp(start_time)]\n    _end_time = [] if end_time is None else [to_timestamp(end_time)]\n    timestamp = timestamp + _start_time + _end_time\n\n    orbit_and_frame = _format_input(orbit_and_frame, format_func=format_orbit_and_frame)\n    orbit_and_frame = _list_to_regex(orbit_and_frame, \".\" * 6)\n\n    orbit_number = _format_input(orbit_number, format_func=format_orbit_number)\n    orbit_number = _list_to_regex(orbit_number, \".\" * 5)\n\n    frame_id = _format_input(frame_id, format_func=format_frame_id)\n    frame_id = _list_to_regex(frame_id, \".\")\n\n    oaf_list = []\n    oaf = \"\"\n    if orbit_number != \".\" * 5:\n        oaf_list.append(orbit_number)\n    if frame_id != \".\":\n        oaf_list.append(frame_id)\n    if orbit_number != \".\" * 5 or frame_id != \".\":\n        oaf = f\"{orbit_number}{frame_id}\"\n\n    if oaf == \"\":\n        oaf = orbit_and_frame\n    elif oaf != \"\" and orbit_and_frame != \".\" * 6:\n        oaf = f\"(({oaf})|{orbit_and_frame})\"\n\n    pattern = f\".*{mission_id}_{agency}{latency}{baseline_and_file_type}_........T......Z_........T......Z_{oaf}.h5\"\n\n    # pattern = search_pattern(\n    #     file_type=file_type,\n    #     agency=agency,\n    #     latency=latency,\n    #     timestamp=timestamp,\n    #     baseline=baseline,\n    #     orbit_and_frame=orbit_and_frame,\n    #     orbit_number=orbit_number,\n    #     frame_id=frame_id,\n    # )\n\n    if pattern == \".*ECA_...._..._..._.._........T......Z_........T......Z_.......h5\":\n        files = []\n    else:\n        files = search_files_by_regex(root_dirpath, pattern)\n\n    if isinstance(filename, str) or isinstance(filename, Sequence):\n        if isinstance(filename, str):\n            filename = [filename]\n        _get_pattern = lambda fn: f\".*{os.path.basename(fn).replace('.h5', '')}.*.h5\"\n        filename = [_get_pattern(fn) for fn in filename]\n    elif filename is None:\n        filename = []\n    else:\n        raise TypeError(\n            f\"Given filename has invalid type ({type(filename)}: {filename})\"\n        )\n\n    for fn in filename:\n        new_files = search_files_by_regex(root_dirpath, fn)\n        files.extend(new_files)\n\n    # Remove duplicates\n    files = list(set(files))\n\n    old_files = files.copy()\n    if len(timestamp) &gt; 0:\n        files = []\n        for t in timestamp:\n            new_files = [\n                f for f in old_files if _check_product_contains_timestamp(f, t)\n            ]\n            if len(new_files) &gt; 0:\n                files.extend(new_files)\n\n    pdf = get_product_infos(files)\n\n    if start_time is not None or end_time is not None:\n        _pdf = get_product_infos(old_files)\n        _pdf = filter_time_range(_pdf, start_time=start_time, end_time=end_time)\n\n        if not pdf.empty and not _pdf.empty:\n            pdf = ProductDataFrame(pd.concat([pdf, _pdf], ignore_index=True))\n        elif not _pdf.empty:\n            pdf = _pdf\n\n    pdf = pdf.sort_values(by=[\"orbit_and_frame\", \"file_type\", \"start_processing_time\"])\n    pdf = pdf.drop_duplicates()\n    pdf = pdf.reset_index(drop=True)\n\n    pdf.validate_columns()\n    return pdf\n</code></pre>"},{"location":"api_ref/#earthcarekit.set_config","title":"set_config","text":"<pre><code>set_config(c, verbose=True)\n</code></pre> <p>Creates or updates the default earthcarekit configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>str | ECKConfig</code> <p>Filepath to a configuration file (.toml) or configuration object.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints a message to the console. Defaults to True.</p> <code>True</code> Source code in <code>earthcarekit/utils/config.py</code> <pre><code>def set_config(c: str | ECKConfig, verbose: bool = True) -&gt; None:\n    \"\"\"\n    Creates or updates the default earthcarekit configuration file.\n\n    Args:\n        c (str | ECKConfig): Filepath to a configuration file (.toml) or configuration object.\n        verbose (bool): If True, prints a message to the console. Defaults to True.\n    \"\"\"\n    _set_config(c=c, verbose=verbose)\n</code></pre>"},{"location":"api_ref/#earthcarekit.set_config_maap_token","title":"set_config_maap_token","text":"<pre><code>set_config_maap_token(token)\n</code></pre> <p>Updates the ESA MAAP access token in the default earthcarekit configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>A temporary ESA MAAP access token (to generate it visit: https://portal.maap.eo.esa.int/ini/services/auth/token/).</p> required Source code in <code>earthcarekit/utils/config.py</code> <pre><code>def set_config_maap_token(token: str) -&gt; None:\n    \"\"\"\n    Updates the ESA MAAP access token in the default earthcarekit configuration file.\n\n    Args:\n        token (str): A temporary ESA MAAP access token (to generate it visit: https://portal.maap.eo.esa.int/ini/services/auth/token/).\n    \"\"\"\n    _config: ECKConfig = read_config()\n    _config.maap_token = token\n    _set_config(\n        _config,\n        alt_msg=f\"Set MAAP access token\",\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.set_config_to_maap","title":"set_config_to_maap","text":"<pre><code>set_config_to_maap()\n</code></pre> <p>Sets the download backend to the ESA MAAP system in the default earthcarekit configuration file.</p> Source code in <code>earthcarekit/utils/config.py</code> <pre><code>def set_config_to_maap() -&gt; None:\n    \"\"\"Sets the download backend to the ESA MAAP system in the default earthcarekit configuration file.\"\"\"\n    _config: ECKConfig = read_config()\n    _config.download_backend = \"maap\"\n    _set_config(\n        _config,\n        alt_msg=f\"Set download backend to {_config.download_backend.upper()}\",\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.set_config_to_oads","title":"set_config_to_oads","text":"<pre><code>set_config_to_oads()\n</code></pre> <p>Sets the download backend to OADS in the default earthcarekit configuration file.</p> Source code in <code>earthcarekit/utils/config.py</code> <pre><code>def set_config_to_oads() -&gt; None:\n    \"\"\"Sets the download backend to OADS in the default earthcarekit configuration file.\"\"\"\n    _config: ECKConfig = read_config()\n    _config.download_backend = \"oads\"\n    _set_config(\n        _config,\n        alt_msg=f\"Set download backend to {_config.download_backend.upper()}\",\n    )\n</code></pre>"},{"location":"api_ref/#earthcarekit.shift_cmap","title":"shift_cmap","text":"<pre><code>shift_cmap(cmap, start=0.0, midpoint=0.5, stop=1.0, name='shifted_cmap')\n</code></pre> <p>Create a colormap with its center point shifted to a specified value.</p> <p>This function is useful for data with asymmetric ranges (e.g., negative min and positive max) where you want the center of the colormap to align with a specific value like zero.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str | Colormap | None</code> <p>Colormap to be modified</p> required <code>start</code> <code>float</code> <p>Lower bound of the colormap range (value between 0 and <code>midpoint</code>). Defaults to 0.0.</p> <code>0.0</code> <code>midpoint</code> <code>float</code> <p>New center point of the colormap (value between 0 and 1). Defaults to 0.5. For data ranging from vmin to vmax where you want the center at value v, set midpoint = 1 - vmax/(vmax + abs(vmin))</p> <code>0.5</code> <code>stop</code> <code>float</code> <p>Upper bound of the colormap range (value between <code>midpoint</code> and 1). Defaults to 1.0.</p> <code>1.0</code> <code>name</code> <code>str</code> <p>Name of the new colormap. Defaults to \"shifted_cmap\".</p> <code>'shifted_cmap'</code> <p>Returns:</p> Name Type Description <code>Cmap</code> <code>Cmap</code> <p>New colormap with shifted center</p> Source code in <code>earthcarekit/plot/color/colormap/shift/_shift_cmap.py</code> <pre><code>def shift_cmap(\n    cmap: str | Colormap | None,\n    start: float = 0.0,\n    midpoint: float = 0.5,\n    stop: float = 1.0,\n    name: str = \"shifted_cmap\",\n) -&gt; Cmap:\n    \"\"\"Create a colormap with its center point shifted to a specified value.\n\n    This function is useful for data with asymmetric ranges (e.g., negative min and\n    positive max) where you want the center of the colormap to align with a specific\n    value like zero.\n\n    Args:\n        cmap (str | Colormap | None): Colormap to be modified\n        start (float): Lower bound of the colormap range (value between 0 and `midpoint`). Defaults to 0.0.\n        midpoint (float): New center point of the colormap (value between 0 and 1). Defaults to 0.5.\n            For data ranging from vmin to vmax where you want the center at value v,\n            set midpoint = 1 - vmax/(vmax + abs(vmin))\n        stop (float): Upper bound of the colormap range (value between `midpoint` and 1). Defaults to 1.0.\n        name (str): Name of the new colormap. Defaults to \"shifted_cmap\".\n\n    Returns:\n        Cmap: New colormap with shifted center\n    \"\"\"\n    from ..colormap import get_cmap\n\n    cmap = get_cmap(cmap)\n    cmap = shift_mpl_colormap(\n        cmap,\n        start=start,\n        midpoint=midpoint,\n        stop=stop,\n        name=name,\n    )\n    cmap = get_cmap(cmap)\n\n    return cmap\n</code></pre>"},{"location":"cli_tools/","title":"Command-Line Interface Tools","text":""},{"location":"cli_tools/#command-line-interface-tools","title":"Command-Line Interface Tools","text":"<p>The package provides 2 command-line interface (CLI) tools:</p> <ol> <li><code>ecdownload</code> for searching, selection and downloading EarthCARE products from ESA's dissemination platfroms OADS or MAAP (depending on your configuration)</li> <li><code>ecquicklook</code> for fast generation of preview visualisations of EarthCARE datasets</li> </ol>"},{"location":"colormaps/","title":"Colormaps","text":""},{"location":"colormaps/#colormaps","title":"Colormaps","text":"<p>Figure objects such as <code>CurtainFigure</code> accept <code>matplotlib.colors.Colormap</code> objects or a name string, which then retrieves the appropriate colormap from <code>matplotlib</code>, <code>plotly</code>, <code>cmcrameri</code>, and from a list of pre-defined colormaps for <code>earthcarekit</code>:</p> <p></p> <p>Advanced</p> <p>In case you want to get an <code>matplotlib.Colormap</code> object and call by name, use the <code>get_cmap</code> function.</p> <p>All pre-defined colour tables for <code>earthcarekit</code> are also listed in <code>earthcarekit.cmaps</code>.</p>"},{"location":"colormaps/#categorical-colormaps","title":"Categorical colormaps","text":"<p>For classification data (e.g., ATLID target classification) categorical colormaps can be created using the <code>Cmap.to_categorical</code> method:</p> <pre><code>cmap = eck.get_cmap(\"viridis\")\nvalues_to_labels = {\n    0: \"class 1\",\n    1: \"class 2\",\n    100: \"class 3\",\n    -1: \"missing data\",\n}\ncmap_categorical = cmap.to_categorical(values_to_labels)\n\n# Example plot\neck.CurtainFigure().plot(\n    values=[[-1,  0,  1, 100],\n            [ 1, -1,  1,   0],\n            [ 0,  1, -1,   1]],\n    height=[5e3,15e3, 25e3, 35e3],\n    time=[\"20250101\", \"20250201\", \"20250301\"],\n    cmap=cmap_categorical,\n)\n</code></pre>"},{"location":"colormaps/#shifting-the-midpoint","title":"Shifting the midpoint","text":"<p>See <code>shift_cmap</code>.</p> <pre><code>def plot_cmap(c):\n    import matplotlib.pyplot as plt\n    _, ax = plt.subplots(figsize=(6, 0.5))\n    plt.colorbar(plt.cm.ScalarMappable(cmap=c), cax=ax, orientation=\"horizontal\", label=c.name)\n    plt.show()\n\ncmap = eck.get_cmap(\"RdBu\")\nplot_cmap(cmap)\n\ncmap_shifted = eck.shift_cmap(cmap, midpoint=0.2, name=\"RdBu_shifted\")\nplot_cmap(cmap_shifted)\n</code></pre>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#setup","title":"Setup","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>Set up a Python 3.11+ environment with <code>pip</code> available, then install the latest version from PyPI:</p> <pre><code>pip install earthcarekit\n\n# Check installed version\necdownload -V\n\n# Update to the latest release whenever needed\npip install earthcarekit --upgrade\n\n# Note for conda users: To avoid mixing conda and system packages, use instead\npython -m pip install earthcarekit [--upgrade]\n</code></pre> Advanced: Install Latest Pre-Release from GitHub. <pre><code>pip install -U git+https://github.com/TROPOS-RSD/earthcarekit.git\n\n# Or, install manually from a local clone\npip install .\n</code></pre>"},{"location":"setup/#configuration","title":"Configuration","text":"<p>Set up a configuration file to define storage paths and access to data platforms. ESA products require an ESA account. Applied via Python, the settings are saved at ~/.config/earthcarekit/default_config.toml.</p> <p>Before using the package, you need to set up a configuration file to define storage paths and download credentials. Downloading EarthCARE products requires an ESA account. You can create one at OADS or MAAP</p> <p>Once applied via Python, your settings are saved to your home directory at <code>~/.config/earthcarekit/default_config.toml</code>.</p> <p>Warning</p> <p>As of August 2025, data dissemination is transitioning from OADS to MAAP. OADS is still recommended for now, but will be phased out by the end of 2025.</p> Example: See an example configuration file. example_config.toml<pre><code>[local]\n# Set a path to your root EarthCARE data directory,\n# where local EarthCARE product files will be searched and downloaded to.\ndata_directory = \"\"\n\n# Set a path to your root image directory,\n# where saved plots will be put.\nimage_directory = \"\"\n\n[download]\n# You have 2 options to set your data access rights:\n# 1. (recommended) Choose one: \"commissioning\", \"calval\" or \"open\", e.g.:\n#         collections = \"calval\"\n# 2. List individual collections, e.g.:\n#         collections = [\n#             \"EarthCAREL1InstChecked\",\n#             \"EarthCAREL2InstChecked\",\n#             ...\n#         ]\ncollections = \"open\"\n\n# Set your data dissemination service that will be used for remote data search and download.\n# Choose one: \"oads\" or \"maap\"\nplatform = \"oads\"\n\n# If you've choosen \"maap\", generate a data access token on EarthCARE MAAP and put it here:\n# (see &lt;https://portal.maap.eo.esa.int/earthcare/&gt;)\nmaap_token = \"\"\n\n# If you've choosen \"oads\", give your OADS credencials here:\n# (see &lt;https://ec-pdgs-dissemination1.eo.esa.int&gt; and &lt;https://ec-pdgs-dissemination2.eo.esa.int&gt;)\noads_username = \"my_username\"\noads_password = \"\"\"my_password\"\"\"\n</code></pre>"},{"location":"setup/#configuration-via-the-python-interpreter","title":"Configuration via the Python Interpreter","text":"<ol> <li> <p>Open the Python interpreter and generate an example configuration file in your current directory:</p> <pre><code>$ python\n&gt;&gt;&gt; import earthcarekit as eck\n&gt;&gt;&gt; eck.create_example_config()\n</code></pre> </li> <li> <p>Edit the generated file.</p> <p>Follow the instructions in the inline comments of the exsample file to customize your settings. You may rename and save your file to any location.</p> </li> <li> <p>Go back to the Python Interpreter and apply your configuration file as default:</p> <pre><code>&gt;&gt;&gt; eck.set_config(path_to_file)\n&gt;&gt;&gt; exit()\n</code></pre> </li> </ol> <p>You can later view or manually edit the saved configuration at <code>~/.config/earthcarekit/default_config.toml</code>. To update your settings, you can also simply repeat the steps above.</p>"},{"location":"supported_products/","title":"Supported products","text":""},{"location":"supported_products/#supported-earthcare-products","title":"Supported EarthCARE products","text":"<p>The following tables describe the coverage for EarthCARE products for the latest version 0.9.2 of <code>earthcarekit</code>.</p> <p>Note</p> <p>Here, reading support means that the product can be opend using the <code>read_product</code> function. Products that are not yet supported can also be opened as a <code>xarray.Dataset</code> by using the more basic <code>read_science_data</code> function. The latter function reads the data unmodified, without adding metadata or harmonising dimension names, which can lead to errors when using other utility functions of the package.</p>"},{"location":"supported_products/#level-1-products","title":"Level 1 products","text":"File type Read Quicklook Notes ATL_NOM_1B \u2713 \u2713 MSI_NOM_1B BBR_NOM_1B CPR_NOM_1B \u2713 JAXA product MSI_RGR_1C \u2713"},{"location":"supported_products/#level-2a-products","title":"Level 2a products","text":"File type Read Quicklook Notes ATL_FM__2A \u2713 \u2713 ATL_AER_2A \u2713 \u2713 ATL_ICE_2A \u2713 ATL_TC__2A \u2713 \u2713 ATL_EBD_2A \u2713 \u2713 ATL_CTH_2A \u2713 \u2713 QL needs additional products for background curtain (e.g., A-EBD bsc.) ATL_ALD_2A \u2713 \u2713 QL needs additional products for background curtain (e.g., A-EBD bsc.) MSI_CM__2A MSI_COP_2A MSI_AOT_2A CPR_FMR_2A \u2713 \u2713 CPR_CD__2A \u2713 \u2713 CPR_TC__2A \u2713 \u2713 CPR_CLD_2A \u2713 \u2713 CPR_APC_2A ATL_CLA_2A \u2713 JAXA product MSI_CLP_2A JAXA product CPR_ECO_2A \u2713 JAXA product CPR_CLP_2A \u2713 JAXA product"},{"location":"supported_products/#level-2b-products","title":"Level 2b products","text":"File type Read Quicklook Notes AM__MO__2B AM__CTH_2B \u2713 AM__ACD_2B \u2713 AC__TC__2B \u2713 \u2713 BM__RAD_2B BMA_FLX_2B ACM_CAP_2B \u2713 \u2713 ACM_COM_2B ACM_RT__2B ALL_3D__2B ALL_DF__2B AC__CLP_2B JAXA product ACM_CLP_2B JAXA product ALL_RAD_2B JAXA product"},{"location":"api_ref/geo/","title":"earthcarekit.geo","text":""},{"location":"api_ref/geo/#api-reference","title":"API reference","text":"<p>earthcarekit.geo</p> <p>Geospatial utilities for handling coordinates, coordinate transformations, distance calculation, and interpolation.</p>"},{"location":"api_ref/geo/#earthcarekit.geo.create_spherical_grid","title":"create_spherical_grid","text":"<pre><code>create_spherical_grid(\n    nlat, nlon=None, reduced=False, lat_spacing=\"regular\"\n)\n</code></pre> <p>Generate a spherical gird with regular, sinusoidal or gaussian latitudes and uniform or reduced longitudes.</p> <p>Parameters:</p> Name Type Description Default <code>nlat</code> <code>int</code> <p>Number of latitude.</p> required <code>nlon</code> <code>int | None</code> <p>Nuber of longitudes at the equator. If None, set to <code>nlat * 2</code>. Defaults to None.</p> <code>None</code> <code>reduced</code> <code>bool</code> <p>If True, reduces longitudes near poles using <code>~cos(latitude)</code> scaling. Defaults to False.</p> <code>False</code> <code>lat_spacing</code> <code>regular or sinusoidal or gaussian</code> <p>Method used to place latitudes. Defaults to \"regular\".</p> <code>'regular'</code> <p>Returns:</p> Name Type Description <code>SphericalGrid</code> <code>SphericalGrid</code> <p>A container storing</p> <code>SphericalGrid</code> <ul> <li>lat_centers: A <code>numpy.array</code> of latitude bin centers.</li> </ul> <code>SphericalGrid</code> <ul> <li>lon_centers: A <code>numpy.array</code> of longitude bin centers or if <code>is_reduced=True</code> a list of <code>numpy.array</code> per latitude center.</li> </ul> <code>SphericalGrid</code> <ul> <li>lat_bounds: A <code>numpy.array</code> of latitude bin bounds.</li> </ul> <code>SphericalGrid</code> <ul> <li>lon_bounds: A <code>numpy.array</code> of longitude bin bounds or if <code>is_reduced=True</code> a list of <code>numpy.array</code> per latitude bound.</li> </ul> <code>SphericalGrid</code> <ul> <li>is_reduced (bool): Whether the grid has reduced number of longitudes near the poles.</li> </ul> Source code in <code>earthcarekit/utils/geo/grid/_create_global_grid.py</code> <pre><code>def create_spherical_grid(\n    nlat: int,\n    nlon: int | None = None,\n    reduced: bool = False,\n    lat_spacing: Literal[\"regular\", \"sinusoidal\", \"gaussian\"] = \"regular\",\n) -&gt; SphericalGrid:\n    \"\"\"\n    Generate a spherical gird with regular, sinusoidal or gaussian latitudes and uniform or reduced longitudes.\n\n    Args:\n        nlat (int): Number of latitude.\n        nlon (int | None): Nuber of longitudes at the equator. If None, set to `nlat * 2`. Defaults to None.\n        reduced (bool): If True, reduces longitudes near poles using `~cos(latitude)` scaling. Defaults to False.\n        lat_spacing (\"regular\" or \"sinusoidal\" or \"gaussian\", optional): Method used to place latitudes. Defaults to \"regular\".\n\n    Returns:\n        SphericalGrid: A container storing\n\n        - lat_centers: A `numpy.array` of latitude bin centers.\n        - lon_centers: A `numpy.array` of longitude bin centers or if `is_reduced=True` a list of `numpy.array` per latitude center.\n        - lat_bounds: A `numpy.array` of latitude bin bounds.\n        - lon_bounds: A `numpy.array` of longitude bin bounds or if `is_reduced=True` a list of `numpy.array` per latitude bound.\n        - is_reduced (bool): Whether the grid has reduced number of longitudes near the poles.\n    \"\"\"\n\n    if nlon is None:\n        nlon = nlat + nlat\n\n    if lat_spacing == \"regular\":\n        lat_c, lat_b = _get_regular_latitudes(nlat)\n    elif lat_spacing == \"sinusoidal\":\n        lat_c, lat_b = _get_sinusoidal_latitudes(nlat)\n    elif lat_spacing == \"gaussian\":\n        lat_c, lat_b = _get_gaussian_latitudes(nlat)\n    else:\n        raise ValueError(\"grid_type must be 'regular', 'gaussian', or 'sinusoidal'\")\n\n    lon_b_list = _get_lon_bounds_per_lat(nlon, lat_c, reduced)\n\n    lon_b: NDArray | list[NDArray]\n    if reduced:\n        lon_b = lon_b_list\n        lon_c = [0.5 * (lb[:-1] + lb[1:]) for lb in lon_b_list]\n    else:\n        lon_b = lon_b_list[0]\n        lon_c = 0.5 * (lon_b[:-1] + lon_b[1:])\n\n    return SphericalGrid(\n        lat_centers=lat_c,\n        lon_centers=lon_c,\n        lat_bounds=lat_b,\n        lon_bounds=lon_b,\n        is_reduced=reduced,\n    )\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.ecef_to_geo","title":"ecef_to_geo","text":"<pre><code>ecef_to_geo(\n    x,\n    y,\n    z,\n    target_radius=1.0,\n    perfect_sphere=True,\n    semi_major=SEMI_MAJOR_AXIS_METERS,\n    semi_minor=SEMI_MINOR_AXIS_METERS,\n)\n</code></pre> <p>Converts Earth-centered, Earth-fixed (ECEF) coordinates (x, y, z) back to geodetic coordinates (latitude, longitude, altitude).</p> <p>Parameters:</p> Name Type Description Default <code>x, y, z</code> <code>float</code> <p>Cartesian ECEF coordinates.</p> required <code>target_radius</code> <code>float</code> <p>Target mean radius of the Earth ellipsoid in the new cartesian coordinate system. Defaults to 1.</p> <code>1.0</code> <code>perfect_sphere</code> <code>bool</code> <p>If True, assume a spherical Earth, else ellipsoidal (WGS-84).</p> <code>True</code> <code>semi_major</code> <code>float</code> <p>Semi-major axis of the Earth ellipsoid in meters. Defaults to 6378137 (WGS 84).</p> <code>SEMI_MAJOR_AXIS_METERS</code> <code>semi_minor</code> <code>float</code> <p>Semi-minor axis of the Earth ellipsoid in meters. Defaults to 6356752.314245 (WGS 84).</p> <code>SEMI_MINOR_AXIS_METERS</code> <p>Returns:</p> Name Type Description <code>coords</code> <code>tuple[float, float, float]</code> <ul> <li>lat (float): Latitude in degrees</li> <li>lon (float): Longitude in degrees</li> <li>alt (float): Altitude above ellipsoid in meters</li> </ul> Source code in <code>earthcarekit/utils/geo/convertsions.py</code> <pre><code>def ecef_to_geo(\n    x: SupportsFloat,\n    y: SupportsFloat,\n    z: SupportsFloat,\n    target_radius: float = 1.0,\n    perfect_sphere: bool = True,\n    semi_major: float = SEMI_MAJOR_AXIS_METERS,\n    semi_minor: float = SEMI_MINOR_AXIS_METERS,\n) -&gt; tuple[float, float, float]:\n    \"\"\"\n    Converts Earth-centered, Earth-fixed (ECEF) coordinates (x, y, z)\n    back to geodetic coordinates (latitude, longitude, altitude).\n\n    Args:\n        x, y, z (float): Cartesian ECEF coordinates.\n        target_radius (float): Target mean radius of the Earth ellipsoid in the new cartesian coordinate system. Defaults to 1.\n        perfect_sphere (bool): If True, assume a spherical Earth, else ellipsoidal (WGS-84).\n        semi_major (float, optional): Semi-major axis of the Earth ellipsoid in meters. Defaults to 6378137 (WGS 84).\n        semi_minor (float, optional): Semi-minor axis of the Earth ellipsoid in meters. Defaults to 6356752.314245 (WGS 84).\n\n    Returns:\n        coords (tuple[float, float, float]):\n\n            - lat (float): Latitude in degrees\n            - lon (float): Longitude in degrees\n            - alt (float): Altitude above ellipsoid in meters\n    \"\"\"\n    x = float(x)\n    y = float(y)\n    z = float(z)\n\n    # Undo scaling\n    R = (\n        (semi_major + (semi_major if perfect_sphere else semi_minor)) / 2\n    ) / target_radius\n    x = -x * R\n    y = -y * R\n    z = z * R\n\n    lon = math.atan2(y, x)\n\n    if perfect_sphere:\n        r = math.sqrt(x**2 + y**2 + z**2)\n        lat = math.asin(z / r)\n        alt = r - semi_major\n    else:\n        e2 = 1 - (semi_minor**2 / semi_major**2)\n        p = math.sqrt(x**2 + y**2)\n        # Initial guess\n        lat = math.atan2(z, p * (1 - e2))\n        # Iterative refienment\n        for _ in range(5):\n            N = semi_major / math.sqrt(1 - e2 * math.sin(lat) ** 2)\n            alt = p / math.cos(lat) - N\n            lat = math.atan2(z, p * (1 - e2 * (N / (N + alt))))\n        N = semi_major / math.sqrt(1 - e2 * math.sin(lat) ** 2)\n        alt = p / math.cos(lat) - N\n\n    return math.degrees(lat), math.degrees(lon), alt\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.geo_to_ecef","title":"geo_to_ecef","text":"<pre><code>geo_to_ecef(\n    lat,\n    lon,\n    alt=None,\n    target_radius=1.0,\n    perfect_sphere=True,\n    semi_major=SEMI_MAJOR_AXIS_METERS,\n    semi_minor=SEMI_MINOR_AXIS_METERS,\n)\n</code></pre> <p>Converts geodetic coordinates (i.e. latitude, longitude and altitude above ellipsoid) to Earth-centered, Earth-fixed (ECEF) coordinates (i.e. x, y and z in cartesian coordinates).</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude angle north (positive) and south (negative) of the equator in degrees.</p> required <code>lon</code> <code>float</code> <p>Longitude angle east (positive) and west (negative) of the prime meridian in degrees.</p> required <code>alt</code> <code>float</code> <p>Height above above the Earth ellipsoid in meters.</p> <code>None</code> <code>target_radius</code> <code>float</code> <p>Target mean radius of the Earth ellipsoid in the new cartesian coordinate system. Defaults to 1.</p> <code>1.0</code> <code>semi_major</code> <code>float</code> <p>Semi-major axis of the Earth ellipsoid in meters. Defaults to 6378137 (WGS 84).</p> <code>SEMI_MAJOR_AXIS_METERS</code> <code>semi_minor</code> <code>float</code> <p>Semi-minor axis of the Earth ellipsoid in meters. Defaults to 6356752.314245 (WGS 84).</p> <code>SEMI_MINOR_AXIS_METERS</code> <p>Returns:</p> Name Type Description <code>coords</code> <code>tuple[float, float, float]</code> <p>3D coordinates in meters (ECEF: A right-handed cartesian coordinate system that has its origin at the Earth's center and is fixed with respect to the Earth's rotation).</p> <ul> <li>x (float): Point along the axis passing through the equator at the prime meridian (i.e. latitude = 0, longitude = 0 degrees).</li> <li>y (float): Point along the axis passing through the equator 90 degrees east of the Prime Meridian (i.e. latitude = 0, longitude = 90 degrees).</li> <li>z (float): Point along the axis passing through the north pole (i.e. latitude = 90 degrees).</li> </ul> Source code in <code>earthcarekit/utils/geo/convertsions.py</code> <pre><code>def geo_to_ecef(\n    lat: SupportsFloat,\n    lon: SupportsFloat,\n    alt: SupportsFloat | None = None,\n    target_radius: float = 1.0,\n    perfect_sphere: bool = True,\n    semi_major: float = SEMI_MAJOR_AXIS_METERS,\n    semi_minor: float = SEMI_MINOR_AXIS_METERS,\n) -&gt; tuple[float, float, float]:\n    \"\"\"\n    Converts geodetic coordinates (i.e. latitude, longitude and altitude above ellipsoid)\n    to Earth-centered, Earth-fixed (ECEF) coordinates (i.e. x, y and z in cartesian coordinates).\n\n    Args:\n        lat (float): Latitude angle north (positive) and south (negative) of the equator in degrees.\n        lon (float): Longitude angle east (positive) and west (negative) of the prime meridian in degrees.\n        alt (float, optional): Height above above the Earth ellipsoid in meters.\n        target_radius (float, optional): Target mean radius of the Earth ellipsoid in the new cartesian coordinate system. Defaults to 1.\n        semi_major (float, optional): Semi-major axis of the Earth ellipsoid in meters. Defaults to 6378137 (WGS 84).\n        semi_minor (float, optional): Semi-minor axis of the Earth ellipsoid in meters. Defaults to 6356752.314245 (WGS 84).\n\n    Returns:\n        coords (tuple[float, float, float]): 3D coordinates in meters (ECEF: A right-handed cartesian coordinate system that has its origin at the Earth's center and is fixed with respect to the Earth's rotation).\n\n            - x (float): Point along the axis passing through the equator at the prime meridian (i.e. latitude = 0, longitude = 0 degrees).\n            - y (float): Point along the axis passing through the equator 90 degrees east of the Prime Meridian (i.e. latitude = 0, longitude = 90 degrees).\n            - z (float): Point along the axis passing through the north pole (i.e. latitude = 90 degrees).\n    \"\"\"\n    lat = float(lat)\n    lon = float(lon)\n    if alt is None:\n        alt = 0.0\n    else:\n        alt = float(alt)\n\n    sin = lambda x: math.sin(x)\n    cos = lambda x: math.cos(x)\n    sqrt = lambda x: math.sqrt(x)\n\n    lat = math.radians(lat)\n    lon = math.radians(lon)\n\n    if perfect_sphere:\n        # Calculate ECEF coordinates\n        f = 1 - (semi_major / semi_major)  # Flattening of the ellipsoid\n        N = semi_major / sqrt(\n            1 - (f * sin(lat)) ** 2\n        )  # Prime vertical radius of curvature\n\n        x = (N + alt) * cos(lat) * cos(lon)\n        y = (N + alt) * cos(lat) * sin(lon)\n        z = ((semi_major**2 / semi_major**2) * N + alt) * sin(lat)\n\n        # # Alternative\n        # e2 = 1 - (semi_minor**2 / semi_major**2) # Square of the first numerical eccentricity of the ellipsoid\n        # N = semi_major / sqrt(1 - e2 * (sin(lat) ** 2)) # Prime vertical radius of curvature\n\n        # Scale ECEF coordinates to target radius\n        R = ((semi_major + semi_major) / 2) / target_radius\n        x = -x / R\n        y = -y / R\n        z = z / R\n    else:\n        # Calculate ECEF coordinates\n        f = 1 - (semi_minor / semi_major)  # Flattening of the ellipsoid\n        N = semi_major / sqrt(\n            1 - (f * sin(lat)) ** 2\n        )  # Prime vertical radius of curvature\n\n        x = (N + alt) * cos(lat) * cos(lon)\n        y = (N + alt) * cos(lat) * sin(lon)\n        z = ((semi_minor**2 / semi_major**2) * N + alt) * sin(lat)\n\n        # # Alternative\n        # e2 = 1 - (semi_minor**2 / semi_major**2) # Square of the first numerical eccentricity of the ellipsoid\n        # N = semi_major / sqrt(1 - e2 * (sin(lat) ** 2)) # Prime vertical radius of curvature\n\n        # Scale ECEF coordinates to target radius\n        R = ((semi_major + semi_minor) / 2) / target_radius\n        x = -x / R\n        y = -y / R\n        z = z / R\n\n    return x, y, z\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.geodesic","title":"geodesic","text":"<pre><code>geodesic(\n    a, b, units=\"km\", tolerance=1e-12, max_iterations=10\n)\n</code></pre> <p>Calculates the geodesic distances between points on Earth (i.e. WSG 84 ellipsoid) using Vincenty's inverse method.</p> <p>Supports single or sequences of coordiates.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ArrayLike</code> <p>Coordinates [lat, lon] or array of shape (N, 2), in decimal degrees.</p> required <code>b</code> <code>ArrayLike</code> <p>Second coordinates, same format/shape as <code>a</code>.</p> required <code>units</code> <code>str</code> <p>Output units, \"km\" (default) or \"m\".</p> <code>'km'</code> <code>tolerance</code> <code>float</code> <p>Convergence threshold in radians. Default is 1e-12.</p> <code>1e-12</code> <code>max_iterations</code> <code>int</code> <p>Maximum iterations before failure. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>float64 | NDArray[float64]</code> <p>float or np.ndarray: The geodesic distance or distances between the point in <code>a</code> and <code>b</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input shapes are incompatible or units are invalid.</p> Note <p>Uses WGS84 (a=6378137.0 m, f=1/298.257223563). May fail for nearly antipodal points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geodesic([51.352757, 12.43392], [38.559, 68.856])\n4548.675334434374\n&gt;&gt;&gt; geodesic([0,0], [[0,0], [10,0], [20,0]])\narray([   0.        , 1105.85483324, 2212.36625417])\n&gt;&gt;&gt; geodesic([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\narray([0., 0., 0.])\n</code></pre> References <p>Vincenty, T. (1975). \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations.\" Survey Review, 23(176), 88-93. https://doi.org/10.1179/sre.1975.23.176.88</p> Source code in <code>earthcarekit/utils/geo/distance/_vincenty.py</code> <pre><code>def vincenty(\n    a: ArrayLike,\n    b: ArrayLike,\n    units: str = \"km\",\n    tolerance: float = 1e-12,\n    max_iterations: int = 10,\n) -&gt; np.float64 | NDArray[np.float64]:\n    \"\"\"\n    Calculates the geodesic distances between points on Earth (i.e. WSG 84 ellipsoid) using Vincenty's inverse method.\n\n    Supports single or sequences of coordiates.\n\n    Args:\n        a (ArrayLike): Coordinates [lat, lon] or array of shape (N, 2), in decimal degrees.\n        b (ArrayLike): Second coordinates, same format/shape as `a`.\n        units (str, optional): Output units, \"km\" (default) or \"m\".\n        tolerance (float, optional): Convergence threshold in radians. Default is 1e-12.\n        max_iterations (int, optional): Maximum iterations before failure. Default is 10.\n\n    Returns:\n        float or np.ndarray: The geodesic distance or distances between the point in `a` and `b`.\n\n    Raises:\n        ValueError: If input shapes are incompatible or units are invalid.\n\n    Note:\n        Uses WGS84 (a=6378137.0 m, f=1/298.257223563). May fail for nearly antipodal points.\n\n    Examples:\n        &gt;&gt;&gt; geodesic([51.352757, 12.43392], [38.559, 68.856])\n        4548.675334434374\n        &gt;&gt;&gt; geodesic([0,0], [[0,0], [10,0], [20,0]])\n        array([   0.        , 1105.85483324, 2212.36625417])\n        &gt;&gt;&gt; geodesic([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\n        array([0., 0., 0.])\n\n    References:\n        Vincenty, T. (1975). \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application\n        of nested equations.\" Survey Review, 23(176), 88-93. https://doi.org/10.1179/sre.1975.23.176.88\n    \"\"\"\n    _a, _b = map(np.asarray, [a, b])\n    coord_a, coord_b = map(np.atleast_2d, [_a, _b])\n    coord_a, coord_b = map(np.radians, [coord_a, coord_b])\n\n    if (coord_a.shape[1] != 2) or (coord_b.shape[1] != 2):\n        raise ValueError(\n            f\"At least one passed array has a wrong shape (a={_a.shape}, b={_b.shape}). 1d arrays should be of length 2 (i.e. [lat, lon]) and 2d array should have the shape (n, 2).\"\n        )\n    if (coord_a.shape[0] &lt; 1) or (coord_b.shape[0] &lt; 1):\n        raise ValueError(\n            f\"At least one passed array contains no values (a={_a.shape}, b={_b.shape}).\"\n        )\n    if coord_a.shape[0] != coord_b.shape[0]:\n        if (coord_a.shape[0] != 1) and (coord_b.shape[0] != 1):\n            raise ValueError(\n                f\"The shapes of passed arrays dont match (a={_a.shape}, b={_b.shape}). Either both should contain the same number of coordinates or at least one of them should contain a single coordinate.\"\n            )\n\n    lat_1, lon_1 = coord_a[:, 0], coord_a[:, 1]\n    lat_2, lon_2 = coord_b[:, 0], coord_b[:, 1]\n\n    # WGS84 ellipsoid constants\n    a = 6378137.0  # semi-major axis (equatorial radius) in meters\n    f = 1 / 298.257223563  # flattening\n    b = (1 - f) * a  # semi-minor axis (polar radius) in meters\n\n    # Reduced latitudes\n    beta_1 = np.arctan((1 - f) * np.tan(lat_1))\n    beta_2 = np.arctan((1 - f) * np.tan(lat_2))\n\n    initial_lon_diff = lon_2 - lon_1\n\n    # Initialize variables for iterative solution\n    lon_diff = initial_lon_diff\n    sin_beta_1, cos_beta_1 = np.sin(beta_1), np.cos(beta_1)\n    sin_beta_2, cos_beta_2 = np.sin(beta_2), np.cos(beta_2)\n    # Track convergence for each point pair\n    converged = np.full_like(lat_1, False, dtype=bool)\n\n    for _ in range(max_iterations):\n        sin_lon_diff, cos_lon_diff = np.sin(lon_diff), np.cos(lon_diff)\n\n        sin_sigma = np.sqrt(\n            (cos_beta_2 * sin_lon_diff) ** 2\n            + (cos_beta_1 * sin_beta_2 - sin_beta_1 * cos_beta_2 * cos_lon_diff) ** 2\n        )\n        cos_sigma = (sin_beta_1 * sin_beta_2) + (cos_beta_1 * cos_beta_2 * cos_lon_diff)\n        sigma = np.arctan2(sin_sigma, cos_sigma)\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            sin_alpha = cos_beta_1 * cos_beta_2 * sin_lon_diff / sin_sigma\n        sin_alpha = np.nan_to_num(sin_alpha, nan=0.0)\n        cos2_alpha = 1 - sin_alpha**2\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            cos2_sigma_m = np.where(\n                cos2_alpha != 0.0,\n                cos_sigma - ((2 * sin_beta_1 * sin_beta_2) / cos2_alpha),\n                0.0,\n            )\n        cos2_sigma_m = np.nan_to_num(cos2_sigma_m, nan=0.0)\n\n        C = f / 16 * cos2_alpha * (4 + f * (4 - 3 * cos2_alpha))\n\n        previous_lon_diff = lon_diff\n        lon_diff = initial_lon_diff + (1 - C) * f * sin_alpha * (\n            sigma\n            + C\n            * sin_sigma\n            * (cos2_sigma_m + C * cos_sigma * (-1 + 2 * cos2_sigma_m**2))\n        )\n        converged = converged | (np.abs(lon_diff - previous_lon_diff) &lt; tolerance)\n        if np.all(converged):\n            break\n\n    u2 = cos2_alpha * (a**2 - b**2) / b**2\n    A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)))\n    B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)))\n\n    delta_sigma = (\n        B\n        * sin_sigma\n        * (\n            cos2_sigma_m\n            + B\n            / 4\n            * (\n                cos_sigma * (-1 + 2 * cos2_sigma_m**2)\n                - B\n                / 6\n                * cos2_sigma_m\n                * (-3 + 4 * sin_sigma**2)\n                * (-3 + 4 * cos2_sigma_m**2)\n            )\n        )\n    )\n\n    distance = b * A * (sigma - delta_sigma)\n\n    if units == \"km\":\n        distance = distance / 1000.0\n    elif units != \"m\":\n        raise ValueError(\n            f\"{vincenty.__name__}() Invalid units : {units}. Use 'm' or 'km' instead.\"\n        )\n\n    if len(_a.shape) == 1 and len(_b.shape) == 1:\n        return distance[0]\n\n    return distance\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.get_central_coords","title":"get_central_coords","text":"<pre><code>get_central_coords(latitude, longitude)\n</code></pre> <p>Calculates the central lat/lon coordinates.</p> Source code in <code>earthcarekit/utils/geo/coordinates.py</code> <pre><code>def get_central_coords(\n    latitude: ArrayLike,\n    longitude: ArrayLike,\n) -&gt; tuple[float, float]:\n    \"\"\"Calculates the central lat/lon coordinates.\"\"\"\n    from .convertsions import ecef_to_geo, geo_to_ecef\n\n    lats: NDArray = flatten_array(latitude)\n    lons: NDArray = flatten_array(longitude)\n\n    coords_ecef = np.array([geo_to_ecef(lat=lt, lon=ln) for lt, ln in zip(lats, lons)])\n    coords_ecef_min = np.nanmin(coords_ecef, axis=0)\n    coords_ecef_max = np.nanmax(coords_ecef, axis=0)\n    coords_ecef_central = (coords_ecef_min + coords_ecef_max) * 0.5\n    coords_geo_central = ecef_to_geo(\n        coords_ecef_central[0], coords_ecef_central[1], coords_ecef_central[2]\n    )\n    return (coords_geo_central[0], coords_geo_central[1])\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.get_central_latitude","title":"get_central_latitude","text":"<pre><code>get_central_latitude(latitude)\n</code></pre> <p>Calculates the central latitude coordinate.</p> Source code in <code>earthcarekit/utils/geo/coordinates.py</code> <pre><code>def get_central_latitude(\n    latitude: ArrayLike,\n) -&gt; float:\n    \"\"\"Calculates the central latitude coordinate.\"\"\"\n    lats: NDArray = flatten_array(latitude)\n    lons: NDArray = np.zeros(lats.shape)\n\n    central_coords = get_central_coords(lats, lons)\n\n    return central_coords[0]\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.get_central_longitude","title":"get_central_longitude","text":"<pre><code>get_central_longitude(longitude)\n</code></pre> <p>Calculates the central longitude coordinate.</p> Source code in <code>earthcarekit/utils/geo/coordinates.py</code> <pre><code>def get_central_longitude(\n    longitude: ArrayLike,\n) -&gt; float:\n    \"\"\"Calculates the central longitude coordinate.\"\"\"\n    lons: NDArray = flatten_array(longitude)\n    lats: NDArray = np.zeros(lons.shape)\n\n    central_coords = get_central_coords(lats, lons)\n\n    return central_coords[1]\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.get_coord_between","title":"get_coord_between","text":"<pre><code>get_coord_between(coord1, coord2, f=0.5)\n</code></pre> <p>Interpolates between two coordinates by fraction f (0 to 1).</p> <p>Parameters:</p> Name Type Description Default <code>coord1</code> <code>ArrayLike</code> <p>The first lat/lon point.</p> required <code>coord2</code> <code>ArrayLike</code> <p>The second lat/lon point.</p> required <code>f</code> <code>float</code> <p>A fractional value between 0 and 1. Defaults to 0.5, i.e., the mid point between coord1 and coord2.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>A 2-element <code>numpy.ndarray</code> representing the interpolated lat/lon point.</p> Source code in <code>earthcarekit/utils/geo/interpolate.py</code> <pre><code>def get_coord_between(\n    coord1: ArrayLike,\n    coord2: ArrayLike,\n    f: float = 0.5,\n) -&gt; NDArray:\n    \"\"\"\n    Interpolates between two coordinates by fraction f (0 to 1).\n\n    Args:\n        coord1 (ArrayLike): The first lat/lon point.\n        coord2 (ArrayLike): The second lat/lon point.\n        f (float): A fractional value between 0 and 1. Defaults to 0.5, i.e., the mid point between coord1 and coord2.\n\n    Returns:\n        NDArray: A 2-element `numpy.ndarray` representing the interpolated lat/lon point.\n    \"\"\"\n\n    coord1 = np.array(coord1)\n    coord2 = np.array(coord2)\n\n    if coord1.shape != (2,):\n        raise ValueError(f\"coord1 must be a 2-element sequence (lat, lon)\")\n\n    if coord2.shape != (2,):\n        raise ValueError(f\"coord2 must be a 2-element sequence (lat, lon)\")\n\n    lon, lat = interpgeo(\n        lat1=float(coord1[0]),\n        lon1=float(coord1[1]),\n        lat2=float(coord2[0]),\n        lon2=float(coord2[1]),\n        f=f,\n    )\n    return np.array([lat, lon])\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.get_coords","title":"get_coords","text":"<pre><code>get_coords(\n    ds,\n    *,\n    lat_var=TRACK_LAT_VAR,\n    lon_var=TRACK_LON_VAR,\n    flatten=False\n)\n</code></pre> <p>Takes a <code>xarray.Dataset</code> and returns the lat/lon coordinates as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>lat_var</code> <code>str</code> <p>Name of the latitude variable. Defaults to TRACK_LAT_VAR.</p> <code>TRACK_LAT_VAR</code> <code>lon_var</code> <code>str</code> <p>Name of the longitude variable. Defaults to TRACK_LON_VAR.</p> <code>TRACK_LON_VAR</code> <code>flatten</code> <code>bool</code> <p>If True, the coordinates will be flattened to a 2D array</p> <ul> <li>1st dimension: time</li> <li>2nd dimension: lat/lon</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>numpy.array: The extracted lat/lon coordinates.</p> Source code in <code>earthcarekit/utils/geo/coordinates.py</code> <pre><code>def get_coords(\n    ds: xr.Dataset,\n    *,\n    lat_var: str = TRACK_LAT_VAR,\n    lon_var: str = TRACK_LON_VAR,\n    flatten: bool = False,\n) -&gt; NDArray:\n    \"\"\"Takes a `xarray.Dataset` and returns the lat/lon coordinates as a numpy array.\n\n    Args:\n        lat_var (str, optional): Name of the latitude variable. Defaults to TRACK_LAT_VAR.\n        lon_var (str, optional): Name of the longitude variable. Defaults to TRACK_LON_VAR.\n        flatten (bool, optional):\n            If True, the coordinates will be flattened to a 2D array\n\n            - 1st dimension: time\n            - 2nd dimension: lat/lon\n\n    Returns:\n        numpy.array: The extracted lat/lon coordinates.\n    \"\"\"\n    lat = ds[lat_var].values\n    lon = ds[lon_var].values\n    coords = np.stack((lat, lon)).transpose()\n\n    if len(coords.shape) &gt; 2 and flatten:\n        coords = coords.reshape(-1, 2)\n    return coords\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.haversine","title":"haversine","text":"<pre><code>haversine(\n    a, b, units=\"km\", radius_m=MEAN_EARTH_RADIUS_METERS\n)\n</code></pre> <p>Calculates the great-circle (spherical) distance between pairs of latitude/longitude coordinates using the haversine formula.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ArrayLike</code> <p>An array-like object of shape (..., 2) containing latitude and longitude coordinates in degrees. The last dimension must be 2: (lat, lon).</p> required <code>b</code> <code>ArrayLike</code> <p>An array-like object of the same shape as <code>a</code>, containing corresponding latitude and longitude coordinates.</p> required <code>units</code> <code>Literal['m', 'km']</code> <p>Unit of the output distance. Must be either \"km\" for kilometers or \"m\" for meters. Defaults to \"km\".</p> <code>'km'</code> <code>radius</code> <code>float</code> <p>Radius of the sphere to use for distance calculation. Defaults to MEAN_EARTH_RADIUS_METERS (based on WSG 84 ellipsoid: ~6371008.77 meters). Note: If <code>units=\"km\"</code>, this value is automatically converted to kilometers.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Array of great-circle distances between <code>a</code> and <code>b</code>, in the specified units. The shape matches the input shape excluding the last dimension.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shapes of <code>a</code> and <code>b</code> are incompatible or <code>units</code> is not one of \"m\" or \"km\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; haversine([51.352757, 12.43392], [38.559, 68.856])\n4537.564747442274\n&gt;&gt;&gt; haversine([0,0], [[0,0], [10,0], [20,0]])\narray([   0.        , 1111.95079735, 2223.90159469])\n&gt;&gt;&gt; haversine([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\narray([0., 0., 0.])\n</code></pre> Source code in <code>earthcarekit/utils/geo/distance/_haversine.py</code> <pre><code>def haversine(\n    a: ArrayLike,\n    b: ArrayLike,\n    units: Literal[\"m\", \"km\"] = \"km\",\n    radius_m: float = MEAN_EARTH_RADIUS_METERS,\n):\n    \"\"\"\n    Calculates the great-circle (spherical) distance between pairs of latitude/longitude coordinates\n    using the haversine formula.\n\n    Args:\n        a (ArrayLike): An array-like object of shape (..., 2) containing latitude and longitude\n            coordinates in degrees. The last dimension must be 2: (lat, lon).\n        b (ArrayLike): An array-like object of the same shape as `a`, containing corresponding\n            latitude and longitude coordinates.\n        units (Literal[\"m\", \"km\"], optional): Unit of the output distance. Must be either\n            \"km\" for kilometers or \"m\" for meters. Defaults to \"km\".\n        radius (float, optional): Radius of the sphere to use for distance calculation.\n            Defaults to MEAN_EARTH_RADIUS_METERS (based on WSG 84 ellipsoid: ~6371008.77 meters).\n            Note: If `units=\"km\"`, this value is automatically converted to kilometers.\n\n    Returns:\n        np.ndarray: Array of great-circle distances between `a` and `b`, in the specified units.\n            The shape matches the input shape excluding the last dimension.\n\n    Raises:\n        ValueError: If the shapes of `a` and `b` are incompatible or `units` is not one of \"m\" or \"km\".\n\n    Examples:\n        &gt;&gt;&gt; haversine([51.352757, 12.43392], [38.559, 68.856])\n        4537.564747442274\n        &gt;&gt;&gt; haversine([0,0], [[0,0], [10,0], [20,0]])\n        array([   0.        , 1111.95079735, 2223.90159469])\n        &gt;&gt;&gt; haversine([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\n        array([0., 0., 0.])\n    \"\"\"\n\n    if units not in [\"m\", \"km\"]:\n        raise ValueError(\n            f\"{haversine.__name__}() Invalid units : {units}. Use 'm' or 'km' instead.\"\n        )\n\n    radius: float = radius_m\n    if units == \"km\":\n        radius = radius / 1000.0\n\n    a = np.array(a)\n    b = np.array(b)\n\n    coord_a = np.atleast_2d(a)\n    coord_b = np.atleast_2d(b)\n\n    if (coord_a.shape[1] != 2) or (coord_b.shape[1] != 2):\n        raise ValueError(\n            f\"At least one passed array has a wrong shape (a={a.shape}, b={b.shape}). 1d arrays should be of length 2 (i.e. [lat, lon]) and 2d array should have the shape (n, 2).\"\n        )\n    if (coord_a.shape[0] &lt; 1) or (coord_b.shape[0] &lt; 1):\n        raise ValueError(\n            f\"At least one passed array contains no values (a={a.shape}, b={b.shape}).\"\n        )\n    if coord_a.shape[0] != coord_b.shape[0]:\n        if (coord_a.shape[0] != 1) and (coord_b.shape[0] != 1):\n            raise ValueError(\n                f\"The shapes of passed arrays dont match (a={a.shape}, b={b.shape}). Either both should contain the same number of coordinates or at least one of them should contain a single coordinate.\"\n            )\n\n    coord_a = np.radians(coord_a)\n    coord_b = np.radians(coord_b)\n\n    phi_1, lambda_1 = coord_a[:, 0], coord_a[:, 1]\n    phi_2, lambda_2 = coord_b[:, 0], coord_b[:, 1]\n\n    hav = lambda theta: (1 - np.cos(theta)) / 2\n\n    h = hav(phi_2 - phi_1) + np.cos(phi_1) * np.cos(phi_2) * hav(lambda_2 - lambda_1)\n\n    d = 2 * radius * np.arcsin(np.sqrt(h))\n\n    if len(a.shape) == 1 and len(b.shape) == 1:\n        return d[0]\n\n    return d\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.interpgeo","title":"interpgeo","text":"<pre><code>interpgeo(lat1, lon1, lat2, lon2, f)\n</code></pre> <p>Interpolates along the geodesic from (lon1, lat1) to (lon2, lat2) by fraction f (0 to 1) and returns interpolated (lon, lat).</p> Source code in <code>earthcarekit/utils/geo/interpolate.py</code> <pre><code>def interpgeo(\n    lat1: float,\n    lon1: float,\n    lat2: float,\n    lon2: float,\n    f: float,\n) -&gt; tuple[float, float]:\n    \"\"\"\n    Interpolates along the geodesic from (lon1, lat1) to (lon2, lat2) by fraction f (0 to 1) and returns interpolated (lon, lat).\n    \"\"\"\n    azi1, azi2, dist = _GEOD.inv(lon1, lat1, lon2, lat2)\n    lon, lat, _ = _GEOD.fwd(lon1, lat1, azi1, f * dist)\n    return lon, lat\n</code></pre>"},{"location":"api_ref/geo/#earthcarekit.geo.vincenty","title":"vincenty","text":"<pre><code>vincenty(\n    a, b, units=\"km\", tolerance=1e-12, max_iterations=10\n)\n</code></pre> <p>Calculates the geodesic distances between points on Earth (i.e. WSG 84 ellipsoid) using Vincenty's inverse method.</p> <p>Supports single or sequences of coordiates.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ArrayLike</code> <p>Coordinates [lat, lon] or array of shape (N, 2), in decimal degrees.</p> required <code>b</code> <code>ArrayLike</code> <p>Second coordinates, same format/shape as <code>a</code>.</p> required <code>units</code> <code>str</code> <p>Output units, \"km\" (default) or \"m\".</p> <code>'km'</code> <code>tolerance</code> <code>float</code> <p>Convergence threshold in radians. Default is 1e-12.</p> <code>1e-12</code> <code>max_iterations</code> <code>int</code> <p>Maximum iterations before failure. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>float64 | NDArray[float64]</code> <p>float or np.ndarray: The geodesic distance or distances between the point in <code>a</code> and <code>b</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input shapes are incompatible or units are invalid.</p> Note <p>Uses WGS84 (a=6378137.0 m, f=1/298.257223563). May fail for nearly antipodal points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geodesic([51.352757, 12.43392], [38.559, 68.856])\n4548.675334434374\n&gt;&gt;&gt; geodesic([0,0], [[0,0], [10,0], [20,0]])\narray([   0.        , 1105.85483324, 2212.36625417])\n&gt;&gt;&gt; geodesic([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\narray([0., 0., 0.])\n</code></pre> References <p>Vincenty, T. (1975). \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations.\" Survey Review, 23(176), 88-93. https://doi.org/10.1179/sre.1975.23.176.88</p> Source code in <code>earthcarekit/utils/geo/distance/_vincenty.py</code> <pre><code>def vincenty(\n    a: ArrayLike,\n    b: ArrayLike,\n    units: str = \"km\",\n    tolerance: float = 1e-12,\n    max_iterations: int = 10,\n) -&gt; np.float64 | NDArray[np.float64]:\n    \"\"\"\n    Calculates the geodesic distances between points on Earth (i.e. WSG 84 ellipsoid) using Vincenty's inverse method.\n\n    Supports single or sequences of coordiates.\n\n    Args:\n        a (ArrayLike): Coordinates [lat, lon] or array of shape (N, 2), in decimal degrees.\n        b (ArrayLike): Second coordinates, same format/shape as `a`.\n        units (str, optional): Output units, \"km\" (default) or \"m\".\n        tolerance (float, optional): Convergence threshold in radians. Default is 1e-12.\n        max_iterations (int, optional): Maximum iterations before failure. Default is 10.\n\n    Returns:\n        float or np.ndarray: The geodesic distance or distances between the point in `a` and `b`.\n\n    Raises:\n        ValueError: If input shapes are incompatible or units are invalid.\n\n    Note:\n        Uses WGS84 (a=6378137.0 m, f=1/298.257223563). May fail for nearly antipodal points.\n\n    Examples:\n        &gt;&gt;&gt; geodesic([51.352757, 12.43392], [38.559, 68.856])\n        4548.675334434374\n        &gt;&gt;&gt; geodesic([0,0], [[0,0], [10,0], [20,0]])\n        array([   0.        , 1105.85483324, 2212.36625417])\n        &gt;&gt;&gt; geodesic([[0,0], [10,0], [20,0]], [[0,0], [10,0], [20,0]])\n        array([0., 0., 0.])\n\n    References:\n        Vincenty, T. (1975). \"Direct and Inverse Solutions of Geodesics on the Ellipsoid with application\n        of nested equations.\" Survey Review, 23(176), 88-93. https://doi.org/10.1179/sre.1975.23.176.88\n    \"\"\"\n    _a, _b = map(np.asarray, [a, b])\n    coord_a, coord_b = map(np.atleast_2d, [_a, _b])\n    coord_a, coord_b = map(np.radians, [coord_a, coord_b])\n\n    if (coord_a.shape[1] != 2) or (coord_b.shape[1] != 2):\n        raise ValueError(\n            f\"At least one passed array has a wrong shape (a={_a.shape}, b={_b.shape}). 1d arrays should be of length 2 (i.e. [lat, lon]) and 2d array should have the shape (n, 2).\"\n        )\n    if (coord_a.shape[0] &lt; 1) or (coord_b.shape[0] &lt; 1):\n        raise ValueError(\n            f\"At least one passed array contains no values (a={_a.shape}, b={_b.shape}).\"\n        )\n    if coord_a.shape[0] != coord_b.shape[0]:\n        if (coord_a.shape[0] != 1) and (coord_b.shape[0] != 1):\n            raise ValueError(\n                f\"The shapes of passed arrays dont match (a={_a.shape}, b={_b.shape}). Either both should contain the same number of coordinates or at least one of them should contain a single coordinate.\"\n            )\n\n    lat_1, lon_1 = coord_a[:, 0], coord_a[:, 1]\n    lat_2, lon_2 = coord_b[:, 0], coord_b[:, 1]\n\n    # WGS84 ellipsoid constants\n    a = 6378137.0  # semi-major axis (equatorial radius) in meters\n    f = 1 / 298.257223563  # flattening\n    b = (1 - f) * a  # semi-minor axis (polar radius) in meters\n\n    # Reduced latitudes\n    beta_1 = np.arctan((1 - f) * np.tan(lat_1))\n    beta_2 = np.arctan((1 - f) * np.tan(lat_2))\n\n    initial_lon_diff = lon_2 - lon_1\n\n    # Initialize variables for iterative solution\n    lon_diff = initial_lon_diff\n    sin_beta_1, cos_beta_1 = np.sin(beta_1), np.cos(beta_1)\n    sin_beta_2, cos_beta_2 = np.sin(beta_2), np.cos(beta_2)\n    # Track convergence for each point pair\n    converged = np.full_like(lat_1, False, dtype=bool)\n\n    for _ in range(max_iterations):\n        sin_lon_diff, cos_lon_diff = np.sin(lon_diff), np.cos(lon_diff)\n\n        sin_sigma = np.sqrt(\n            (cos_beta_2 * sin_lon_diff) ** 2\n            + (cos_beta_1 * sin_beta_2 - sin_beta_1 * cos_beta_2 * cos_lon_diff) ** 2\n        )\n        cos_sigma = (sin_beta_1 * sin_beta_2) + (cos_beta_1 * cos_beta_2 * cos_lon_diff)\n        sigma = np.arctan2(sin_sigma, cos_sigma)\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            sin_alpha = cos_beta_1 * cos_beta_2 * sin_lon_diff / sin_sigma\n        sin_alpha = np.nan_to_num(sin_alpha, nan=0.0)\n        cos2_alpha = 1 - sin_alpha**2\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\")\n            cos2_sigma_m = np.where(\n                cos2_alpha != 0.0,\n                cos_sigma - ((2 * sin_beta_1 * sin_beta_2) / cos2_alpha),\n                0.0,\n            )\n        cos2_sigma_m = np.nan_to_num(cos2_sigma_m, nan=0.0)\n\n        C = f / 16 * cos2_alpha * (4 + f * (4 - 3 * cos2_alpha))\n\n        previous_lon_diff = lon_diff\n        lon_diff = initial_lon_diff + (1 - C) * f * sin_alpha * (\n            sigma\n            + C\n            * sin_sigma\n            * (cos2_sigma_m + C * cos_sigma * (-1 + 2 * cos2_sigma_m**2))\n        )\n        converged = converged | (np.abs(lon_diff - previous_lon_diff) &lt; tolerance)\n        if np.all(converged):\n            break\n\n    u2 = cos2_alpha * (a**2 - b**2) / b**2\n    A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)))\n    B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)))\n\n    delta_sigma = (\n        B\n        * sin_sigma\n        * (\n            cos2_sigma_m\n            + B\n            / 4\n            * (\n                cos_sigma * (-1 + 2 * cos2_sigma_m**2)\n                - B\n                / 6\n                * cos2_sigma_m\n                * (-3 + 4 * sin_sigma**2)\n                * (-3 + 4 * cos2_sigma_m**2)\n            )\n        )\n    )\n\n    distance = b * A * (sigma - delta_sigma)\n\n    if units == \"km\":\n        distance = distance / 1000.0\n    elif units != \"m\":\n        raise ValueError(\n            f\"{vincenty.__name__}() Invalid units : {units}. Use 'm' or 'km' instead.\"\n        )\n\n    if len(_a.shape) == 1 and len(_b.shape) == 1:\n        return distance[0]\n\n    return distance\n</code></pre>"},{"location":"api_ref/read/","title":"earthcarekit.read","text":""},{"location":"api_ref/read/#api-reference","title":"API reference","text":"<p>earthcarekit.read</p> <p>Reading utilities for EarthCARE product data.</p>"},{"location":"api_ref/read/#earthcarekit.read.FileAgency","title":"FileAgency","text":"<p>               Bases: <code>FileInfoEnum</code></p> Source code in <code>earthcarekit/utils/read/product/file_info/agency.py</code> <pre><code>class FileAgency(FileInfoEnum):\n    ESA = \"E\"\n    JAXA = \"J\"\n\n    @classmethod\n    def from_input(cls, input: str | xr.Dataset) -&gt; \"FileAgency\":\n        \"\"\"Infers the EarthCARE product agency (i.e. ESA or JAXA) from a given file or dataset.\"\"\"\n        if isinstance(input, str):\n            try:\n                return cls[input.upper()]\n            except AttributeError:\n                pass\n            except KeyError:\n                pass\n            try:\n                return cls(input.upper())\n            except ValueError:\n                pass\n\n        return get_file_agency(input)\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.FileAgency.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(input)\n</code></pre> <p>Infers the EarthCARE product agency (i.e. ESA or JAXA) from a given file or dataset.</p> Source code in <code>earthcarekit/utils/read/product/file_info/agency.py</code> <pre><code>@classmethod\ndef from_input(cls, input: str | xr.Dataset) -&gt; \"FileAgency\":\n    \"\"\"Infers the EarthCARE product agency (i.e. ESA or JAXA) from a given file or dataset.\"\"\"\n    if isinstance(input, str):\n        try:\n            return cls[input.upper()]\n        except AttributeError:\n            pass\n        except KeyError:\n            pass\n        try:\n            return cls(input.upper())\n        except ValueError:\n            pass\n\n    return get_file_agency(input)\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.FileLatency","title":"FileLatency","text":"<p>               Bases: <code>FileInfoEnum</code></p> Source code in <code>earthcarekit/utils/read/product/file_info/latency.py</code> <pre><code>class FileLatency(FileInfoEnum):\n    NEAR_REAL_TIME = \"N\"\n    OFFLINE = \"O\"\n    NOT_APPLICABLE = \"X\"\n\n    @classmethod\n    def from_input(cls, input: str | xr.Dataset) -&gt; \"FileLatency\":\n        \"\"\"Infers the EarthCARE product latency indicator (i.e. N for Near-real time, O for Offline, X for not applicable) from a given name, file or dataset.\"\"\"\n        if isinstance(input, str):\n            try:\n                return cls[input.upper()]\n            except AttributeError:\n                pass\n            except KeyError:\n                pass\n            try:\n                return cls(input.upper())\n            except ValueError:\n                pass\n\n        return get_file_latency(input)\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.FileLatency.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(input)\n</code></pre> <p>Infers the EarthCARE product latency indicator (i.e. N for Near-real time, O for Offline, X for not applicable) from a given name, file or dataset.</p> Source code in <code>earthcarekit/utils/read/product/file_info/latency.py</code> <pre><code>@classmethod\ndef from_input(cls, input: str | xr.Dataset) -&gt; \"FileLatency\":\n    \"\"\"Infers the EarthCARE product latency indicator (i.e. N for Near-real time, O for Offline, X for not applicable) from a given name, file or dataset.\"\"\"\n    if isinstance(input, str):\n        try:\n            return cls[input.upper()]\n        except AttributeError:\n            pass\n        except KeyError:\n            pass\n        try:\n            return cls(input.upper())\n        except ValueError:\n            pass\n\n    return get_file_latency(input)\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.FileType","title":"FileType","text":"<p>               Bases: <code>FileInfoEnum</code></p> Source code in <code>earthcarekit/utils/read/product/file_info/type.py</code> <pre><code>class FileType(FileInfoEnum):\n    # Level 1\n    ATL_NOM_1B = \"ATL_NOM_1B\"\n    ATL_DCC_1B = \"ATL_DCC_1B\"\n    ATL_CSC_1B = \"ATL_CSC_1B\"\n    ATL_FSC_1B = \"ATL_FSC_1B\"\n    MSI_NOM_1B = \"MSI_NOM_1B\"\n    MSI_BBS_1B = \"MSI_BBS_1B\"\n    MSI_SD1_1B = \"MSI_SD1_1B\"\n    MSI_SD2_1B = \"MSI_SD2_1B\"\n    MSI_RGR_1C = \"MSI_RGR_1C\"\n    BBR_NOM_1B = \"BBR_NOM_1B\"\n    BBR_SNG_1B = \"BBR_SNG_1B\"\n    BBR_SOL_1B = \"BBR_SOL_1B\"\n    BBR_LIN_1B = \"BBR_LIN_1B\"\n    CPR_NOM_1B = \"CPR_NOM_1B\"  # JAXA product\n    # Level 2a\n    ATL_FM__2A = \"ATL_FM__2A\"\n    ATL_AER_2A = \"ATL_AER_2A\"\n    ATL_ICE_2A = \"ATL_ICE_2A\"\n    ATL_TC__2A = \"ATL_TC__2A\"\n    ATL_EBD_2A = \"ATL_EBD_2A\"\n    ATL_CTH_2A = \"ATL_CTH_2A\"\n    ATL_ALD_2A = \"ATL_ALD_2A\"\n    MSI_CM__2A = \"MSI_CM__2A\"\n    MSI_COP_2A = \"MSI_COP_2A\"\n    MSI_AOT_2A = \"MSI_AOT_2A\"\n    CPR_FMR_2A = \"CPR_FMR_2A\"\n    CPR_CD__2A = \"CPR_CD__2A\"\n    CPR_TC__2A = \"CPR_TC__2A\"\n    CPR_CLD_2A = \"CPR_CLD_2A\"\n    CPR_APC_2A = \"CPR_APC_2A\"\n    ATL_CLA_2A = \"ATL_CLA_2A\"  # JAXA product\n    MSI_CLP_2A = \"MSI_CLP_2A\"  # JAXA product\n    CPR_ECO_2A = \"CPR_ECO_2A\"  # JAXA product\n    CPR_CLP_2A = \"CPR_CLP_2A\"  # JAXA product\n    # Level 2b\n    AM__MO__2B = \"AM__MO__2B\"\n    AM__CTH_2B = \"AM__CTH_2B\"\n    AM__ACD_2B = \"AM__ACD_2B\"\n    AC__TC__2B = \"AC__TC__2B\"\n    BM__RAD_2B = \"BM__RAD_2B\"\n    BMA_FLX_2B = \"BMA_FLX_2B\"\n    ACM_CAP_2B = \"ACM_CAP_2B\"\n    ACM_COM_2B = \"ACM_COM_2B\"\n    ACM_RT__2B = \"ACM_RT__2B\"\n    ALL_DF__2B = \"ALL_DF__2B\"\n    ALL_3D__2B = \"ALL_3D__2B\"\n    AC__CLP_2B = \"AC__CLP_2B\"  # JAXA product\n    ACM_CLP_2B = \"ACM_CLP_2B\"  # JAXA product\n    ALL_RAD_2B = \"ALL_RAD_2B\"  # JAXA product\n    # Auxiliary data\n    AUX_MET_1D = \"AUX_MET_1D\"\n    AUX_JSG_1D = \"AUX_JSG_1D\"\n    # Orbit data\n    MPL_ORBSCT = \"MPL_ORBSCT\"\n    AUX_ORBPRE = \"AUX_ORBPRE\"\n    AUX_ORBRES = \"AUX_ORBRES\"\n\n    @classmethod\n    def from_input(cls, input: str | xr.Dataset) -&gt; \"FileType\":\n        \"\"\"Infers the EarthCARE product type from a given file or dataset.\"\"\"\n        if isinstance(input, str):\n            try:\n                return cls[format_file_type_string(input)]\n            except AttributeError:\n                pass\n            except KeyError:\n                pass\n            try:\n                return cls(format_file_type_string(input))\n            except ValueError:\n                pass\n            except KeyError:\n                pass\n\n        return get_file_type(input)\n\n    @classmethod\n    def list(cls):\n        return list(map(lambda c: c.value, cls))\n\n    def to_shorthand(self, with_dash: bool = False):\n        if with_dash:\n            return _short_hand_map[self.value]\n        else:\n            return _short_hand_map[self.value].replace(\"-\", \"\")\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.FileType.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(input)\n</code></pre> <p>Infers the EarthCARE product type from a given file or dataset.</p> Source code in <code>earthcarekit/utils/read/product/file_info/type.py</code> <pre><code>@classmethod\ndef from_input(cls, input: str | xr.Dataset) -&gt; \"FileType\":\n    \"\"\"Infers the EarthCARE product type from a given file or dataset.\"\"\"\n    if isinstance(input, str):\n        try:\n            return cls[format_file_type_string(input)]\n        except AttributeError:\n            pass\n        except KeyError:\n            pass\n        try:\n            return cls(format_file_type_string(input))\n        except ValueError:\n            pass\n        except KeyError:\n            pass\n\n    return get_file_type(input)\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.ProductInfo","title":"ProductInfo  <code>dataclass</code>","text":"<p>Class storing all info gathered from a EarthCARE product's file path.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>@dataclass\nclass ProductInfo:\n    \"\"\"Class storing all info gathered from a EarthCARE product's file path.\"\"\"\n\n    mission_id: FileMissionID\n    agency: FileAgency\n    latency: FileLatency\n    baseline: str\n    file_type: FileType\n    start_sensing_time: pd.Timestamp\n    start_processing_time: pd.Timestamp\n    orbit_number: int\n    frame_id: str\n    orbit_and_frame: str\n    name: str\n    filepath: str\n    hdr_filepath: str\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns data stored in `ProductInfo` as a `dict`.\"\"\"\n        return asdict(self)\n\n    def to_dataframe(self) -&gt; \"ProductDataFrame\":\n        return ProductDataFrame([self])\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.ProductInfo.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Returns data stored in <code>ProductInfo</code> as a <code>dict</code>.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns data stored in `ProductInfo` as a `dict`.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.add_depol_ratio","title":"add_depol_ratio","text":"<pre><code>add_depol_ratio(\n    ds_anom,\n    rolling_w=20,\n    near_zero_tolerance=2e-07,\n    smooth=True,\n    skip_height_above_elevation=300,\n    depol_ratio_var=\"depol_ratio\",\n    cpol_cleaned_var=\"cpol_cleaned_for_depol_calculation\",\n    xpol_cleaned_var=\"xpol_cleaned_for_depol_calculation\",\n    depol_ratio_from_means_var=\"depol_ratio_from_means\",\n    cpol_var=\"mie_attenuated_backscatter\",\n    xpol_var=\"crosspolar_attenuated_backscatter\",\n    elevation_var=ELEVATION_VAR,\n    height_var=HEIGHT_VAR,\n    height_dim=VERTICAL_DIM,\n)\n</code></pre> <p>Compute depolarization ratio (<code>DPOL</code> = <code>XPOL</code>/<code>CPOL</code>) from attenuated backscatter signals.</p> <p>This function derives the depolarization ratio from cross-polarized (<code>XPOL</code>) and co-polarized (<code>CPOL</code>) attenuated backscatter signals. Signals below the surface are masked, by default with a vertical margin on 300 meters above elevation to remove potencial surface retrun. Also, signals are smoothed (or \"cleaned\") with a rolling mean, and near-zero divisions are suppressed. Cleaned <code>CPOL</code> and <code>XPOL</code> signals are stored alongside <code>DPOL</code>, and a secondary single depol. profile calculated from mean profiles is added (i.e., mean(<code>XPOL</code>)/mean(<code>CPOL</code>)).</p> <p>Parameters:</p> Name Type Description Default <code>ds_anom</code> <code>Dataset</code> <p>ATL_NOM_1B dataset containing cross- and co-polar attenuated backscatter.</p> required <code>rolling_w</code> <code>int</code> <p>Window size for rolling mean smoothing. Defaults to 20.</p> <code>20</code> <code>near_zero_tolerance</code> <code>float</code> <p>Tolerance for masking near-zero <code>CPOL</code> (i.e., denominators). Defaults to 2e-7.</p> <code>2e-07</code> <code>smooth</code> <code>bool</code> <p>Whether to apply rolling mean smoothing. Defaults to True.</p> <code>True</code> <code>skip_height_above_elevation</code> <code>int</code> <p>Vertical margin above surface elevation to mask in meters. Defaults to 300.</p> <code>300</code> <code>depol_ratio_var</code> <code>str</code> <p>Name for depol. ratio variable. Defaults to \"depol_ratio\".</p> <code>'depol_ratio'</code> <code>cpol_cleaned_var</code> <code>str</code> <p>Name for cleaned co-polar variable. Defaults to \"cpol_cleaned_for_depol_calculation\".</p> <code>'cpol_cleaned_for_depol_calculation'</code> <code>xpol_cleaned_var</code> <code>str</code> <p>Name for cleaned cross-polar variable. Defaults to \"xpol_cleaned_for_depol_calculation\".</p> <code>'xpol_cleaned_for_depol_calculation'</code> <code>depol_ratio_from_means_var</code> <code>str</code> <p>Name for ratio from mean profiles. Defaults to \"depol_ratio_from_means\".</p> <code>'depol_ratio_from_means'</code> <code>cpol_var</code> <code>str</code> <p>Input co-polar variable name. Defaults to \"mie_attenuated_backscatter\".</p> <code>'mie_attenuated_backscatter'</code> <code>xpol_var</code> <code>str</code> <p>Input cross-polar variable name. Defaults to \"crosspolar_attenuated_backscatter\".</p> <code>'crosspolar_attenuated_backscatter'</code> <code>elevation_var</code> <code>str</code> <p>Elevation variable name. Defaults to ELEVATION_VAR.</p> <code>ELEVATION_VAR</code> <code>height_var</code> <code>str</code> <p>Height variable name. Defaults to HEIGHT_VAR.</p> <code>HEIGHT_VAR</code> <code>height_dim</code> <code>str</code> <p>Height dimension name. Defaults to VERTICAL_DIM.</p> <code>VERTICAL_DIM</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset with added depol. ratio, cleaned <code>CPOL</code>/<code>XPOL</code> signals, and depol. ratio from mean profiles.</p> Source code in <code>earthcarekit/utils/read/product/level1/atl_nom_1b.py</code> <pre><code>def add_depol_ratio(\n    ds_anom: xr.Dataset,\n    rolling_w: int = 20,\n    near_zero_tolerance: float = 2e-7,\n    smooth: bool = True,\n    skip_height_above_elevation: int = 300,\n    depol_ratio_var: str = \"depol_ratio\",\n    cpol_cleaned_var: str = \"cpol_cleaned_for_depol_calculation\",\n    xpol_cleaned_var: str = \"xpol_cleaned_for_depol_calculation\",\n    depol_ratio_from_means_var: str = \"depol_ratio_from_means\",\n    cpol_var: str = \"mie_attenuated_backscatter\",\n    xpol_var: str = \"crosspolar_attenuated_backscatter\",\n    elevation_var: str = ELEVATION_VAR,\n    height_var: str = HEIGHT_VAR,\n    height_dim: str = VERTICAL_DIM,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Compute depolarization ratio (`DPOL` = `XPOL`/`CPOL`) from attenuated backscatter signals.\n\n    This function derives the depolarization ratio from cross-polarized (`XPOL`) and\n    co-polarized (`CPOL`) attenuated backscatter signals. Signals below the surface\n    are masked, by default with a vertical margin on 300 meters above elevation to remove\n    potencial surface retrun. Also, signals are smoothed (or \"cleaned\") with a rolling mean,\n    and near-zero divisions are suppressed. Cleaned `CPOL` and `XPOL` signals are stored alongside `DPOL`,\n    and a secondary single depol. profile calculated from mean profiles is added (i.e., mean(`XPOL`)/mean(`CPOL`)).\n\n    Args:\n        ds_anom (xr.Dataset): ATL_NOM_1B dataset containing cross- and co-polar attenuated backscatter.\n        rolling_w (int, optional): Window size for rolling mean smoothing. Defaults to 20.\n        near_zero_tolerance (float, optional): Tolerance for masking near-zero `CPOL` (i.e., denominators). Defaults to 2e-7.\n        smooth (bool, optional): Whether to apply rolling mean smoothing. Defaults to True.\n        skip_height_above_elevation (int, optional): Vertical margin above surface elevation to mask in meters. Defaults to 300.\n        depol_ratio_var (str, optional): Name for depol. ratio variable. Defaults to \"depol_ratio\".\n        cpol_cleaned_var (str, optional): Name for cleaned co-polar variable. Defaults to \"cpol_cleaned_for_depol_calculation\".\n        xpol_cleaned_var (str, optional): Name for cleaned cross-polar variable. Defaults to \"xpol_cleaned_for_depol_calculation\".\n        depol_ratio_from_means_var (str, optional): Name for ratio from mean profiles. Defaults to \"depol_ratio_from_means\".\n        cpol_var (str, optional): Input co-polar variable name. Defaults to \"mie_attenuated_backscatter\".\n        xpol_var (str, optional): Input cross-polar variable name. Defaults to \"crosspolar_attenuated_backscatter\".\n        elevation_var (str, optional): Elevation variable name. Defaults to ELEVATION_VAR.\n        height_var (str, optional): Height variable name. Defaults to HEIGHT_VAR.\n        height_dim (str, optional): Height dimension name. Defaults to VERTICAL_DIM.\n\n    Returns:\n        xr.Dataset: Dataset with added depol. ratio, cleaned `CPOL`/`XPOL` signals,\n            and depol. ratio from mean profiles.\n    \"\"\"\n    cpol_da = ds_anom[cpol_var].copy()\n    xpol_da = ds_anom[xpol_var].copy()\n    ds_anom[depol_ratio_var] = xpol_da / cpol_da\n    rename_var_info(\n        ds_anom,\n        depol_ratio_var,\n        name=depol_ratio_var,\n        long_name=\"Depol. ratio from cross- and co-polar atten. part. bsc.\",\n        units=\"\",\n    )\n\n    elevation = (\n        ds_anom[elevation_var].values.copy()[:, np.newaxis]\n        + skip_height_above_elevation\n    )\n    mask_surface = ds_anom[height_var].values[0].copy() &lt; elevation\n\n    xpol = ds_anom[xpol_var].values\n    cpol = ds_anom[cpol_var].values\n    xpol[mask_surface] = np.nan\n    cpol[mask_surface] = np.nan\n    if smooth:\n        xpol = rolling_mean_2d(xpol, rolling_w, axis=0)\n        cpol = rolling_mean_2d(cpol, rolling_w, axis=0)\n        near_zero_mask = np.isclose(cpol, 0, atol=near_zero_tolerance)\n        ds_anom[depol_ratio_var].values = xpol / cpol\n        ds_anom[depol_ratio_var].values[near_zero_mask] = np.nan\n    else:\n        ds_anom[depol_ratio_var].values = xpol / cpol\n\n    xpol[near_zero_mask] = np.nan\n    cpol[near_zero_mask] = np.nan\n\n    ds_anom[cpol_cleaned_var] = ds_anom[cpol_var].copy()\n    ds_anom[cpol_cleaned_var].values = cpol\n\n    ds_anom[xpol_cleaned_var] = ds_anom[xpol_var].copy()\n    ds_anom[xpol_cleaned_var].values = xpol\n\n    dpol_mean = nan_mean(xpol, axis=0) / nan_mean(cpol, axis=0)\n    ds_anom[depol_ratio_from_means_var] = xr.DataArray(\n        data=dpol_mean,\n        dims=[height_dim],\n        attrs=dict(\n            long_name=\"Depol. ratio from cross- and co-polar atten. part. bsc.\",\n            units=\"\",\n        ),\n    )\n\n    return ds_anom\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.get_product_info","title":"get_product_info","text":"<pre><code>get_product_info(filepath, warn=False, must_exist=True)\n</code></pre> <p>Gather all info contained in the EarthCARE product's file path.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>def get_product_info(\n    filepath: str,\n    warn: bool = False,\n    must_exist: bool = True,\n) -&gt; ProductInfo:\n    \"\"\"Gather all info contained in the EarthCARE product's file path.\"\"\"\n    if _is_url(filepath):\n        filepath = _get_path_from_url(filepath)\n        must_exist = False\n\n    filepath = os.path.abspath(filepath)\n\n    if must_exist and not os.path.exists(filepath):\n        raise FileNotFoundError(f\"File does not exist: {filepath}\")\n\n    if must_exist:\n        pattern = re.compile(\n            r\".*ECA_[EJ][XNO][A-Z]{2}_..._..._.._\\d{8}T\\d{6}Z_\\d{8}T\\d{6}Z_\\d{5}[ABCDEFGH]\\.h5\"\n        )\n    else:\n        pattern = re.compile(\n            r\".*ECA_[EJ][XNO][A-Z]{2}_..._..._.._\\d{8}T\\d{6}Z_\\d{8}T\\d{6}Z_\\d{5}[ABCDEFGH].*\"\n        )\n    is_match = bool(pattern.fullmatch(filepath))\n\n    if not is_match:\n        pattern_orbit_file = re.compile(\n            r\".*ECA_[EJ][XNO][A-Z]{2}_..._......_\\d{8}T\\d{6}Z_\\d{8}T\\d{6}Z_\\d{4}.*\"\n        )\n        is_match = bool(pattern_orbit_file.fullmatch(filepath))\n\n        if not is_match:\n            raise ValueError(f\"EarthCARE product has invalid file name: {filepath}\")\n\n        filename = os.path.basename(filepath).removesuffix(\".h5\")\n        mission_id = FileMissionID.from_input(filename[0:3])\n        agency = FileAgency.from_input(filename[4])\n        latency = FileLatency.from_input(filename[5])\n        baseline = filename[6:8]\n        file_type = FileType.from_input(filename[9:19])\n        start_sensing_time: pd.Timestamp\n        try:\n            start_sensing_time = pd.Timestamp(filename[20:35])\n        except ValueError as e:\n            start_sensing_time = pd.NaT  # type: ignore\n        start_processing_time: pd.Timestamp\n        try:\n            start_processing_time = pd.Timestamp(filename[37:52])\n        except ValueError as e:\n            start_processing_time = pd.NaT  # type: ignore\n\n        info = ProductInfo(\n            mission_id=mission_id,\n            agency=agency,\n            latency=latency,\n            baseline=baseline,\n            file_type=file_type,\n            start_sensing_time=start_sensing_time,\n            start_processing_time=start_processing_time,\n            orbit_number=0,\n            frame_id=\"\",\n            orbit_and_frame=\"\",\n            name=filename,\n            filepath=filepath,\n            hdr_filepath=\"\",\n        )\n\n        return info\n\n    product_filepath = filepath.removesuffix(\".h5\").removesuffix(\".HDR\") + \".h5\"\n    if not os.path.exists(product_filepath):\n        if warn:\n            msg = f\"Missing product file: {product_filepath}\"\n            warnings.warn(msg)\n        product_filepath = \"\"\n\n    hdr_filepath = filepath.removesuffix(\".h5\").removesuffix(\".HDR\") + \".HDR\"\n    if not os.path.exists(hdr_filepath):\n        if warn:\n            msg = f\"Missing product header file: {hdr_filepath}\"\n            warnings.warn(msg)\n        hdr_filepath = \"\"\n\n    filename = os.path.basename(filepath).removesuffix(\".h5\").removesuffix(\".HDR\")\n    mission_id = FileMissionID.from_input(filename[0:3])\n    agency = FileAgency.from_input(filename[4])\n    latency = FileLatency.from_input(filename[5])\n    baseline = filename[6:8]\n    file_type = FileType.from_input(filename[9:19])\n    start_sensing_time = pd.Timestamp(filename[20:35])\n    start_processing_time = pd.Timestamp(filename[37:52])\n    orbit_number = int(filename[54:59])\n    frame_id = filename[59]\n    orbit_and_frame = filename[54:60]\n\n    info = ProductInfo(\n        mission_id=mission_id,\n        agency=agency,\n        latency=latency,\n        baseline=baseline,\n        file_type=file_type,\n        start_sensing_time=start_sensing_time,\n        start_processing_time=start_processing_time,\n        orbit_number=orbit_number,\n        frame_id=frame_id,\n        orbit_and_frame=orbit_and_frame,\n        name=filename,\n        filepath=product_filepath,\n        hdr_filepath=hdr_filepath,\n    )\n\n    return info\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.get_product_infos","title":"get_product_infos","text":"<pre><code>get_product_infos(filepaths, **kwargs)\n</code></pre> <p>Extracts product metadata from EarthCARE product file paths (e.g. file_type, orbit_number, frame_id, baseline, ...).</p> <p>Parameters:</p> Name Type Description Default <code>filepaths</code> <code>str | list[str] | NDArray | DataFrame | Dataset</code> <p>Input sources for EarthCARE product files. Can be one of - <code>str</code> -&gt; A single file path. - <code>list[str]</code> or <code>numpy.ndarray</code> -&gt; A list or array of file paths. - <code>pandas.DataFrame</code> -&gt; Must contain a 'filepath' column. - <code>xarray.Dataset</code> -&gt; Must have encoding with attribute 'source' (<code>str</code>) or 'sources' (<code>list[str]</code>).</p> required <code>**kwargs</code> <p>Additional arguments passed to <code>get_product_info()</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ProductDataFrame</code> <code>ProductDataFrame</code> <p>A dataframe containing extracted product information.</p> Source code in <code>earthcarekit/utils/read/product/file_info/product_info.py</code> <pre><code>def get_product_infos(\n    filepaths: str | list[str] | NDArray | pd.DataFrame | xr.Dataset,\n    **kwargs,\n) -&gt; \"ProductDataFrame\":\n    \"\"\"\n    Extracts product metadata from EarthCARE product file paths (e.g. file_type, orbit_number, frame_id, baseline, ...).\n\n    Args:\n        filepaths:\n            Input sources for EarthCARE product files. Can be one of\n            - `str` -&gt; A single file path.\n            - `list[str]` or `numpy.ndarray` -&gt; A list or array of file paths.\n            - `pandas.DataFrame` -&gt; Must contain a 'filepath' column.\n            - `xarray.Dataset` -&gt; Must have encoding with attribute 'source' (`str`) or 'sources' (`list[str]`).\n        **kwargs: Additional arguments passed to `get_product_info()`.\n\n    Returns:\n        ProductDataFrame: A dataframe containing extracted product information.\n    \"\"\"\n    _filepaths: list[str] | NDArray\n    if isinstance(filepaths, (str, np.str_)):\n        _filepaths = [str(filepaths)]\n    elif isinstance(filepaths, xr.Dataset):\n        ds: xr.Dataset = filepaths\n        if not hasattr(ds, \"encoding\"):\n            raise ValueError(f\"Dataset missing encoding attribute.\")\n        elif \"source\" in ds.encoding:\n            _filepaths = [ds.encoding[\"source\"]]\n        elif \"sources\" in ds.encoding:\n            _filepaths = ds.encoding[\"sources\"]\n        else:\n            raise ValueError(f\"Dataset encoding does not contain source or sources.\")\n    elif isinstance(filepaths, pd.DataFrame):\n        df: pd.DataFrame = filepaths\n        if \"filepath\" in df:\n            _filepaths = df[\"filepath\"].to_numpy()\n        else:\n            raise ValueError(\n                f\"\"\"Given dataframe does not contain a column of file paths. A valid file path column name is \"filepath\".\"\"\"\n            )\n    else:\n        _filepaths = filepaths\n\n    infos = []\n    for filepath in _filepaths:\n        try:\n            infos.append(get_product_info(filepath, **kwargs).to_dict())\n        except ValueError as e:\n            continue\n    pdf = ProductDataFrame(infos)\n    pdf.validate_columns()\n    return pdf\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_any","title":"read_any","text":"<pre><code>read_any(input, **kwargs)\n</code></pre> <p>Reads various input types and returns an <code>xarray.Dataset</code>.</p> This function can read <ul> <li>EarthCARE product files (<code>.h5</code>)</li> <li>NetCDF files (<code>.nc</code>)</li> <li>Manually processed PollyXT output files (<code>.txt</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | Dataset</code> <p>File path or existing Dataset.</p> required <code>**kwargs</code> <p>Additional keyword arguments for specific readers.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Opened dataset.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file type is not supported.</p> <code>TypeError</code> <p>If the input type is invalid.</p> Source code in <code>earthcarekit/utils/read/_read_any.py</code> <pre><code>def read_any(input: str | xr.Dataset, **kwargs) -&gt; xr.Dataset:\n    \"\"\"Reads various input types and returns an `xarray.Dataset`.\n\n    This function can read:\n        - EarthCARE product files (`.h5`)\n        - NetCDF files (`.nc`)\n        - Manually processed PollyXT output files (`.txt`)\n\n    Args:\n        input (str | xr.Dataset): File path or existing Dataset.\n        **kwargs: Additional keyword arguments for specific readers.\n\n    Returns:\n        xr.Dataset: Opened dataset.\n\n    Raises:\n        ValueError: If the file type is not supported.\n        TypeError: If the input type is invalid.\n    \"\"\"\n    if isinstance(input, xr.Dataset):\n        return input\n    elif isinstance(input, str):\n        filepath = input\n\n        if is_earthcare_product(filepath=filepath):\n            return read_product(filepath, **kwargs)\n\n        filename = os.path.basename(filepath)\n        _, ext = os.path.splitext(filename)\n        if ext.lower() == \".txt\":\n            return read_polly(filepath)\n        elif ext.lower() == \".nc\":\n            return read_nc(filepath, **kwargs)\n\n        raise ValueError(f\"Reading of file not supported: &lt;{input}&gt;\")\n    raise TypeError(f\"Invalid type '{type(input).__name__}' for input.\")\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_header_data","title":"read_header_data","text":"<pre><code>read_header_data(source: str) -&gt; xr.Dataset\n</code></pre><pre><code>read_header_data(source: Dataset) -&gt; xr.Dataset\n</code></pre> <pre><code>read_header_data(source)\n</code></pre> <p>Opens the product header groups of a EarthCARE file as a <code>xarray.Dataset</code>.</p> Source code in <code>earthcarekit/utils/read/product/header_group.py</code> <pre><code>def read_header_data(source: str | xr.Dataset) -&gt; xr.Dataset:\n    \"\"\"Opens the product header groups of a EarthCARE file as a `xarray.Dataset`.\"\"\"\n    if isinstance(source, str):\n        filepath = source\n    elif isinstance(source, xr.Dataset):\n        filepath = source.encoding.get(\"source\", None)\n        if filepath is None:\n            raise ValueError(f\"Dataset missing source attribute\")\n    else:\n        raise TypeError(\"Expected 'str' or 'xarray.Dataset'\")\n\n    groups = xr.open_groups(filepath)\n    header_groups = {n: g for n, g in groups.items() if \"HeaderData\" in n}\n\n    # Rename duplicate vars\n\n    all_vars = {}\n    header_datasets = []\n    for i, (group_name, ds) in enumerate(header_groups.items()):\n        ds_new = ds.copy()\n        for var in ds.data_vars:\n            if var in all_vars:\n                new_name = f\"{group_name.split('/')[-1]}_{var}\"\n                ds_new = ds_new.rename({var: new_name})\n            else:\n                all_vars[var] = True\n        header_datasets.append(ds_new)\n\n    ds = xr.merge(header_datasets)\n\n    ds = _convert_all_fill_values_to_nan(ds)\n\n    # Convert timestamps to numpy datetime\n    for var in [\n        \"Creation_Date\",\n        \"Validity_Start\",\n        \"Validity_Stop\",\n        \"ANXTime\",\n        \"frameStartTime\",\n        \"frameStopTime\",\n        \"processingStartTime\",\n        \"processingStopTime\",\n        \"sensingStartTime\",\n        \"sensingStopTime\",\n        \"stateVectorTime\",\n    ]:\n        if var in ds:\n            raw = ds[var].values\n            formatted = np.char.replace(raw, \"UTC=\", \"\")\n            ds[var].values = formatted.astype(\"datetime64[ns]\")\n\n    # Ensure that strings are correctly decoded\n    for var in [\"frameID\"]:\n        if var in ds:\n            ds = convert_scalar_var_to_str(ds, var)\n\n    # Remove dimensions of size == 1\n    ds = ds.squeeze()\n\n    return ds\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_nc","title":"read_nc","text":"<pre><code>read_nc(input, modify=True, in_memory=False, **kwargs)\n</code></pre> <p>Returns an <code>xarray.Dataset</code> from a Dataset or NetCDF file path, optionally loaded into memory.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Dataset or str</code> <p>Path to a NetCDF file. If a already opened <code>xarray.Dataset</code> object is passed, it is returned as is.</p> required <code>modify</code> <code>bool</code> <p>If True, default modifications to the opened dataset will be applied (e.g., converting heights in Polly data from height a.g.l. to height above mean sea level).</p> <code>True</code> <code>in_memory</code> <code>bool</code> <p>If True, ensures the dataset is fully loaded into memory. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Key-word arguments passed to <code>xarray.open_dataset()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xarray.Dataset: The resulting dataset.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not a Dataset or string.</p> Source code in <code>earthcarekit/utils/read/_read_nc.py</code> <pre><code>def read_nc(\n    input: str | xr.Dataset,\n    modify: bool = True,\n    in_memory: bool = False,\n    **kwargs,\n) -&gt; xr.Dataset:\n    \"\"\"Returns an `xarray.Dataset` from a Dataset or NetCDF file path, optionally loaded into memory.\n\n    Args:\n        input (xarray.Dataset or str): Path to a NetCDF file. If a already opened `xarray.Dataset` object is passed, it is returned as is.\n        modify (bool): If True, default modifications to the opened dataset will be applied\n            (e.g., converting heights in Polly data from height a.g.l. to height above mean sea level).\n        in_memory (bool, optional): If True, ensures the dataset is fully loaded into memory. Defaults to False.\n        **kwargs: Key-word arguments passed to `xarray.open_dataset()`.\n\n    Returns:\n        xarray.Dataset: The resulting dataset.\n\n    Raises:\n        TypeError: If input is not a Dataset or string.\n    \"\"\"\n    ds: xr.Dataset\n    if isinstance(input, xr.Dataset):\n        ds = input\n    elif isinstance(input, str):\n        if in_memory:\n            with _read_nc(input, modify=modify, **kwargs) as ds:\n                ds = ds.load()\n        else:\n            ds = _read_nc(input, modify=modify, **kwargs)\n    else:\n        raise TypeError(\n            f\"Invalid input type! Expecting a opened NetCDF dataset (xarray.Dataset) or a path to a NetCDF file.\"\n        )\n    return ds\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_polly","title":"read_polly","text":"<pre><code>read_polly(input)\n</code></pre> <p>Reads manually processed PollyXT output text files as <code>xarray.Dataset</code> or returns an already open one.</p> Source code in <code>earthcarekit/utils/read/_read_polly.py</code> <pre><code>def read_polly(input: str | xr.Dataset) -&gt; xr.Dataset:\n    \"\"\"Reads manually processed PollyXT output text files as `xarray.Dataset` or returns an already open one.\"\"\"\n\n    if isinstance(input, xr.Dataset):\n        return input\n\n    with open(input, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n        df = pd.read_csv(f, sep=\"\\t\")\n\n    new_columns = [_parse_column_name(c) for c in df.columns]\n    new_column_names = [c.name for c in new_columns]\n    new_column_names = _make_column_names_unique(new_column_names)\n    df.columns = pd.Index(new_column_names)\n\n    ds = xr.Dataset.from_dataframe(df)\n    ds = ds.assign_coords(index=ds.height.values)\n    ds = ds.rename({\"index\": \"vertical\"})\n    if \"time\" not in ds:\n        ds = ds.assign({\"time\": np.datetime64(\"1970-01-01T00:00:00.000\", \"ms\")})\n\n    vars_order = [\"time\"] + [v for v in ds.data_vars if v != \"time\"]\n    ds = ds[vars_order]\n\n    for c in new_columns:\n        if c.units == \"km\":\n            ds[c.name].values = ds[c.name].values * 1e3\n            c.units = c.units.replace(\"k\", \"\")\n        elif c.units in [\"Mm-1 sr-1\", \"Mm-1\", \"Msr-1\"]:\n            ds[c.name].values = ds[c.name].values / 1e6\n            c.units = c.units.replace(\"M\", \"\")\n\n        ds[c.name] = ds[c.name].assign_attrs(\n            dict(\n                long_name=c.long_name,\n                units=c.units,\n            )\n        )\n    return ds\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_product","title":"read_product","text":"<pre><code>read_product(\n    input,\n    trim_to_frame=True,\n    modify=DEFAULT_READ_EC_PRODUCT_MODIFY,\n    header=DEFAULT_READ_EC_PRODUCT_HEADER,\n    meta=DEFAULT_READ_EC_PRODUCT_META,\n    in_memory=False,\n    **kwargs\n)\n</code></pre> <p>Returns an <code>xarray.Dataset</code> from a Dataset or EarthCARE file path, optionally loaded into memory.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str or Dataset</code> <p>Path to a EarthCARE file. If a <code>xarray.Dataset</code> is given it will be returned as is.</p> required <code>trim_to_frame</code> <code>bool</code> <p>Whether to trim the dataset to latitude frame bounds. Defaults to True.</p> <code>True</code> <code>modify</code> <code>bool</code> <p>If True, default modifications to the opened dataset will be applied (e.g., renaming dimension corresponding to height to \"vertical\"). Defaults to True.</p> <code>DEFAULT_READ_EC_PRODUCT_MODIFY</code> <code>header</code> <code>bool</code> <p>If True, all header data will be included in the dataframe. Defaults to False.</p> <code>DEFAULT_READ_EC_PRODUCT_HEADER</code> <code>meta</code> <code>bool</code> <p>If True, select meta data from header (like orbit number and frame ID) will be included in the dataframe. Defaults to True.</p> <code>DEFAULT_READ_EC_PRODUCT_META</code> <code>in_memory</code> <code>bool</code> <p>If True, ensures the dataset is fully loaded into memory. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xarray.Dataset: The resulting dataset.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not a Dataset or string.</p> Source code in <code>earthcarekit/utils/read/product/_generic.py</code> <pre><code>def read_product(\n    input: str | Dataset,\n    trim_to_frame: bool = True,\n    modify: bool = DEFAULT_READ_EC_PRODUCT_MODIFY,\n    header: bool = DEFAULT_READ_EC_PRODUCT_HEADER,\n    meta: bool = DEFAULT_READ_EC_PRODUCT_META,\n    in_memory: bool = False,\n    **kwargs,\n) -&gt; Dataset:\n    \"\"\"Returns an `xarray.Dataset` from a Dataset or EarthCARE file path, optionally loaded into memory.\n\n    Args:\n        input (str or xarray.Dataset): Path to a EarthCARE file. If a `xarray.Dataset` is given it will be returned as is.\n        trim_to_frame (bool, optional): Whether to trim the dataset to latitude frame bounds. Defaults to True.\n        modify (bool): If True, default modifications to the opened dataset will be applied\n            (e.g., renaming dimension corresponding to height to \"vertical\"). Defaults to True.\n        header (bool): If True, all header data will be included in the dataframe. Defaults to False.\n        meta (bool): If True, select meta data from header (like orbit number and frame ID) will be included in the dataframe. Defaults to True.\n        in_memory (bool, optional): If True, ensures the dataset is fully loaded into memory. Defaults to False.\n\n    Returns:\n        xarray.Dataset: The resulting dataset.\n\n    Raises:\n        TypeError: If input is not a Dataset or string.\n    \"\"\"\n    ds: Dataset\n    if isinstance(input, Dataset):\n        ds = input\n    elif isinstance(input, str):\n        if in_memory:\n            with _read_product(\n                filepath=input,\n                trim_to_frame=trim_to_frame,\n                modify=modify,\n                header=header,\n                meta=meta,\n                **kwargs,\n            ) as ds:\n                ds = ds.load()\n        else:\n            ds = _read_product(\n                filepath=input,\n                trim_to_frame=trim_to_frame,\n                modify=modify,\n                header=header,\n                meta=meta,\n                **kwargs,\n            )\n    else:\n        raise TypeError(\n            f\"Invalid input type! Expecting a opened EarthCARE dataset (xarray.Dataset) or a path to a EarthCARE product.\"\n        )\n    return ds\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_products","title":"read_products","text":"<pre><code>read_products(\n    filepaths,\n    zoom_at=None,\n    along_track_dim=ALONG_TRACK_DIM,\n    func=None,\n    func_inputs=None,\n    max_num_files=8,\n    coarsen=True,\n)\n</code></pre> <p>Read and concatenate a sequence of EarthCARE frames into a single xarray Dataset.</p> <p>By default, the dataset is coarsened according to the number of input frames (e.g., combining 3 products averages every 3 profiles, so the along-track dimension remains comparable to a single product). Optionally applies a processing function to each frame and zooms in on a specific region (defined by <code>zoom_at</code>) without coarsening. Coarsening can also be turned of but might case memory issues.</p> <p>Parameters:</p> Name Type Description Default <code>filepaths</code> <code>Sequence[str] or DataFrame</code> <p>EarthCARE product file paths as a list or a DataFrame with metadata including <code>filepath</code>, <code>orbit_number</code>, and <code>frame_id</code>.</p> required <code>zoom_at</code> <code>float</code> <p>If set, selects only a zoomed-in portion of the frames around this fractional index. Defaults to None.</p> <code>None</code> <code>along_track_dim</code> <code>str</code> <p>Name of the dimension to concatenate along. Defaults to ALONG_TRACK_DIM.</p> <code>ALONG_TRACK_DIM</code> <code>func</code> <code>Callable</code> <p>Function to apply to each frame after loading. Defaults to None.</p> <code>None</code> <code>func_inputs</code> <code>Sequence[dict]</code> <p>Optional per-frame arguments to pass to <code>func</code>. Defaults to None.</p> <code>None</code> <code>max_num_files</code> <code>int</code> <p>Max. number of files that are allowed to be loaded at once. A <code>ValueError</code> is raised if above. Defaults to 8 (e.g., full orbit).</p> <code>8</code> <code>coarsen</code> <code>bool</code> <p>If Ture, read data sets are coarened depending on the number given of files. Only aplicable when not zooming. Defaults to Ture.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>Concatenated dataset with all frames along <code>along_track_dim</code>.</p> Source code in <code>earthcarekit/utils/read/product/_concat.py</code> <pre><code>def read_products(\n    filepaths: Sequence[str] | pd.DataFrame,\n    zoom_at: float | None = None,\n    along_track_dim: str = ALONG_TRACK_DIM,\n    func: Callable | None = None,\n    func_inputs: Sequence[dict] | None = None,\n    max_num_files: int = 8,\n    coarsen: bool = True,\n) -&gt; Dataset:\n    \"\"\"Read and concatenate a sequence of EarthCARE frames into a single xarray Dataset.\n\n    By default, the dataset is coarsened according to the number of input frames (e.g.,\n    combining 3 products averages every 3 profiles, so the along-track dimension remains\n    comparable to a single product). Optionally applies a processing function to each\n    frame and zooms in on a specific region (defined by `zoom_at`) without coarsening.\n    Coarsening can also be turned of but might case memory issues.\n\n    Args:\n        filepaths (Sequence[str] or pandas.DataFrame):\n            EarthCARE product file paths as a list or a DataFrame with metadata\n            including `filepath`, `orbit_number`, and `frame_id`.\n        zoom_at (float, optional):\n            If set, selects only a zoomed-in portion of the frames around this\n            fractional index. Defaults to None.\n        along_track_dim (str, optional):\n            Name of the dimension to concatenate along. Defaults to ALONG_TRACK_DIM.\n        func (Callable, optional):\n            Function to apply to each frame after loading. Defaults to None.\n        func_inputs (Sequence[dict], optional):\n            Optional per-frame arguments to pass to `func`. Defaults to None.\n        max_num_files (int, optional):\n            Max. number of files that are allowed to be loaded at once.\n            A `ValueError` is raised if above. Defaults to 8 (e.g., full orbit).\n        coarsen (bool, optional):\n            If Ture, read data sets are coarened depending on the number given of files.\n            Only aplicable when not zooming. Defaults to Ture.\n\n    Returns:\n        Dataset: Concatenated dataset with all frames along `along_track_dim`.\n    \"\"\"\n    if isinstance(filepaths, str):\n        filepaths = [filepaths]\n    elif isinstance(filepaths, pd.DataFrame):\n        df = filepaths.sort_values(by=\"filepath\")\n        filepaths = df[\"filepath\"].tolist()\n    else:\n        df = ProductDataFrame.from_files(list(filepaths)).sort_values(by=\"filepath\")\n        df.validate_columns()\n        filepaths = df[\"filepath\"].tolist()\n\n    if len(filepaths) == 0:\n        raise ValueError(f\"Given sequence of product files paths is empty\")\n    elif len(filepaths) == 1:\n        warnings.warn(f\"Can not concatenate frames since only one file path was given\")\n        return read_product(filepaths[0])\n    elif len(filepaths) &gt; max_num_files:\n        raise ValueError(\n            f\"Too many files provided: {len(filepaths)} (currently maximum allowed is {max_num_files}). \"\n            \"Please reduce the number of files or increase the allowed amount by setting the argument max_num_files.\"\n        )\n    elif len(filepaths) &gt; 8:\n        warnings.warn(\n            f\"You provided {len(filepaths)} files, which is more than one full orbit (8 files). \"\n            \"Processing might take longer than usual.\"\n        )\n\n    # # Construct filename suffix from orbit/frame numbers\n    # orbit_start = str(df[\"orbit_number\"].iloc[0]).zfill(5)\n    # orbit_end = str(df[\"orbit_number\"].iloc[-1]).zfill(5)\n    # frame_start = df[\"frame_id\"].iloc[0]\n    # frame_end = df[\"frame_id\"].iloc[-1]\n\n    # if orbit_start == orbit_end:\n    #     oaf_string = (\n    #         f\"{orbit_start}{frame_start}\"\n    #         if frame_start == frame_end\n    #         else f\"{orbit_start}{frame_start}-{frame_end}\"\n    #     )\n    # else:\n    #     oaf_string = f\"{orbit_start}{frame_start}-{orbit_end}{frame_end}\"\n\n    def apply_func(ds: Dataset, i: int) -&gt; Dataset:\n        \"\"\"Apply a processing function to a dataset if specified.\"\"\"\n        if func is None:\n            return ds\n        if func_inputs is None:\n            return func(ds)\n        if i &lt; len(func_inputs):\n            return func(ds, **func_inputs[i])\n        raise IndexError(\"Too few function inputs provided\")\n\n    num_files = len(filepaths)\n    ds: xr.Dataset | None = None\n\n    if zoom_at is not None:\n        # Zoomed read: select portions of two adjacent frames\n        frame_indices = np.unique([int(np.floor(zoom_at)), int(np.ceil(zoom_at))])\n        offset = zoom_at - frame_indices[0]\n        filepaths = [filepaths[i] for i in frame_indices]\n\n        for i, filepath in enumerate(filepaths):\n            with read_product(filepath) as frame_ds:\n                frame_ds = apply_func(frame_ds, frame_indices[i])\n\n                # Preserve original dtypes\n                original_dtypes = {v: frame_ds[v].dtype for v in frame_ds.variables}\n\n                # Select relevant portion of the frame\n                n = len(frame_ds[along_track_dim])\n                sel_slice = (\n                    slice(int(np.floor(n * offset)), n)\n                    if i == 0\n                    else slice(0, int(np.ceil(n * offset)))\n                )\n                frame_ds = frame_ds.sel({along_track_dim: sel_slice})\n\n                # Restore dtypes\n                for v, dtype in original_dtypes.items():\n                    frame_ds[v] = frame_ds[v].astype(dtype)\n\n                ds = (\n                    frame_ds.copy()\n                    if ds is None\n                    else concat_datasets(\n                        ds.copy(), frame_ds.copy(), dim=along_track_dim\n                    )\n                )\n\n    else:\n        # Full read and coarsen each frame\n        for i, filepath in enumerate(filepaths):\n            with read_product(filepath) as frame_ds:\n                frame_ds = apply_func(frame_ds, i)\n\n                if coarsen:\n                    original_dtypes = {v: frame_ds[v].dtype for v in frame_ds.variables}\n\n                    coarsen_dims = {along_track_dim: num_files}\n\n                    # Circular mean for longitude\n                    lon_coarse = (\n                        frame_ds[\"longitude\"]\n                        .coarsen(coarsen_dims, boundary=\"trim\")\n                        .reduce(circular_mean_np)\n                    )\n                    _tmp_attrs = lon_coarse.attrs\n                    lon_coarse.attrs = {}\n\n                    # Regular mean for the rest\n                    rest = (\n                        frame_ds.drop_vars(\"longitude\")\n                        .coarsen(coarsen_dims, boundary=\"trim\")\n                        .mean()  # type: ignore\n                    )\n\n                    # Merge results\n                    frame_ds = xr.merge([lon_coarse, rest])\n                    frame_ds[\"longitude\"].attrs = _tmp_attrs\n\n                    for v, dtype in original_dtypes.items():\n                        frame_ds[v] = frame_ds[v].astype(dtype)\n\n                ds = (\n                    frame_ds\n                    if ds is None\n                    else concat_datasets(ds, frame_ds, dim=along_track_dim)\n                )\n\n    # Set output file sources\n    if isinstance(ds, Dataset):\n        ds.encoding[\"sources\"] = list(filepaths)\n        return ds\n    else:\n        raise RuntimeError(f\"Bad implementation\")\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.read_science_data","title":"read_science_data","text":"<pre><code>read_science_data(filepath, agency=None, **kwargs)\n</code></pre> <p>Opens the science data of a EarthCARE file as a <code>xarray.Dataset</code>.</p> Source code in <code>earthcarekit/utils/read/product/science_group.py</code> <pre><code>def read_science_data(\n    filepath: str,\n    agency: Union[\"FileAgency\", None] = None,\n    **kwargs,\n) -&gt; xr.Dataset:\n    \"\"\"Opens the science data of a EarthCARE file as a `xarray.Dataset`.\"\"\"\n    from .file_info.agency import (\n        FileAgency,  # Imported inside function to avoid circular import error\n    )\n\n    if agency is None:\n        agency = FileAgency.from_input(filepath)\n\n    if agency == FileAgency.ESA:\n        ds = xr.open_dataset(filepath, group=\"ScienceData\", **kwargs)\n    elif agency == FileAgency.JAXA:\n        df_cpr_geo = xr.open_dataset(\n            filepath, group=\"ScienceData/Geo\", engine=\"h5netcdf\", phony_dims=\"sort\"\n        )\n        df_cpr_data = xr.open_dataset(\n            filepath, group=\"ScienceData/Data\", engine=\"h5netcdf\", phony_dims=\"sort\"\n        )\n        ds = xr.merge([df_cpr_data, df_cpr_geo])\n        ds.encoding[\"source\"] = df_cpr_data.encoding[\"source\"]\n    else:\n        raise NotImplementedError()\n\n    ds = _convert_all_fill_values_to_nan(ds)\n\n    return ds\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.rebin_xmet_to_vertical_track","title":"rebin_xmet_to_vertical_track","text":"<pre><code>rebin_xmet_to_vertical_track(\n    ds_xmet,\n    ds_vert,\n    vars=None,\n    k=4,\n    eps=1e-12,\n    lat_var=TRACK_LAT_VAR,\n    lon_var=TRACK_LON_VAR,\n    time_var=TIME_VAR,\n    height_var=HEIGHT_VAR,\n    along_track_dim=ALONG_TRACK_DIM,\n    height_dim=VERTICAL_DIM,\n    xmet_lat_var=\"latitude\",\n    xmet_lon_var=\"longitude\",\n    xmet_height_var=\"geometrical_height\",\n    xmet_height_dim=\"height\",\n    xmet_horizontal_grid_dim=\"horizontal_grid\",\n)\n</code></pre> <p>Rebins variables from an AUX_MET_1D (XMET) dataset onto the vertical curtain track of given by another dataset (e.g. ATL_EBD_2A).</p> <p>This function interpolates selected variables from <code>ds_xmet</code> onto a EarthCARE vertical track given in <code>ds_vert</code>, using quick horizontal kd-tree nearest-neighbor search with <code>scipy.spatial.cKDTree</code> followed by averaging the <code>k</code>-nearest vertical XMET profiles using inverse distance weighting. The resulting profiles are then interpolated in the vertical to match the height resolution of <code>ds_vert</code>.</p> <p>Parameters:</p> Name Type Description Default <code>ds_xmet</code> <code>Dataset</code> <p>The source XMET dataset from which vertical curtain along track will be interpolated.</p> required <code>ds_vert</code> <code>Dataset</code> <p>The target dataset containing the vertical curtain track.</p> required <code>vars</code> <code>list[str] | None</code> <p>List of variable names from <code>ds_xmet</code> to rebin. If None, all data variables are considered.</p> <code>None</code> <code>k</code> <code>int</code> <p>Number of nearest horizontal neighbors to include in the kd-tree search. Defaults to 4.</p> <code>4</code> <code>eps</code> <code>float</code> <p>Numerical threshold to avoid division by zero in distance calculations during the kd-tree search. Defaults to 1e-12.</p> <code>1e-12</code> <code>lat_var</code> <code>str</code> <p>Name of the latitude variable in <code>ds_vert</code>. Defaults to TRACK_LAT_VAR.</p> <code>TRACK_LAT_VAR</code> <code>lon_var</code> <code>str</code> <p>Name of the longitude variable in <code>ds_vert</code>. Defaults to TRACK_LON_VAR.</p> <code>TRACK_LON_VAR</code> <code>time_var</code> <code>str</code> <p>Name of the time variable in <code>ds_vert</code>. Defaults to TIME_VAR.</p> <code>TIME_VAR</code> <code>height_var</code> <code>str</code> <p>Name of the height variable in <code>ds_vert</code>. Defaults to HEIGHT_VAR.</p> <code>HEIGHT_VAR</code> <code>along_track_dim</code> <code>str</code> <p>Name of the along-track dimension in <code>ds_vert</code>. Defaults to ALONG_TRACK_DIM.</p> <code>ALONG_TRACK_DIM</code> <code>height_dim</code> <code>str</code> <p>Name of the vertical or height dimension in <code>ds_vert</code>. Defaults to VERTICAL_DIM.</p> <code>VERTICAL_DIM</code> <code>xmet_lat_var</code> <code>str</code> <p>Name of the latitude variable in <code>ds_xmet</code>. Defaults to \"latitude\".</p> <code>'latitude'</code> <code>xmet_lon_var</code> <code>str</code> <p>Name of the longitude variable in <code>ds_xmet</code>. Defaults to \"longitude\".</p> <code>'longitude'</code> <code>xmet_height_var</code> <code>str</code> <p>Name of the height variable in <code>ds_xmet</code>. Defaults to \"geometrical_height\".</p> <code>'geometrical_height'</code> <code>xmet_height_dim</code> <code>str</code> <p>Name of the vertical dimension in <code>ds_xmet</code>. Defaults to \"height\".</p> <code>'height'</code> <code>xmet_horizontal_grid_dim</code> <code>str</code> <p>Name of the horizontal grid dimension in <code>ds_xmet</code>. Defaults to \"horizontal_grid\".</p> <code>'horizontal_grid'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: A new dataset containing the selected XMET variables interpolated to the grid of the vertical curtain given in <code>ds_vert</code>. This new dataset has the same along-track and vertical dimensions as <code>ds_vert</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If any specified variable or coordinate name is not found in <code>ds_xmet</code>.</p> Source code in <code>earthcarekit/utils/read/product/auxiliary/aux_met_1d.py</code> <pre><code>def rebin_xmet_to_vertical_track(\n    ds_xmet: xr.Dataset,\n    ds_vert: xr.Dataset,\n    vars: list[str] | None = None,\n    k: int = 4,\n    eps: float = 1e-12,\n    lat_var: str = TRACK_LAT_VAR,\n    lon_var: str = TRACK_LON_VAR,\n    time_var: str = TIME_VAR,\n    height_var: str = HEIGHT_VAR,\n    along_track_dim: str = ALONG_TRACK_DIM,\n    height_dim: str = VERTICAL_DIM,\n    xmet_lat_var: str = \"latitude\",\n    xmet_lon_var: str = \"longitude\",\n    xmet_height_var: str = \"geometrical_height\",\n    xmet_height_dim: str = \"height\",\n    xmet_horizontal_grid_dim: str = \"horizontal_grid\",\n) -&gt; xr.Dataset:\n    \"\"\"\n    Rebins variables from an AUX_MET_1D (XMET) dataset onto the vertical curtain track of given by another dataset (e.g. ATL_EBD_2A).\n\n    This function interpolates selected variables from `ds_xmet` onto a EarthCARE\n    vertical track given in `ds_vert`, using quick horizontal kd-tree nearest-neighbor search with `scipy.spatial.cKDTree` followed\n    by averaging the `k`-nearest vertical XMET profiles using inverse distance weighting. The resulting\n    profiles are then interpolated in the vertical to match the height resolution of `ds_vert`.\n\n    Args:\n        ds_xmet (xr.Dataset): The source XMET dataset from which vertical curtain along track will be interpolated.\n        ds_vert (xr.Dataset): The target dataset containing the vertical curtain track.\n        vars (list[str] | None, optional): List of variable names from `ds_xmet` to rebin.\n            If None, all data variables are considered.\n        k (int, optional): Number of nearest horizontal neighbors to include in the kd-tree search.\n            Defaults to 4.\n        eps (float, optional): Numerical threshold to avoid division by zero in distance calculations during the kd-tree search.\n            Defaults to 1e-12.\n        lat_var (str, optional): Name of the latitude variable in `ds_vert`.\n            Defaults to TRACK_LAT_VAR.\n        lon_var (str, optional): Name of the longitude variable in `ds_vert`.\n            Defaults to TRACK_LON_VAR.\n        time_var (str, optional): Name of the time variable in `ds_vert`.\n            Defaults to TIME_VAR.\n        height_var (str, optional): Name of the height variable in `ds_vert`.\n            Defaults to HEIGHT_VAR.\n        along_track_dim (str, optional): Name of the along-track dimension in `ds_vert`.\n            Defaults to ALONG_TRACK_DIM.\n        height_dim (str, optional): Name of the vertical or height dimension in `ds_vert`.\n            Defaults to VERTICAL_DIM.\n        xmet_lat_var (str, optional): Name of the latitude variable in `ds_xmet`.\n            Defaults to \"latitude\".\n        xmet_lon_var (str, optional): Name of the longitude variable in `ds_xmet`.\n            Defaults to \"longitude\".\n        xmet_height_var (str, optional): Name of the height variable in `ds_xmet`.\n            Defaults to \"geometrical_height\".\n        xmet_height_dim (str, optional): Name of the vertical dimension in `ds_xmet`.\n            Defaults to \"height\".\n        xmet_horizontal_grid_dim (str, optional): Name of the horizontal grid dimension in `ds_xmet`.\n            Defaults to \"horizontal_grid\".\n\n    Returns:\n        xr.Dataset: A new dataset containing the selected XMET variables interpolated to the grid of the\n            vertical curtain given in `ds_vert`. This new dataset has the same along-track and vertical\n            dimensions as `ds_vert`.\n\n    Raises:\n        KeyError: If any specified variable or coordinate name is not found in `ds_xmet`.\n    \"\"\"\n    if vars is None:\n        vars = [str(v) for v in ds_xmet.variables]\n    else:\n        for var in vars:\n            if var not in ds_xmet.variables:\n                present_vars = [str(v) for v in ds_xmet.variables]\n                raise KeyError(\n                    f\"\"\"X-MET dataset does not contain variable \"{var}\". Present variables are: {\", \".join(present_vars)}\"\"\"\n                )\n\n    new_ds_xmet = ds_xmet.copy().swap_dims({xmet_height_dim: \"tmp_xmet_height\"})\n    new_ds_xmet[time_var] = ds_vert[time_var].copy()\n    new_ds_xmet[height_var] = ds_vert[height_var].copy()\n\n    hgrid_lat = ds_xmet[xmet_lat_var].values.flatten()\n    hgrid_lon = ds_xmet[xmet_lon_var].values.flatten()\n    hgrid_alt = ds_xmet[xmet_height_var].values\n    hgrid_coords = sequence_geo_to_ecef(hgrid_lat, hgrid_lon)\n\n    track_lat = ds_vert[lat_var].values\n    track_lon = ds_vert[lon_var].values\n    track_alt = ds_vert[height_var].values\n    track_coords = sequence_geo_to_ecef(track_lat, track_lon)\n\n    tree = cKDTree(hgrid_coords)\n    dists, idxs = tree.query(track_coords, k=k)\n\n    # Inverse distance weighting\n    if k &gt; 1:\n        weights = 1.0 / (dists + eps)\n        weights /= np.sum(weights, axis=1, keepdims=True)\n        height = np.einsum(\"ij,ijh-&gt;ih\", weights, hgrid_alt[idxs])\n    else:\n        weights = np.ones(idxs.shape)\n        height = hgrid_alt[idxs]\n\n    dims: str | tuple[str, str]\n    for var in vars:\n        values = ds_xmet[var].values\n        if len(values.shape) == 0:\n            continue\n\n        if len(values.shape) == 1:\n            dims = along_track_dim\n\n            if k &gt; 1:\n                result = np.sum(values[idxs] * weights, axis=1)\n                new_values = result\n            else:\n                new_values = values[idxs]\n        else:\n            dims = (along_track_dim, height_dim)\n\n            if k &gt; 1:\n                result = np.einsum(\"ij,ijh-&gt;ih\", weights, values[idxs])\n            else:\n                result = values[idxs]\n\n            new_values = np.empty(track_alt.shape)\n            new_values[:] = np.nan\n\n            for i in np.arange(track_alt.shape[0]):\n                _new_values = np.interp(\n                    track_alt[i],\n                    height[i],\n                    result[i],\n                )\n                # _new_values = interp(track_alt[i])\n\n                # Fill nans\n                # _new_values[np.isnan(_new_values) &amp; (track_alt[i] &lt; height[i, 0])] = result[i, 0]\n                # _new_values[np.isnan(_new_values) &amp; (track_alt[i] &gt; height[i, -1])] = result[i, -1]\n\n                new_values[i] = _new_values\n\n        new_var = f\"{var}\"\n        new_ds_xmet[new_var] = (dims, new_values)\n        new_ds_xmet[new_var].attrs = ds_xmet[var].attrs\n\n    new_ds_xmet = remove_dims(new_ds_xmet, [xmet_horizontal_grid_dim, xmet_height_dim])\n\n    return new_ds_xmet\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.search_files_by_regex","title":"search_files_by_regex","text":"<pre><code>search_files_by_regex(root_dirpath, regex_pattern)\n</code></pre> <p>Recursively searches for files in a directory that match a given regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>root_dirpath</code> <code>str</code> <p>The root directory to start the search from.</p> required <code>regex_pattern</code> <code>str</code> <p>A regular expression pattern to match file names against.</p> required Return <p>list[str]: A list of absolute file paths that point to files with matching names.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the root directory does not exist.</p> <code>error</code> <p>If the given pattern is not a valid regular expression.</p> Source code in <code>earthcarekit/utils/read/search.py</code> <pre><code>def search_files_by_regex(root_dirpath: str, regex_pattern: str) -&gt; list[str]:\n    \"\"\"\n    Recursively searches for files in a directory that match a given regex pattern.\n\n    Args:\n        root_dirpath (str): The root directory to start the search from.\n        regex_pattern (str): A regular expression pattern to match file names against.\n\n    Return:\n        list[str]: A list of absolute file paths that point to files with matching names.\n\n    Raises:\n        FileNotFoundError: If the root directory does not exist.\n        re.error: If the given pattern is not a valid regular expression.\n    \"\"\"\n    if not os.path.exists(root_dirpath):\n        raise FileNotFoundError(\n            f\"{search_files_by_regex.__name__}() Root directory does not exist: {root_dirpath}\"\n        )\n\n    filepaths = []\n    for dirpath, _, filenames in os.walk(root_dirpath):\n        for filename in filenames:\n            filepath = os.path.join(dirpath, filename)\n            if re.search(regex_pattern, filename):\n                filepaths.append(filepath)\n    return filepaths\n</code></pre>"},{"location":"api_ref/read/#earthcarekit.read.search_product","title":"search_product","text":"<pre><code>search_product(\n    root_dirpath=None,\n    config=None,\n    file_type=None,\n    agency=None,\n    latency=None,\n    timestamp=None,\n    baseline=None,\n    orbit_and_frame=None,\n    orbit_number=None,\n    frame_id=None,\n    filename=None,\n    start_time=None,\n    end_time=None,\n)\n</code></pre> <p>Searches for EarthCARE product files matching given metadata filters.</p> <p>Parameters:</p> Name Type Description Default <code>root_dirpath</code> <code>str</code> <p>Root directory to search. Defaults to directory given in a configuration file.</p> <code>None</code> <code>config</code> <code>str | ECKConfig | None</code> <p>Path to a <code>config.toml</code> file or a ECKConfig instance. Defaults to the default configuration file path.</p> <code>None</code> <code>file_type</code> <code>str | Sequence[str]</code> <p>Product file type(s) to match.</p> <code>None</code> <code>agency</code> <code>str | Sequence[str]</code> <p>Producing agency or agencies (e.g. \"ESA\" or \"JAXA\").</p> <code>None</code> <code>latency</code> <code>str | Sequence[str]</code> <p>Data latency level(s).</p> <code>None</code> <code>timestamp</code> <code>TimestampLike | Sequence</code> <p>Timestamp(s) included in the product's time coverage.</p> <code>None</code> <code>baseline</code> <code>str | Sequence[str]</code> <p>Baseline version(s).</p> <code>None</code> <code>orbit_and_frame</code> <code>str | Sequence[str]</code> <p>Orbit and frame identifiers.</p> <code>None</code> <code>orbit_number</code> <code>int, str, | Sequence</code> <p>Orbit number(s).</p> <code>None</code> <code>frame_id</code> <code>str | Sequence[str]</code> <p>Frame identifier(s).</p> <code>None</code> <code>filename</code> <code>str | Sequence[str]</code> <p>Specific filename(s) or regular expression patterns to match.</p> <code>None</code> <code>start_time</code> <code>TimestampLike</code> <p>First timestamp included in the product's time coverage.</p> <code>None</code> <code>end_time</code> <code>TimestampLike</code> <p>Last timestamp included in the product's time coverage.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ProductDataFrame</code> <code>ProductDataFrame</code> <p>Filtered list of matching product files as a <code>pandas.DataFrame</code>-based object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If root directory does not exist.</p> Source code in <code>earthcarekit/utils/read/product/_search.py</code> <pre><code>def search_product(\n    root_dirpath: str | None = None,\n    config: str | ECKConfig | None = None,\n    file_type: str | Sequence[str] | None = None,\n    agency: str | Sequence[str] | None = None,\n    latency: str | Sequence[str] | None = None,\n    timestamp: TimestampLike | Sequence[TimestampLike] | None = None,\n    baseline: str | Sequence[str] | None = None,\n    orbit_and_frame: str | Sequence[str] | None = None,\n    orbit_number: int | str | Sequence[int | str] | None = None,\n    frame_id: str | Sequence[str] | None = None,\n    filename: str | Sequence[str] | None = None,\n    start_time: TimestampLike | None = None,\n    end_time: TimestampLike | None = None,\n) -&gt; ProductDataFrame:\n    \"\"\"\n    Searches for EarthCARE product files matching given metadata filters.\n\n    Args:\n        root_dirpath (str, optional): Root directory to search. Defaults to directory given in a configuration file.\n        config (str | ECKConfig | None , optional): Path to a `config.toml` file or a ECKConfig instance. Defaults to the default configuration file path.\n        file_type (str | Sequence[str], optional): Product file type(s) to match.\n        agency (str | Sequence[str], optional): Producing agency or agencies (e.g. \"ESA\" or \"JAXA\").\n        latency (str | Sequence[str], optional): Data latency level(s).\n        timestamp (TimestampLike | Sequence, optional): Timestamp(s) included in the product's time coverage.\n        baseline (str | Sequence[str], optional): Baseline version(s).\n        orbit_and_frame (str | Sequence[str], optional): Orbit and frame identifiers.\n        orbit_number (int, str, | Sequence, optional): Orbit number(s).\n        frame_id (str | Sequence[str], optional): Frame identifier(s).\n        filename (str | Sequence[str], optional): Specific filename(s) or regular expression patterns to match.\n        start_time (TimestampLike, optional): First timestamp included in the product's time coverage.\n        end_time (TimestampLike, optional): Last timestamp included in the product's time coverage.\n\n    Returns:\n        ProductDataFrame: Filtered list of matching product files as a `pandas.DataFrame`-based object.\n\n    Raises:\n        FileNotFoundError: If root directory does not exist.\n    \"\"\"\n    if not isinstance(root_dirpath, str):\n        if isinstance(config, ECKConfig):\n            root_dirpath = config.path_to_data\n        else:\n            root_dirpath = read_config(config).path_to_data\n\n    if not os.path.exists(root_dirpath):\n        raise FileNotFoundError(f\"Given root directory does not exist: {root_dirpath}\")\n\n    mission_id = \"ECA\"\n\n    if isinstance(file_type, str):\n        file_type = [file_type]\n    if isinstance(file_type, Sequence):\n        _baseline: list[str] = []\n        _file_type: list[str] = []\n        for i, ft in enumerate(file_type):\n            if isinstance(ft, str):\n                _parts = ft.split(\":\")\n                if len(_parts) == 2:\n                    _file_type.append(_parts[0])\n                    _baseline.append(_parts[1])\n                    continue\n            _file_type.append(ft)\n            if isinstance(baseline, str):\n                _baseline.append(baseline)\n            elif isinstance(baseline, Sequence):\n                try:\n                    _baseline.append(baseline[i])\n                except IndexError as e:\n                    raise IndexError(e, f\"given baseline list is too small\")\n            else:\n                _baseline.append(\"latest\")\n        file_type = _file_type\n        baseline = _baseline\n    file_type = _to_file_info_list(file_type, FileType)\n    baseline = _format_input(\n        baseline,\n        file_types=file_type,\n        default_input=\"..\",\n        format_func=validate_baseline,\n    )\n    baseline_and_file_type_list = [f\"{bl}_{ft}\" for bl, ft in zip(baseline, file_type)]\n    baseline_and_file_type = _list_to_regex(\n        baseline_and_file_type_list, \".._..._..._..\"\n    )\n\n    agency = _to_file_info_list(agency, FileAgency)\n    agency = _list_to_regex(agency, \".\")\n\n    latency = _to_file_info_list(latency, FileLatency)\n    latency = _list_to_regex(latency, \".\")\n\n    timestamp = _format_input(timestamp, format_func=to_timestamp)\n    _start_time = [] if start_time is None else [to_timestamp(start_time)]\n    _end_time = [] if end_time is None else [to_timestamp(end_time)]\n    timestamp = timestamp + _start_time + _end_time\n\n    orbit_and_frame = _format_input(orbit_and_frame, format_func=format_orbit_and_frame)\n    orbit_and_frame = _list_to_regex(orbit_and_frame, \".\" * 6)\n\n    orbit_number = _format_input(orbit_number, format_func=format_orbit_number)\n    orbit_number = _list_to_regex(orbit_number, \".\" * 5)\n\n    frame_id = _format_input(frame_id, format_func=format_frame_id)\n    frame_id = _list_to_regex(frame_id, \".\")\n\n    oaf_list = []\n    oaf = \"\"\n    if orbit_number != \".\" * 5:\n        oaf_list.append(orbit_number)\n    if frame_id != \".\":\n        oaf_list.append(frame_id)\n    if orbit_number != \".\" * 5 or frame_id != \".\":\n        oaf = f\"{orbit_number}{frame_id}\"\n\n    if oaf == \"\":\n        oaf = orbit_and_frame\n    elif oaf != \"\" and orbit_and_frame != \".\" * 6:\n        oaf = f\"(({oaf})|{orbit_and_frame})\"\n\n    pattern = f\".*{mission_id}_{agency}{latency}{baseline_and_file_type}_........T......Z_........T......Z_{oaf}.h5\"\n\n    # pattern = search_pattern(\n    #     file_type=file_type,\n    #     agency=agency,\n    #     latency=latency,\n    #     timestamp=timestamp,\n    #     baseline=baseline,\n    #     orbit_and_frame=orbit_and_frame,\n    #     orbit_number=orbit_number,\n    #     frame_id=frame_id,\n    # )\n\n    if pattern == \".*ECA_...._..._..._.._........T......Z_........T......Z_.......h5\":\n        files = []\n    else:\n        files = search_files_by_regex(root_dirpath, pattern)\n\n    if isinstance(filename, str) or isinstance(filename, Sequence):\n        if isinstance(filename, str):\n            filename = [filename]\n        _get_pattern = lambda fn: f\".*{os.path.basename(fn).replace('.h5', '')}.*.h5\"\n        filename = [_get_pattern(fn) for fn in filename]\n    elif filename is None:\n        filename = []\n    else:\n        raise TypeError(\n            f\"Given filename has invalid type ({type(filename)}: {filename})\"\n        )\n\n    for fn in filename:\n        new_files = search_files_by_regex(root_dirpath, fn)\n        files.extend(new_files)\n\n    # Remove duplicates\n    files = list(set(files))\n\n    old_files = files.copy()\n    if len(timestamp) &gt; 0:\n        files = []\n        for t in timestamp:\n            new_files = [\n                f for f in old_files if _check_product_contains_timestamp(f, t)\n            ]\n            if len(new_files) &gt; 0:\n                files.extend(new_files)\n\n    pdf = get_product_infos(files)\n\n    if start_time is not None or end_time is not None:\n        _pdf = get_product_infos(old_files)\n        _pdf = filter_time_range(_pdf, start_time=start_time, end_time=end_time)\n\n        if not pdf.empty and not _pdf.empty:\n            pdf = ProductDataFrame(pd.concat([pdf, _pdf], ignore_index=True))\n        elif not _pdf.empty:\n            pdf = _pdf\n\n    pdf = pdf.sort_values(by=[\"orbit_and_frame\", \"file_type\", \"start_processing_time\"])\n    pdf = pdf.drop_duplicates()\n    pdf = pdf.reset_index(drop=True)\n\n    pdf.validate_columns()\n    return pdf\n</code></pre>"},{"location":"api_ref/stats/","title":"earthcarekit.stats","text":""},{"location":"api_ref/stats/#api-reference","title":"API reference","text":"<p>earthcarekit.stats</p> <p>Statistical utility functions.</p>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_diff_of_means","title":"nan_diff_of_means","text":"<pre><code>nan_diff_of_means(predictions, targets)\n</code></pre> <p>Difference between means of target and prediction (i.e., <code>mean(target) - mean(prediction)</code>).</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_diff_of_means(predictions: ArrayLike, targets: ArrayLike) -&gt; float:\n    \"\"\"Difference between means of target and prediction (i.e., `mean(target) - mean(prediction)`).\"\"\"\n    predictions = np.asarray(predictions)\n    targets = np.asarray(targets)\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        result = np.nanmean(targets) - np.nanmean(predictions)\n    return result\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_mae","title":"nan_mae","text":"<pre><code>nan_mae(predictions, targets)\n</code></pre> <p>Mean absolute error (MAE)</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_mae(predictions: ArrayLike, targets: ArrayLike) -&gt; float:\n    \"\"\"Mean absolute error (MAE)\"\"\"\n    predictions = np.asarray(predictions)\n    targets = np.asarray(targets)\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        result = np.nanmean(np.abs(targets - predictions))\n    return result\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_max","title":"nan_max","text":"<pre><code>nan_max(a, axis=None)\n</code></pre> <p>Compute the maximum while ignoring NaNs.</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_max(a: ArrayLike, axis: int | None = None) -&gt; NDArray | float:\n    \"\"\"Compute the maximum while ignoring NaNs.\"\"\"\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        a = np.asarray(a)\n        if len(a) &gt; 0:\n            return np.nanmax(a, axis=axis)\n        else:\n            return np.nan\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_mean","title":"nan_mean","text":"<pre><code>nan_mean(a, axis=None)\n</code></pre> <p>Compute the mean while ignoring NaNs.</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_mean(a: ArrayLike, axis: int | None = None) -&gt; NDArray | float:\n    \"\"\"Compute the mean while ignoring NaNs.\"\"\"\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        a = np.asarray(a)\n        return np.nanmean(a, axis=axis)\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_mean_diff","title":"nan_mean_diff","text":"<pre><code>nan_mean_diff(predictions, targets)\n</code></pre> <p>Mean of element-wise differences (i.e., <code>mean(target - prediction)</code>).</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_mean_diff(predictions: ArrayLike, targets: ArrayLike) -&gt; float:\n    \"\"\"Mean of element-wise differences (i.e., `mean(target - prediction)`).\"\"\"\n    predictions = np.asarray(predictions)\n    targets = np.asarray(targets)\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        result = np.nanmean(targets - predictions)\n    return result\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_min","title":"nan_min","text":"<pre><code>nan_min(a, axis=None)\n</code></pre> <p>Compute the minimum while ignoring NaNs.</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_min(a: ArrayLike, axis: int | None = None) -&gt; NDArray | float:\n    \"\"\"Compute the minimum while ignoring NaNs.\"\"\"\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        a = np.asarray(a)\n        if len(a) &gt; 0:\n            return np.nanmin(a, axis=axis)\n        else:\n            return np.nan\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_rmse","title":"nan_rmse","text":"<pre><code>nan_rmse(predictions, targets)\n</code></pre> <p>Root mean squared error (RMSE)</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_rmse(predictions: ArrayLike, targets: ArrayLike) -&gt; float:\n    \"\"\"Root mean squared error (RMSE)\"\"\"\n    predictions = np.asarray(predictions)\n    targets = np.asarray(targets)\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        result = np.sqrt(np.nanmean((targets - predictions) ** 2))\n    return result\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_sem","title":"nan_sem","text":"<pre><code>nan_sem(a, axis=None)\n</code></pre> <p>Compute the standard error of the mean while ignoring NaNs.</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_sem(a: ArrayLike, axis: int | None = None) -&gt; NDArray | float:\n    \"\"\"Compute the standard error of the mean while ignoring NaNs.\"\"\"\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        a = np.asarray(a)\n        return np.nanstd(a, axis=axis) / np.sqrt(np.size(a, axis=0))\n</code></pre>"},{"location":"api_ref/stats/#earthcarekit.stats.nan_std","title":"nan_std","text":"<pre><code>nan_std(a, axis=None)\n</code></pre> <p>Compute the standard deviation while ignoring NaNs.</p> Source code in <code>earthcarekit/utils/statistics.py</code> <pre><code>def nan_std(a: ArrayLike, axis: int | None = None) -&gt; NDArray | float:\n    \"\"\"Compute the standard deviation while ignoring NaNs.\"\"\"\n    with warnings.catch_warnings():  # ignore warings about all-nan values\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        a = np.asarray(a)\n        return np.nanstd(a, axis=axis)\n</code></pre>"},{"location":"cli/ecdownload/","title":"Download tool","text":""},{"location":"cli/ecdownload/#download-cli-tool","title":"Download CLI tool","text":"<p>Search, select, and download EarthCARE data from the command line.</p> <p>Caution</p> <p>Page status: Work in progess</p> <p>Info</p> <p>This tool is adapted from code previously hosted in the separate oads-download repository.</p> <p>Please be aware that the sub-directory names have changed from the original oads-download project.</p>"},{"location":"cli/ecdownload/#setup","title":"Setup","text":"<p>Please ensure that you've completed the Setup and created an ESA account. Depending on the data dissemination platform selected in the configuration file, the corresponding login credentials (for OADS) or non-expired data access token (for the MAAP) must be provided.</p>"},{"location":"cli/ecdownload/#usage","title":"Usage","text":"<p>For detailed explanations on how to use the CLI tool and available search criteria run the help command: </p><pre><code>ecdownload -h\n</code></pre><p></p> <p>By default, products downloaded with the script are unpacked and stored in the local data folder specified in the <code>data_directory</code> field of your <code>~/.config/earthcarekit/default_config.toml</code> file. Also, products are organized in a subfolder structure depending on the product level and the acquisition date: </p><pre><code>data_directory/\n\u251c\u2500\u2500 level1b/                 # processing level\n\u2502   \u251c\u2500\u2500 ATL_NOM_1B/          # file type\n\u2502   \u2502   \u251c\u2500\u2500 2024/            # year\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 11/          # month\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 01/      # day\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 BA/  # baseline\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 02/\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 level1c/\n\u251c\u2500\u2500 level2a/\n\u251c\u2500\u2500 level2b/\n\u251c\u2500\u2500 auxiliary_files/\n\u2514\u2500\u2500 orbit_files/\n</code></pre> To prevent this, the <code>--no_unzip</code> and <code>--no_subdirs</code> options can be used.<p></p>"},{"location":"cli/ecdownload/#logging","title":"Logging","text":"<p>On execution, log files are created in a folder called <code>logs</code> in your current working directory. These can be used to trace the execution of the script in more detail than from the console. Logging can be disabled by using the <code>--no_log</code> option.</p>"},{"location":"cli/ecdownload/#examples","title":"Examples","text":"<p>Here are selected examples that illustrate some possible use cases.</p>"},{"location":"cli/ecdownload/#example-1-how-can-i-download-specific-frames","title":"Example 1: How can I download specific frames?","text":"<p>To download the ATL_NOM_1B product for the orbit and frame 02163E you can run the command: </p><pre><code>ecdownload ATL_NOM_1B -oaf 2163E\n</code></pre> If you want to download a product from a specific processor baseline, you can specify its two-letter identifier after a colon or use the <code>--product_version</code>/<code>-pv</code> option: <pre><code>ecdownload ATL_NOM_1B:AC -oaf 2163E\n</code></pre> You can also download different product types with the same command and also use alternative shorthand aliases (see this table below). For example, the following command downloads the products ATL_NOM_1B (baseline AC), CPR_NOM_1B and MSI_RGR_1C for frame 02163E. <pre><code>ecdownload ANOM:AC MRGR CNOM -oaf 2163E\n</code></pre> You can also specify only a timestamp within the frame, e.g. if you do not know the orbit and frame identifier in advance (the <code>--time</code>/<code>-t</code> option allows flexible timestamp string formats, like <code>202410142355</code>, <code>2024-10-14T23:55</code>, ...): <pre><code>ecdownload ANOM:AC MRGR CNOM -t 2024-10-14T23:55\n</code></pre><p></p>"},{"location":"cli/ecdownload/#example-2-how-can-i-select-products-within-the-radius-of-a-ground-site","title":"Example 2: How can I select products within the radius of a ground site?","text":"<pre><code>ecdownload ATL_EBD_2A --radius 100000 16.878 -24.995 --start_time 2025-01-20T00:00:00 --end_time 2025-01-28T00:00:00\n</code></pre> With this command the script downloads all ATL_EBD_2A products that are found within a 100 km radius around Mindelo CPV between the 20th and 28th of January 2025."},{"location":"cli/ecdownload/#example-3-how-do-i-obtain-data-for-an-entire-day","title":"Example 3: How do I obtain data for an entire day?","text":"<pre><code>ecdownload AALD -st 20250101 -et 20250102\n</code></pre> This command downloads all ATL_ALD_2A products for the day of January 1 2025 (125 files) by using the <code>--start_time</code>/<code>-st</code> and <code>--end_time</code>/<code>-et</code> options."},{"location":"cli/ecdownload/#example-4-how-can-i-first-search-for-product-candidates-and-then-select-a-single-product","title":"Example 4: How can I first search for product candidates and then select a single product?","text":"<pre><code>ecdownload XORBP -t 20250130 --no_download\n</code></pre> This lists all AUX_ORBPRE files predicting the orbit on January 30 2025 without downloading them. <p>The output shows a list of found products with indices:</p> <pre><code>...\nList of files found (total number 11):\n [ 1]  ECA_EXAA_AUX_ORBPRE_20250120T000000Z_20250130T000000Z_0001\n [ 2]  ECA_EXAA_AUX_ORBPRE_20250121T000000Z_20250131T000000Z_0001\n [ 3]  ECA_EXAA_AUX_ORBPRE_20250122T000000Z_20250201T000000Z_0001\n [ 4]  ECA_EXAA_AUX_ORBPRE_20250123T000000Z_20250202T000000Z_0001\n [ 5]  ECA_EXAA_AUX_ORBPRE_20250124T000000Z_20250203T000000Z_0001\n [ 6]  ECA_EXAA_AUX_ORBPRE_20250125T000000Z_20250204T000000Z_0001\n [ 7]  ECA_EXAA_AUX_ORBPRE_20250126T000000Z_20250205T000000Z_0001\n [ 8]  ECA_EXAA_AUX_ORBPRE_20250127T000000Z_20250206T000000Z_0001\n [ 9]  ECA_EXAA_AUX_ORBPRE_20250128T000000Z_20250207T000000Z_0001\n [10]  ECA_EXAA_AUX_ORBPRE_20250129T000000Z_20250208T000000Z_0001\n [11]  ECA_EXAA_AUX_ORBPRE_20250130T000000Z_20250209T000000Z_0001\nNote: To export this list use the option --export_results\nNote: To select only one specific file use the option -i/--select_file_at_index\n...\n</code></pre> <p>To download a single file from this list you can specify its index. To select the last file set the index to -1:</p> <pre><code>$ ecdownload XORBP -t 20250130 -i -1\n...\nList of files found (total number 11):\n [ 1]  ECA_EXAA_AUX_ORBPRE_20250120T000000Z_20250130T000000Z_0001\n [ 2]  ECA_EXAA_AUX_ORBPRE_20250121T000000Z_20250131T000000Z_0001\n [ 3]  ECA_EXAA_AUX_ORBPRE_20250122T000000Z_20250201T000000Z_0001\n [ 4]  ECA_EXAA_AUX_ORBPRE_20250123T000000Z_20250202T000000Z_0001\n [ 5]  ECA_EXAA_AUX_ORBPRE_20250124T000000Z_20250203T000000Z_0001\n [ 6]  ECA_EXAA_AUX_ORBPRE_20250125T000000Z_20250204T000000Z_0001\n [ 7]  ECA_EXAA_AUX_ORBPRE_20250126T000000Z_20250205T000000Z_0001\n [ 8]  ECA_EXAA_AUX_ORBPRE_20250127T000000Z_20250206T000000Z_0001\n [ 9]  ECA_EXAA_AUX_ORBPRE_20250128T000000Z_20250207T000000Z_0001\n [10]  ECA_EXAA_AUX_ORBPRE_20250129T000000Z_20250208T000000Z_0001\n&lt;[11]&gt; ECA_EXAA_AUX_ORBPRE_20250130T000000Z_20250209T000000Z_0001 &lt;-- Select file (user input: -1)\nNote: To export this list use the option --export_results\n...\n</code></pre>"},{"location":"cli/ecdownload/#further-examples-how-to-download-orbit-ranges","title":"Further examples: How to download orbit ranges?","text":"<p>Download all D and B frames from orbit 3000 to 3009 (20 files):</p> <pre><code>ecdownload AALD -f D B -so 3000 -eo 3009\n</code></pre> <p>Download all frames between 01300D and 01302B (15 files):</p> <pre><code>ecdownload AALD -soaf 01300D -eoaf 01302B\n</code></pre>"},{"location":"cli/ecdownload/#tables-of-product-name-aliases","title":"Tables of product name aliases","text":""},{"location":"cli/ecdownload/#level-1-products","title":"Level 1 products","text":"Product name File type Shorthand Notes A-NOM ATL_NOM_1B ANOM M-NOM MSI_NOM_1B MNOM B-NOM BBR_NOM_1B BNOM C-NOM CPR_NOM_1B CNOM JAXA product M-RGR MSI_RGR_1C MRGR Calibration products Product name File type Shorthand Notes A-DCC ATL_DCC_1B ADCC A-CSC ATL_CSC_1B ACSC A-FSC ATL_FSC_1B AFSC M-BBS MSI_BBS_1B MBBS M-SD1 MSI_SD1_1B MSD1 M-SD2 MSI_SD2_1B MSD2 B-SNG BBR_SNG_1B BSNG B-SOL BBR_SOL_1B BSOL B-LIN BBR_LIN_1B BLIN"},{"location":"cli/ecdownload/#level-2a-products","title":"Level 2a products","text":"Product name File type Shorthand Notes A-FM ATL_FM__2A AFM A-AER ATL_AER_2A AAER A-ICE ATL_ICE_2A AICE A-TC ATL_TC__2A ATC A-EBD ATL_EBD_2A AEBD A-CTH ATL_CTH_2A ACTH A-ALD ATL_ALD_2A AALD M-CM MSI_CM__2A MCM M-COP MSI_COP_2A MCOP M-AOT MSI_AOT_2A MAOT C-FMR CPR_FMR_2A CFMR C-CD CPR_CD__2A CCD C-TC CPR_TC__2A CTC C-CLD CPR_CLD_2A CCLD C-APC CPR_APC_2A CAPC A-CLA ATL_CLA_2A ACLA JAXA product M-CLP MSI_CLP_2A MCLP JAXA product C-ECO CPR_ECO_2A CECO JAXA product C-CLP CPR_CLP_2A CCLP JAXA product"},{"location":"cli/ecdownload/#level-2b-products","title":"Level 2b products","text":"Product name File type Shorthand Notes AM-MO AM__MO__2B AMMO AM-CTH AM__CTH_2B AMCTH AM-ACD AM__ACD_2B AMACD AC-TC AC__TC__2B ACTC BM-RAD BM__RAD_2B BMRAD BMA-FLX BMA_FLX_2B BMAFLX ACM-CAP ACM_CAP_2B ACMCAP ACM-COM ACM_COM_2B ACMCOM ACM-RT ACM_RT__2B ACMRT ACMB-3D ALL_3D__2B ALL3D ACMB-DF ALL_DF__2B ALLDF AC-CLP AC__CLP_2B ACCLP JAXA product ACM-CLP ACM_CLP_2B ACMCLP JAXA product ACMB-RAD ALL_RAD_2B ALLRAD JAXA product"},{"location":"cli/ecdownload/#auxiliary-data","title":"Auxiliary data","text":"Product name File type Shorthand Notes X-MET AUX_MET_1D XMET X-JSG AUX_JSG_1D XJSG"},{"location":"cli/ecdownload/#orbit-data","title":"Orbit data","text":"Product name File type Shorthand Notes ORBSCT MPL_ORBSCT MPLORBS Orbit scenario ORBPRE AUX_ORBPRE XORBP Predicted orbit ORBRES AUX_ORBRES XORBR Reconstructed orbit"},{"location":"cli/ecquicklook/","title":"Quicklook tool","text":""},{"location":"cli/ecquicklook/#quicklook-cli-tool","title":"Quicklook CLI tool","text":"<p>Create fast quicklooks of your local EarthCARE products via the command line.</p> <p>Caution</p> <p>Page status: Work in progess</p>"},{"location":"cli/ecquicklook/#setup","title":"Setup","text":"<p>Please ensure that you've completed the Setup and that you have copied or downloaded EarthCARE data to your data directory.</p>"},{"location":"cli/ecquicklook/#usage","title":"Usage","text":"<p>For detailed explanations on how to use the CLI tool run the help command: </p><pre><code>ecquicklook -h\n</code></pre><p></p>"},{"location":"tutorials/profiles/","title":"Working with profiles","text":""},{"location":"tutorials/profiles/#working-with-profiles","title":"Working with profiles","text":"<p>This tutorial gives an introduction to the <code>ProfileData</code> class and it's use in <code>earthcarekit</code>.</p> <p>Begin by importing the following modules:</p> <pre><code>import earthcarekit as eck\nimport numpy as np\nimport pandas as pd\n</code></pre> <p>The class <code>ProfileData</code> is a container for atmospheric profile data. It stores profile values together with their time/height bins and, optionally, their coordinates and other metadata (e.g., label and units) in a consistent structure, making profiles easier to handle, compare and visualise.</p>"},{"location":"tutorials/profiles/#overview","title":"Overview","text":"<p><code>ProfileData</code> requires at least three inputs:</p> <ul> <li>values - the profile data, either of a single vertical profile or a time series of profiles (2D array with time as the first dimension and height as the second).</li> <li>height - an array or time series of arrays of ascending height bin centers.</li> <li>time - an array of ascending timestamps corresponding to the profiles.</li> </ul> <pre><code>p = eck.ProfileData(\n    values=[\n        [0, 0.4, 1, 1, 0.6, 0],  # 1 profile (6 bins)\n    ],\n    height=[0e3, 5e3, 10e3, 15e3, 20e3, 25e3],  # 6 bin centers (can also be 2D if same shape as values)\n    time=[\"2025-01-01T00:00\"],  # 1 timestamp for the single profile in values\n)\nprint(p)\n</code></pre> See output ... <pre><code>ProfileData(values=array([[0. , 0.4, 1. , 1. , 0.6, 0. ]]), height=array([    0.,  5000., 10000., 15000., 20000., 25000.]), time=array(['2025-01-01T00:00:00.000000000'], dtype='datetime64[ns]'), latitude=None, longitude=None, color=None, label=None, units=None, platform=None, error=None)\n</code></pre> <p>To create a quick plot use the <code>ProfileFigure</code> class:</p> <pre><code>pf = eck.ProfileFigure().plot(p)\npf.save(filepath=\"profile1.png\")\n</code></pre> <code>profile1.png</code> <p>Alternatively, you can initialize a <code>ProfileData</code> object from data stored in a <code>xarray.Dataset</code>, e.g., from a EarthCARE product:</p> <pre><code>fp = r\"./ECA_EXBA_ATL_EBD_2A_20240902T210023Z_20250721T110708Z_01508B.h5\"  # Replace path with one of your local files\nwith eck.read_any(fp) as ds:\n    p_from_ec = eck.ProfileData.from_dataset(\n        ds=ds,\n        var=\"particle_linear_depol_ratio_355nm_medium_resolution\",  # Select a valid variable from the dataset\n    )\n\n    # Plotting the profile data in a time/height curtain plot\n    cf = eck.CurtainFigure().plot(p_from_ec, cmap=\"ratio\", value_range=(0, 0.6), height_range=(0, 20e3))  # Custommize curtain plot settings\n    cf.save(filepath=\"profile_curtain_from_ec.png\")\n\n    # Plotting the profile (i.e., the mean and STD)\n    pf = eck.ProfileFigure(height_range=(0, 20e3)).plot(p_from_ec)\n    pf.save(filepath=\"profile_from_ec.png\")\n</code></pre> <code>profile_curtain_from_ec.png</code> <code>profile_from_ec.png</code>"},{"location":"tutorials/profiles/#selection-by-height-range","title":"Selection by height range","text":"<pre><code># Generating example data\nnh = 1000  # Number of height bins\nh = np.linspace(0, 40e3, nh)  # Height values in meters\nv = np.abs(np.sin(np.linspace(np.pi*3, -np.pi, nh)) * h)  # Signal values\nv = v / np.max(v)\n\np = eck.ProfileData(\n    values=v,\n    height=h,\n    time=[\"2025-01-01T00:00\"],\n)\n\n# Plotting\npf = eck.ProfileFigure().plot(p)\npf.save(filepath=\"single_profile1.png\")\n</code></pre> <code>single_profile1.png</code> <pre><code>height_range = (5e3, 15e3)  # in meters\np_selected = p.select_height_range(height_range)\n\n# Plotting\npf = eck.ProfileFigure(label=\"The variable name\", units=\"some units\", show_legend=True, value_range=(0, 1))\npf = pf.plot(p, linestyle=\"dotted\", legend_label=\"original\")\npf = pf.plot(p_selected, linewidth=3, legend_label=\"selected\")\npf.save(filepath=\"single_profile2.png\")\n</code></pre> <code>single_profile2.png</code> <p>You can also mark the selected height range only in the plot:</p> <pre><code>pf = eck.ProfileFigure(value_range=(0,1))\npf = pf.plot(p, selection_height_range=(5e3, 15e3))\npf.save(filepath=\"single_profile3.png\")\n</code></pre> <code>single_profile3.png</code>"},{"location":"tutorials/profiles/#rebinning","title":"Rebinning","text":"<pre><code>new_height = np.linspace(0, 40e3, 11)  # Generated list of height bin centers\n\np_rebin_mean = p.rebin_height(new_height)\np_rebin_interp = p.rebin_height(new_height, method=\"interpolate\")\n\n# Plotting\npf = eck.ProfileFigure(label=\"The variable name\", units=\"some units\", show_legend=True, value_range=(0,1))\npf = pf.plot(p, legend_label=\"profile\")\npf = pf.plot(p_rebin_mean, legend_label='rebin (method = \"mean\")')\npf = pf.plot(p_rebin_interp, legend_label='rebin (method = \"interpolate\")')\npf.save(filepath=\"rebinned_profile1.png\")\n</code></pre> <code>rebinned_profile1.png</code>"},{"location":"tutorials/profiles/#calculating-statistics","title":"Calculating statistics","text":"<pre><code>results = p.stats()\nprint(results)\n</code></pre> See output ... <pre><code>ProfileStatResults(hmin=0.0, hmax=40000.0, mean=0.3619352437163005, std=0.2874920456912103, mean_error=None)\n</code></pre> <pre><code>results2 = p.stats(height_range=(7_500, 12_500))\nresults3 = p.stats(height_range=(12_500, 17_500))\n\n# Create a dataframe\ndf = pd.concat([\n    results.to_dataframe(),\n    results2.to_dataframe(),\n    results3.to_dataframe(),\n], ignore_index=True)\n</code></pre> hmin hmax mean std mean_error 0 0 40000 0.361935 0.287492 nan 1 7500 12500 0.106411 0.063519 nan 2 12500 17500 0.384492 0.0501576 nan"},{"location":"tutorials/profiles/#comparing-profiles","title":"Comparing profiles","text":"<p>We compare the two rebinned profiles from the above section on Rebinning. Here, <code>p_rebin_mean</code> is the prediction and <code>p_rebin_interp</code> the target.</p> <pre><code>results = p_rebin_mean.compare_to(p_rebin_interp)\ndisplay(results.to_dataframe())  # works only in a Jupyter notebook\n\n# Plotting\npf = eck.ProfileFigure(label=\"The variable name\", units=\"some units\", show_legend=True, value_range=(0,1))\npf = pf.plot(p_rebin_mean, legend_label='rebin (method = \"mean\")',color=\"tab:orange\")\npf = pf.plot(p_rebin_interp, legend_label='rebin (method = \"interpolate\")',color=\"tab:green\")\npf.save(filepath=\"compared_profiles.png\")\n</code></pre> hmin hmax diff_of_means mae rmse mean_diff mean_prediction std_prediction mean_error_prediction mean_target std_target mean_error_target 0 0 40000 -0.0256926 0.0668805 0.115323 -0.0256926 0.344468 0.251908 nan 0.318775 0.303957 nan <code>compared_profiles.png</code>"},{"location":"tutorials/profiles/#timeseries-of-profiles","title":"Timeseries of profiles","text":"<pre><code># Generating example data\nnh = 100  # Number of height bins\nh = np.linspace(0, 40e3, nh)\n\nnt = 300  # Number of (temporal) samples\ny = np.linspace(-0.5, 0.5, nh)\nx = np.linspace(-1, 2, nt)\ngx, gy = np.meshgrid(x, y)\nr = np.sqrt(gx**2 + gy**2)\nv = np.sin(50 * r).T\nv = np.abs(v) * np.linspace(1, 0.1, nh)\n\np = eck.ProfileData(\n    values=v,\n    height=h,\n    time=pd.date_range(\"20250101T00\", \"20250101T12\", periods=nt),\n)\n\n# PLotting\ncf = eck.CurtainFigure().plot(p, value_range=(0,1))\ncf.save(filepath=\"ts_curtain.png\")\n\npf = eck.ProfileFigure().plot(p, value_range=(0,1))\npf.save(filepath=\"ts_profile.png\")\n</code></pre> <code>ts_curtain.png</code> <code>ts_profile.png</code>"},{"location":"tutorials/profiles/#get-the-mean-profile","title":"Get the mean profile","text":"<pre><code>p_mean = p.mean()\n# p.shape=(300, 100)\n# p_mean.shape=(1, 100)\n\n# Plotting\npf = eck.ProfileFigure().plot(p_mean, value_range=(0,1))\npf.save(filepath=\"ts_mean_profile.png\")\n</code></pre> <code>ts_mean_profile.png</code>"},{"location":"tutorials/profiles/#apply-rolling-mean-or-moving-average","title":"Apply rolling mean (or moving average)","text":"<pre><code>p_roll = p.rolling_mean(20, axis=0)\n# p.shape=(300, 100)\n# p_roll.shape=(300, 100)\n\n# Plotting\ncf = eck.CurtainFigure().plot(p_roll, value_range=(0,1))\npf.save(filepath=\"ts_rolling_curtain.png\")\n\npf = eck.ProfileFigure().plot(p_roll, value_range=(0,1))\npf.save(filepath=\"ts_rolling_profile.png\")\n</code></pre> <code>ts_rolling_curtain.png</code> <code>ts_rolling_profile.png</code>"},{"location":"tutorials/profiles/#coarsen-profiles","title":"Coarsen profiles","text":"<pre><code>p_coarsened = p.coarsen_mean(20)\n# p.shape=(300, 100)\n# p_coarsened.shape=(15, 100)\n\n# Plotting\ncf = eck.CurtainFigure().plot(p_coarsened, value_range=(0,1))\ncf.save(filepath=\"ts_coarse_curtain.png\")\n\npf = eck.ProfileFigure().plot(p_coarsened, value_range=(0,1))\npf.save(filepath=\"ts_coarse_profile.png\")\n</code></pre> <code>ts_coarse_curtain.png</code> <code>ts_coarse_profile.png</code>"},{"location":"tutorials/profiles/#rebin-to-new-height-bins","title":"Rebin to new height bins","text":"<pre><code>height_bin_centers = [0, 5e3, 10e3, 15e3, 20e3, 25e3, 30e3, 35e3, 40e3]\np_rebinned_height_mean = p.rebin_height(height_bin_centers)\np_rebinned_height_interp = p.rebin_height(height_bin_centers, method=\"interpolate\")\n\n# Plotting\ncf = eck.CurtainFigure().plot(p_rebinned_height_mean, value_range=(0,1))\ncf.save(filepath=\"ts_rebin_height_mean_curtain.png\")\n\ncf = eck.CurtainFigure().plot(p_rebinned_height_interp, value_range=(0,1))\ncf.save(filepath=\"ts_rebin_height_interp_curtain.png\")\n</code></pre> <code>ts_rebin_height_mean_curtain.png</code> <code>ts_rebin_height_interp_curtain.png</code>"},{"location":"tutorials/profiles/#rebin-to-new-time-bins","title":"Rebin to new time bins","text":"<pre><code>time_bin_centers = pd.date_range(\"20250101T00\", \"20250101T12\", periods=30)  # 30 instead of 300 time bins\np_rebinned_time_mean = p.rebin_time(time_bin_centers)\np_rebinned_time_interp = p.rebin_time(time_bin_centers, method=\"interpolate\")\n\n# Plotting\ncf = eck.CurtainFigure().plot(p_rebinned_time_mean, value_range=(0,1))\ncf.save(filepath=\"ts_rebin_time_mean_curtain.png\")\n\ncf = eck.CurtainFigure().plot(p_rebinned_time_interp, value_range=(0,1))\ncf.save(filepath=\"ts_rebin_time_interp_curtain.png\")\n</code></pre> <code>ts_rebin_time_mean_curtain.png</code> <code>ts_rebin_time_interp_curtain.png</code>"},{"location":"tutorials/quickstart/","title":"Quickstart","text":""},{"location":"tutorials/quickstart/#quickstart","title":"Quickstart","text":"<p>This page gives a brief example introducing the earthcarekit module. First, make sure to complete the setup.</p> <p>Afterwards, begin by importing the module:</p> <pre><code>import earthcarekit as eck\n</code></pre>"},{"location":"tutorials/quickstart/#download-earthcare-data","title":"Download EarthCARE Data","text":"<p>To download your first EarthCARE product run this:</p> <pre><code>eck.ecdownload(file_type=\"ATL_EBD_2A\", orbit_and_frame=\"5976B\")\n</code></pre> See output ... <pre><code>#======================================================================#\n#                       EarthCARE Download Tool                        #\n#                         earthcarekit 0.9.2                           #\n#======================================================================#\n# Settings\n# - is_download=True\n# - is_overwrite=False\n# - is_unzip=True\n# - is_delete=True\n# - is_create_subdirs=True\n# - is_log=False\n# - is_debug=False\n# - is_export_results=False\n# - idx_selected_input=None\n# - config_filepath=&lt;~/.config/earthcarekit/default_config.toml&gt;\n# - data_dirpath=&lt;~/path_to_data&gt;\n\n+----------------------------------------------------------------------+\n| STEP 1/2 - Search products                       2025-10-28 14:06:01 |\n+----------------------------------------------------------------------+\n\n*[1/1] Search request: ATL_EBD_2A, frame=B, orbits=[5976]\n [1/1] Files found in collection 'EarthCAREL2Validated': 1\n\nList of files found (total number 1):\n [1]  ECA_EXBA_ATL_EBD_2A_20250617T002721Z_20250929T173356Z_05976B\nNote: To export this list use the option --export_results\nNote: To select only one specific file use the option -i/--select_file_at_index\n\n+----------------------------------------------------------------------+\n| STEP 2/2 - Download products                     2025-10-28 14:06:01 |\n+----------------------------------------------------------------------+\n\n*[1/1] Starting: ECA_EXBA_ATL_EBD_2A_20250617T002721Z_20250929T173356Z_05976B\n [1/1] Authenticate at dissemination service: ec-pdgs-dissemination2.eo.esa.int\n [1/1] Download completed (00:00:29 - 2.58 MB/s - 76.08/76.08 MB)                   \n [1/1] File extracted and ZIP-file deleted. (see &lt;~/path_to_data/level2a/ATL_EBD_2A/2025/06/17/BA/ECA_EXBA_ATL_EBD_2A_20250617T002721Z_20250929T173356Z_05976B&gt;)\n\n+----------------------------------------------------------------------+\n| EXECUTION SUMMARY                                2025-10-28 14:06:09 |\n+----------------------------------------------------------------------+\n| Time taken          00:00:09                                         |\n| API search requests 1                                                |\n| Remote files found  1                                                |\n| Files downloaded    1 (17.07 MB at ~3.49 MB/s)                       |\n| Files unzipped      1                                                |\n| Errors occured      0                                                |\n+----------------------------------------------------------------------+\n</code></pre> <p>This will download the latest ATLID extinction backscatter, and depolarization product (A-EBD), specifically from the EarthCARE frame B of orbit 5976. You can monitor the download progress from the output log messages.</p>"},{"location":"tutorials/quickstart/#search-local-files","title":"Search Local Files","text":"<p>Now search the file in your local data directory:</p> <pre><code>dataframe = eck.search_product(file_type=\"ATL_EBD_2A\", orbit_and_frame=\"5976B\")\n\n# View the search results\nprint(dataframe)\n\n# Or, if in a Jupyter notebook, show in tabular format by using\ndisplay(dataframe)\n</code></pre> See output ... mission_id agency latency baseline file_type start_sensing_time start_processing_time orbit_number frame_id orbit_and_frame name filepath hdr_filepath 0 ECA E X AG ATL_EBD_2A 2025-06-17 00:27:21 2025-06-17 02:48:37 5976 B 05976B ECA_EXAG_ATL_EBD_2A_... ~/path_to_data/... ~/path_to_data/..."},{"location":"tutorials/quickstart/#openread-a-dataset","title":"Open/Read a Dataset","text":"<p>Now you can get the file path from the resulting <code>ProductDataFrame</code>:</p> <pre><code>filepath = dataframe.filepath[0]\nprint(filepath)\n</code></pre> See output ... <pre><code>~/path_to_data/level2a/ATL_EBD_2A/2025/06/17/ECA_EXAG_ATL_TC__2A_20250617T002721Z_20250617T024837Z_05976B/ECA_EXAG_ATL_TC__2A_20250617T002721Z_20250617T024837Z_05976B.h5\n</code></pre> <p>To open a dataset use the <code>eck.read_product</code> which is based on <code>xarray.open_dataset</code>. To prevent open file handles, memory leaks, and locked dataset files it is best practice to open files using a <code>with</code> statement:</p> <pre><code>with eck.read_product(filepath) as dataset:\n    print(dataset)\n\n    # Or, if in a notebook\n    display(dataset)\n</code></pre> See output ... <pre><code>&lt;xarray.Dataset&gt; Size: 234MB\nDimensions:                                                         (\n                                                                     along_track: 4946,\n                                                                     vertical: 242,\n                                                                     layer: 25,\n                                                                     n_state: 351)\nDimensions without coordinates: along_track, vertical, layer, n_state\nData variables: (12/74)\n    filename                                                        &lt;U60 240B ...\n    file_type                                                       &lt;U10 40B ...\n    frame_id                                                        &lt;U1 4B 'B'\n    orbit_number                                                    uint32 4B ...\n    orbit_and_frame                                                 &lt;U6 24B '...\n    baseline                                                        &lt;U2 8B 'AG'\n    ...                                                              ...\n    lidar_ratio_355nm_low_resolution_error                          (along_track, vertical) float32 5MB ...\n    retrieved_state_vector                                          (along_track, n_state) float32 7MB ...\n    state_vector_prior                                              (along_track, n_state) float32 7MB ...\n    state_vector_prior_error                                        (along_track, n_state) float32 7MB ...\n    final_chi_square                                                (along_track) float32 20kB ...\n    initial_chi_square                                              (along_track) float32 20kB ...\n</code></pre>"},{"location":"tutorials/quickstart/#create-your-first-plots","title":"Create your first plots","text":"<p><code>earthcarekit</code> provides a set of figure objects:</p> <ul> <li><code>MapFigure</code> - for plotting data on a map (e.g., the satellite's track or geolocated swath data from MSI)</li> <li><code>CurtainFigure</code> - for plotting time series of vertical profile data (i.e., 2D time/height plots of ATLID and CPR \"curtain\" data)</li> <li><code>ProfileFigure</code> - for plotting single or mean vertical profiles as signal/height line plots</li> <li><code>SwathFigure</code> - for plotting time series of across-track swath data (i.e., 2D time/swath plot)</li> <li><code>LineFigure</code> - for plotting time series of 1D along-track data (i.e., tropopause height, latitude, data quality flags, ...)</li> </ul> <p>Each of these implements (among others) two methods:</p> <ol> <li><code>ecplot</code> - for handeling EarthCARE datasets</li> <li><code>plot</code> - for manual data input (profiles, values, time, height, etc.)</li> </ol>"},{"location":"tutorials/quickstart/#plot-a-track-on-a-map","title":"Plot a track on a map","text":"<p>To get a general sense of the satellites track, you may start by plotting a simple map:</p> <pre><code>with eck.read_product(filepath) as dataset:\n    map_figure = eck.MapFigure().ecplot(dataset)\n\n    # Save the image\n    eck.save_plot(map_figure, filepath=\"simple_map.png\")\n</code></pre> <code>simple_map.png</code>"},{"location":"tutorials/quickstart/#create-simple-curtain-plots","title":"Create simple curtain plots","text":"<p>To make a time/height or curtain plot of the vertically resolved atmospheric profile data stored in the current A-EBD dataset, you can use a <code>CurtainFigure</code> object:</p> <pre><code>with eck.read_product(filepath) as dataset:\n    curtain_figure = eck.CurtainFigure()\n    curtain_figure = curtain_figure.ecplot(\n        dataset,\n        var=\"particle_backscatter_coefficient_355nm_low_resolution\",\n        height_range=(0, 20e3),  # Show only data within 20km height\n    )\n\n    # Save the image\n    eck.save_plot(curtain_figure, filepath=\"simple_curtain.png\")\n</code></pre> <code>simple_curtain.png</code> <p>You can enhance the plot with overlays of elevation and tropopause height from datasets that store this information (in this case, A-EBD already contains both):</p> <pre><code>with eck.read_product(filepath) as dataset:\n    curtain_figure = eck.CurtainFigure().ecplot(\n        dataset,\n        var=\"particle_backscatter_coefficient_355nm_low_resolution\",\n        height_range=(0, 20e3),  # Show only data within 20km height\n\n    )\n    curtain_figure.ecplot_elevation(dataset)  # NEW\n    curtain_figure.ecplot_tropopause(dataset)  # NEW\n\n    # Save the image\n    eck.save_plot(curtain_figure, filepath=\"curtain_with_elevation_and_tropopause.png\")\n</code></pre> <code>simple_curtain_with_elevation_and_tropopausecurtain.png</code>"},{"location":"tutorials/quickstart/#select-along-track-data-and-plot-profiles","title":"Select along-track data and plot profiles","text":""},{"location":"tutorials/quickstart/#select-by-time","title":"Select by time","text":"<pre><code>time_range = (\"2025-06-17T00:29\", \"2025-06-17T00:30:30\")\n\nwith eck.read_product(filepath) as dataset:\n    dataset_filtered = eck.filter_time(ds=dataset, time_range=time_range)\n\n    # Plot the track on a map and mark the selected time range\n    map_figure = eck.MapFigure().ecplot(\n        ds=dataset,\n        time_range=time_range,\n    )\n\n    # Plot a curtain of the whole EarthCARE frame with the time_range marked\n    curtain_figure = eck.CurtainFigure().ecplot(\n        ds=dataset,\n        var=\"particle_backscatter_coefficient_355nm_low_resolution\",\n        height_range=(0, 15e3),  # Show only data within 15km height\n        selection_time_range=time_range,\n    )\n\n    # Plot the mean profile of the filtered data (with STD error ribbon)\n    profile_figure = eck.ProfileFigure().ecplot(\n        ds=dataset_filtered,  # Use the filtered dataset here\n        var=\"particle_backscatter_coefficient_355nm_low_resolution\",\n        height_range=(0, 15e3),  # Show only data within 15km height\n        # value_range=(0, 1e-8),  # You may adjust the x-axis plotting range\n    )\n\n    # Save the images\n    eck.save_plot(map_figure, filepath=\"map_selection_time_range.png\")\n    eck.save_plot(curtain_figure, filepath=\"curtain_selection_time_range.png\")\n    eck.save_plot(profile_figure, filepath=\"profile_selection_time_range.png\")\n</code></pre> <code>map_selection_time_range.png</code> <code>curtain_selection_time_range.png</code> <code>profile_selection_time_range.png</code>"},{"location":"tutorials/quickstart/#select-by-radius","title":"Select by radius","text":"<pre><code>site = eck.GroundSite(\n    name=\"TROPOS\",\n    latitude=51.352757,\n    longitude=12.43392,\n    altitude=125,\n)\n\nwith eck.read_product(filepath) as dataset:\n    dataset_filtered = eck.filter_radius(\n        ds=dataset,\n        radius_km=100,\n        site=site,\n        closest=True, # Since we are using a A-EBD dataset, we should only select the closest profile\n    )\n\n    # Plot the overpass on a map\n    map_figure = eck.MapFigure(\n        style=\"satellite\",\n    ).ecplot(\n        ds=dataset,\n        site=site,\n        radius_km=100,\n        view=\"overpass\",\n    )\n\n    # Plot a curtain of the whole EarthCARE frame with the time_range marked\n    curtain_figure = eck.CurtainFigure().ecplot(\n        ds=dataset,\n        var=\"particle_backscatter_coefficient_355nm_low_resolution\",\n        height_range=(0, 15e3),  # Show only data within 15km height\n        site=site,\n    )\n\n    display(dataset_filtered)\n\n    # Plot the mean profile of the filtered data (with STD error ribbon)\n    profile_figure = eck.ProfileFigure().ecplot(\n        ds=dataset_filtered,  # Use the filtered dataset here\n        var=\"particle_backscatter_coefficient_355nm_low_resolution\",\n        height_range=(0, 15e3),  # Show only data within 15km height\n        value_range=(0, 3e-6),  # You may adjust the x-axis plotting range\n    )\n\n    # Save the images\n    eck.save_plot(map_figure, filepath=\"map_selection_radius_range.png\")\n    eck.save_plot(curtain_figure, filepath=\"curtain_selection_radius_range.png\")\n    eck.save_plot(profile_figure, filepath=\"profile_selection_radius_range.png\")\n</code></pre> <code>map_selection_radius_range.png</code> <code>curtain_selection_radius_range.png</code> <code>profile_selection_radius_range.png</code>"},{"location":"tutorials/xmet_rebin_along_track/","title":"Rebin X-MET along-track","text":""},{"location":"tutorials/xmet_rebin_along_track/#rebin-x-met-along-track","title":"Rebin X-MET along-track","text":"<p>The AUX_MET_1D (X-MET) product stores modeled meteorological parameters from ECMWF in a spacial grid around the EarthCARE swath. To match the vertical along-track cross-section of another Product, X-MET data can be rebinned (by interpolation) using the rebin_xmet_to_vertical_track function.</p> <pre><code>import earthcarekit as eck\n\nfile_types = [\"anom\", \"xmet\"]\norbit_and_frame = \"01508B\"\n\n# Download required data\neck.ecdownload(\n    file_type=file_types,\n    orbit_and_frame=orbit_and_frame,\n)\n\n# Get product file paths\ndf = eck.search_product(\n    file_type=file_types,\n    orbit_and_frame=orbit_and_frame,\n)\nfp_anom = df.filter_file_type(\"anom\").filepath[-1]\nfp_xmet = df.filter_file_type(\"xmet\").filepath[-1]\n\n# Open both datasets\nwith (\n    eck.read_product(fp_anom) as ds_anom,\n    eck.read_product(fp_xmet) as ds_xmet_original,\n):\n    print(f\"A-NOM dims: {ds_anom.sizes}\")\n    print(f\"X-MET dims before rebin: {ds_xmet_original.sizes}\")\n\n    # Rebin X-MET to A-NOM along_track/vertical grid\n    ds_xmet = eck.rebin_xmet_to_vertical_track(\n        ds_xmet=ds_xmet_original,\n        ds_vert=ds_anom,\n    )\n\n    print(f\"X-MET dims after rebin: {ds_xmet.sizes}\")\n</code></pre> See output ... <pre><code>A-NOM dims: Frozen({'along_track': 18023, 'height_raw': 256, 'background': 2, 'vertical': 254, 'segments': 6})\nX-MET dims before rebin: Frozen({'horizontal_grid': 25615, 'height': 137})\nX-MET dims after rebin: Frozen({'along_track': 18023, 'vertical': 254})\n</code></pre>"},{"location":"tutorials/xmet_rebin_along_track/#plotting-examples","title":"Plotting examples","text":"<pre><code>cf = eck.CurtainFigure()\ncf = cf.ecplot(\n    ds=ds_xmet,\n    var=\"temperature_celsius\",\n    height_range=(0, 15e3),\n    value_range=(-70, 30),\n    cmap=eck.shift_cmap(\"RdBu_r\", midpoint=0.7),\n)\ncf.save(filepath=\"xmet_curtain.png\")\n\ncf.ecplot_temperature(ds_xmet)\ncf.save(filepath=\"xmet_curtain_with_temperature_lines.png\")\n</code></pre> <code>xmet_curtain.png</code> <code>xmet_curtain_with_temperature_lines.png</code> <pre><code>cf2 = eck.CurtainFigure()\ncf2 = cf2.ecplot(\n    ds=ds_anom,\n    var=\"mie_attenuated_backscatter\",\n    height_range=(0, 20e3),\n)\ncf2.ecplot_pressure(ds_xmet, colors=\"white\")\ncf2.ecplot_elevation(ds_anom, color=\"black\")\ncf2.save(filepath=\"anom_curtain_with_pressure_lines.png\")\n</code></pre> <code>anom_curtain_with_pressure_lines.png</code> <pre><code>cf3 = eck.CurtainFigure()\ncf3 = cf3.ecplot(\n    ds=ds_anom,\n    var=\"mie_attenuated_backscatter\",\n    height_range=(0, 20e3),\n)\ncf3 = cf3.ecplot_contour(\n    ds=ds_xmet,\n    var=\"relative_humidity\",\n    levels=[0.25, 0.5, 0.75],\n    colors=[\"white\", \"magenta\", \"lime\"],\n    # linestyles=...,\n    # linewidths=...,\n)\ncf3.ecplot_elevation(ds_anom, color=\"black\")\ncf3.save(filepath=\"anom_curtain_with_xmet_lines.png\")\n</code></pre> <code>anom_curtain_with_xmet_lines.png</code>"}]}